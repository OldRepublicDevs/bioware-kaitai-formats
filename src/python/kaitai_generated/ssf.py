# This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild
# type: ignore

import kaitaistruct
from kaitaistruct import KaitaiStruct, KaitaiStream, BytesIO


if getattr(kaitaistruct, 'API_VERSION', (0, 9)) < (0, 11):
    raise Exception("Incompatible Kaitai Struct Python API: 0.11 or later is required, but you have %s" % (kaitaistruct.__version__))

class Ssf(KaitaiStruct):
    """SSF (Sound Set File) files store sound string references (StrRefs) for character voice sets.
    Each SSF file contains exactly 28 sound slots, mapping to different game events and actions.
    
    Binary Format:
    - Header (12 bytes): File type signature, version, and offset to sounds array
    - Sounds Array (112 bytes): 28 uint32 values representing StrRefs (0xFFFFFFFF = -1 = no sound)
    - Padding (12 bytes): 3 uint32 values of 0xFFFFFFFF (reserved/unused)
    
    Total file size: 136 bytes (12 + 112 + 12)
    
    Sound Slots (in order):
    0-5: Battle Cry 1-6
    6-8: Select 1-3
    9-11: Attack Grunt 1-3
    12-13: Pain Grunt 1-2
    14: Low Health
    15: Dead
    16: Critical Hit
    17: Target Immune
    18: Lay Mine
    19: Disarm Mine
    20: Begin Stealth
    21: Begin Search
    22: Begin Unlock
    23: Unlock Failed
    24: Unlock Success
    25: Separated From Party
    26: Rejoined Party
    27: Poisoned
    
    References:
    - https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/ssf/ssf_binary_reader.py
    - https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/ssf/ssf_binary_writer.py
    """
    def __init__(self, _io, _parent=None, _root=None):
        super(Ssf, self).__init__(_io)
        self._parent = _parent
        self._root = _root or self
        self._read()

    def _read(self):
        self.file_type = (self._io.read_bytes(4)).decode(u"ASCII")
        if not self.file_type == u"SSF ":
            raise kaitaistruct.ValidationNotEqualError(u"SSF ", self.file_type, self._io, u"/seq/0")
        self.file_version = (self._io.read_bytes(4)).decode(u"ASCII")
        if not self.file_version == u"V1.1":
            raise kaitaistruct.ValidationNotEqualError(u"V1.1", self.file_version, self._io, u"/seq/1")
        self.sounds_offset = self._io.read_u4le()
        if not self.sounds_offset == 12:
            raise kaitaistruct.ValidationNotEqualError(12, self.sounds_offset, self._io, u"/seq/2")
        self.padding = Ssf.Padding(self._io, self, self._root)


    def _fetch_instances(self):
        pass
        self.padding._fetch_instances()
        _ = self.sounds
        if hasattr(self, '_m_sounds'):
            pass
            self._m_sounds._fetch_instances()


    class Padding(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            super(Ssf.Padding, self).__init__(_io)
            self._parent = _parent
            self._root = _root
            self._read()

        def _read(self):
            self.padding_bytes = []
            for i in range(3):
                self.padding_bytes.append(self._io.read_u4le())



        def _fetch_instances(self):
            pass
            for i in range(len(self.padding_bytes)):
                pass



    class SoundArray(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            super(Ssf.SoundArray, self).__init__(_io)
            self._parent = _parent
            self._root = _root
            self._read()

        def _read(self):
            self.entries = []
            for i in range(28):
                self.entries.append(Ssf.SoundEntry(self._io, self, self._root))



        def _fetch_instances(self):
            pass
            for i in range(len(self.entries)):
                pass
                self.entries[i]._fetch_instances()



    class SoundEntry(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            super(Ssf.SoundEntry, self).__init__(_io)
            self._parent = _parent
            self._root = _root
            self._read()

        def _read(self):
            self.strref_raw = self._io.read_u4le()


        def _fetch_instances(self):
            pass

        @property
        def is_no_sound(self):
            """True if this entry represents "no sound" (0xFFFFFFFF).
            False if this entry contains a valid StrRef value.
            """
            if hasattr(self, '_m_is_no_sound'):
                return self._m_is_no_sound

            self._m_is_no_sound = self.strref_raw == 4294967295
            return getattr(self, '_m_is_no_sound', None)


    @property
    def sounds(self):
        """Array of 28 sound string references (StrRefs)."""
        if hasattr(self, '_m_sounds'):
            return self._m_sounds

        _pos = self._io.pos()
        self._io.seek(self.sounds_offset)
        self._m_sounds = Ssf.SoundArray(self._io, self, self._root)
        self._io.seek(_pos)
        return getattr(self, '_m_sounds', None)


