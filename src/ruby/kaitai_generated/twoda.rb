# This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

require 'kaitai/struct/struct'

unless Gem::Version.new(Kaitai::Struct::VERSION) >= Gem::Version.new('0.11')
  raise "Incompatible Kaitai Struct Ruby API: 0.11 or later is required, but you have #{Kaitai::Struct::VERSION}"
end


##
# TwoDA (2D Array) files store tabular data in a binary format used by BioWare games
# including Knights of the Old Republic (KotOR) and The Sith Lords (TSL).
# 
# TwoDA files are essentially two-dimensional arrays (tables) with:
# - Column headers (first row defines column names)
# - Row labels (first column defines row identifiers)
# - Cell values (data at row/column intersections)
# 
# Binary Format Structure:
# - File Header (9 bytes): Magic "2DA " (space-padded), version "V2.b", and newline
# - Column Headers Section: Tab-separated column names, terminated by null byte
# - Row Count (4 bytes): uint32 indicating number of data rows
# - Row Labels Section: Tab-separated row labels (one per row)
# - Cell Offsets Array: Array of uint16 offsets (rowCount * columnCount entries)
# - Data Size (2 bytes): uint16 indicating total size of cell data section
# - Cell Values Section: Null-terminated strings at offsets specified in offsets array
# 
# The format uses an offset-based string table for cell values, allowing efficient
# storage of duplicate values (shared strings are stored once and referenced by offset).
# 
# References:
# - https://github.com/OldRepublicDevs/PyKotor/tree/master/Libraries/PyKotor/src/pykotor/resource/formats/twoda/io_twoda.py
# - https://github.com/OldRepublicDevs/PyKotor/tree/master/Libraries/PyKotor/src/pykotor/resource/formats/twoda/twoda_data.py
class Twoda < Kaitai::Struct::Struct
  def initialize(_io, _parent = nil, _root = nil)
    super(_io, _parent, _root || self)
    _read
  end

  def _read
    @header = TwodaHeader.new(@_io, self, @_root)
    @column_headers_raw = (@_io.read_bytes_term(0, false, true, true)).force_encoding("ASCII").encode('UTF-8')
    @row_count = @_io.read_u4le
    @row_labels_section = RowLabelsSection.new(@_io, self, @_root)
    @cell_offsets_array = CellOffsetsArray.new(@_io, self, @_root)
    @len_cell_values_section = @_io.read_u2le
    _io_cell_values_section = @_io.substream(len_cell_values_section)
    @cell_values_section = CellValuesSection.new(_io_cell_values_section, self, @_root)
    self
  end
  class CellOffsetsArray < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = nil)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @offsets = []
      i = 0
      begin
        _ = @_io.read_u2le
        @offsets << _
        i += 1
      end until _io.pos >= _io.size - 2
      self
    end

    ##
    # Array of cell value offsets (uint16, little-endian).
    # Each offset points to a null-terminated string in the cell_values_section.
    # Offsets are relative to the start of cell_values_section.
    # 
    # Reading continues until we reach 2 bytes before end of file (where len_cell_values_section field is).
    # Then len_cell_values_section is read, followed by cell_values_section.
    # 
    # The actual count is: row_count * column_count
    # where column_count = number of tab-separated parts in column_headers_raw.
    # 
    # Cell access pattern:
    # - Cell at row i, column j = offsets[i * column_count + j]
    # - Value = read string at cell_values_section start + offsets[i * column_count + j]
    # 
    # Duplicate cell values share the same offset (string deduplication).
    attr_reader :offsets
  end
  class CellValuesSection < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = nil)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @raw_data = (@_io.read_bytes(_root.len_cell_values_section)).force_encoding("ASCII").encode('UTF-8')
      self
    end

    ##
    # Raw cell values data as a single string.
    # Contains all null-terminated cell value strings concatenated together.
    # Individual strings can be extracted using offsets from cell_offsets_array.
    # Note: To read a specific cell value, seek to (cell_values_section start + offset) and read a null-terminated string.
    attr_reader :raw_data
  end
  class RowLabelEntry < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = nil)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @label_value = (@_io.read_bytes_term(9, false, true, false)).force_encoding("ASCII").encode('UTF-8')
      self
    end

    ##
    # Row label value (ASCII string terminated by tab character 0x09).
    # Tab terminator is consumed but not included in the string value.
    # Row labels uniquely identify each row in the table.
    # Often numeric (e.g., "0", "1", "2") but can be any string identifier.
    attr_reader :label_value
  end
  class RowLabelsSection < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = nil)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @labels = []
      (_root.row_count).times { |i|
        @labels << RowLabelEntry.new(@_io, self, @_root)
      }
      self
    end

    ##
    # Array of row label entries, one per row.
    # Each label is terminated by tab character (0x09).
    # Total count equals row_count from the header.
    # Row labels typically identify each data row (e.g., numeric IDs, names, etc.).
    attr_reader :labels
  end
  class TwodaHeader < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = nil)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @magic = (@_io.read_bytes(4)).force_encoding("ASCII").encode('UTF-8')
      @version = (@_io.read_bytes(4)).force_encoding("ASCII").encode('UTF-8')
      @newline = @_io.read_u1
      self
    end

    ##
    # Validation check that the file is a valid TwoDA file.
    # All header fields must match expected values.
    def is_valid_twoda
      return @is_valid_twoda unless @is_valid_twoda.nil?
      @is_valid_twoda =  ((magic == "2DA ") && (version == "V2.b") && (newline == 10)) 
      @is_valid_twoda
    end

    ##
    # File type signature. Must be "2DA " (space-padded).
    # Bytes: 0x32 0x44 0x41 0x20
    # The space after "2DA" is significant and must be present.
    attr_reader :magic

    ##
    # File format version. Always "V2.b" for KotOR/TSL TwoDA files.
    # Bytes: 0x56 0x32 0x2E 0x62
    # This is the binary version identifier (V2.b = Version 2 binary).
    attr_reader :version

    ##
    # Newline character (0x0A = '\n').
    # Separates header from column headers section.
    attr_reader :newline
  end

  ##
  # TwoDA file header (9 bytes) - magic "2DA ", version "V2.b", and newline character
  attr_reader :header

  ##
  # Column headers section as a single null-terminated string.
  # Contains tab-separated column names. The null terminator marks the end.
  # Column names can be extracted by splitting on tab characters (0x09).
  # Example: "col1\tcol2\tcol3\0" represents three columns: "col1", "col2", "col3"
  attr_reader :column_headers_raw

  ##
  # Number of data rows in the TwoDA table.
  # This count determines how many row labels and how many cell entries per column.
  attr_reader :row_count

  ##
  # Row labels section - tab-separated row labels (one per row)
  attr_reader :row_labels_section

  ##
  # Array of cell value offsets (uint16 per cell).
  # Total entries = row_count * column_count (where column_count = number of tab-separated parts in column_headers_raw).
  # Each offset points to a null-terminated string in the cell values section.
  attr_reader :cell_offsets_array

  ##
  # Total size in bytes of the cell values data section.
  # This is the size of all unique cell value strings combined (including null terminators).
  # Not used during reading but stored for format consistency.
  attr_reader :len_cell_values_section

  ##
  # Cell values data section containing all unique cell value strings.
  # Each string is null-terminated. Offsets from cell_offsets_array point into this section.
  # The section starts immediately after len_cell_values_section field and has size = len_cell_values_section bytes.
  attr_reader :cell_values_section
  attr_reader :_raw_cell_values_section
end
