
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">

    <title>Twoda format specification</title>
  </head>
  <body>
           <div class="container">
  <h1>Twoda format specification</h1>

      
<a name='type-twoda'></a>
<h1>Type: Twoda</h1>

<p>TwoDA (2D Array) files store tabular data in a binary format used by BioWare games
including Knights of the Old Republic (KotOR) and The Sith Lords (TSL).

TwoDA files are essentially two-dimensional arrays (tables) with:
- Column headers (first row defines column names)
- Row labels (first column defines row identifiers)
- Cell values (data at row/column intersections)

Binary Format Structure:
- File Header (9 bytes): Magic "2DA " (space-padded), version "V2.b", and newline
- Column Headers Section: Tab-separated column names, terminated by null byte
- Row Count (4 bytes): uint32 indicating number of data rows
- Row Labels Section: Tab-separated row labels (one per row)
- Cell Offsets Array: Array of uint16 offsets (rowCount * columnCount entries)
- Data Size (2 bytes): uint16 indicating total size of cell data section
- Cell Values Section: Null-terminated strings at offsets specified in offsets array

The format uses an offset-based string table for cell values, allowing efficient
storage of duplicate values (shared strings are stored once and referenced by offset).

References:
- https://github.com/OldRepublicDevs/PyKotor/tree/master/Libraries/PyKotor/src/pykotor/resource/formats/twoda/io_twoda.py
- https://github.com/OldRepublicDevs/PyKotor/tree/master/Libraries/PyKotor/src/pykotor/resource/formats/twoda/twoda_data.py
</p>
<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>header</td>
<td><a href="#type-twoda-twoda_header">TwodaHeader</a></td>
<td>TwoDA file header (9 bytes) - magic "2DA ", version "V2.b", and newline character</td>
</tr>
<tr>
<td>9</td>
<td>...</td>
<td>column_headers_raw</td>
<td>str(term=0, ASCII)</td>
<td>Column headers section as a single null-terminated string.
Contains tab-separated column names. The null terminator marks the end.
Column names can be extracted by splitting on tab characters (0x09).
Example: "col1\tcol2\tcol3\0" represents three columns: "col1", "col2", "col3"
</td>
</tr>
<tr>
<td>???</td>
<td>...</td>
<td>row_count</td>
<td>u4le</td>
<td>Number of data rows in the TwoDA table.
This count determines how many row labels and how many cell entries per column.
</td>
</tr>
<tr>
<td>???</td>
<td>...</td>
<td>row_labels_section</td>
<td><a href="#type-twoda-row_labels_section">RowLabelsSection</a></td>
<td>Row labels section - tab-separated row labels (one per row)</td>
</tr>
<tr>
<td>???</td>
<td>...</td>
<td>cell_offsets_array</td>
<td><a href="#type-twoda-cell_offsets_array">CellOffsetsArray</a></td>
<td>Array of cell value offsets (uint16 per cell).
Total entries = row_count * column_count (where column_count = number of tab-separated parts in column_headers_raw).
Each offset points to a null-terminated string in the cell values section.
</td>
</tr>
<tr>
<td>???</td>
<td>...</td>
<td>len_cell_values_section</td>
<td>u2le</td>
<td>Total size in bytes of the cell values data section.
This is the size of all unique cell value strings combined (including null terminators).
Not used during reading but stored for format consistency.
</td>
</tr>
<tr>
<td>???</td>
<td>...</td>
<td>cell_values_section</td>
<td><a href="#type-twoda-cell_values_section">CellValuesSection</a></td>
<td>Cell values data section containing all unique cell value strings.
Each string is null-terminated. Offsets from cell_offsets_array point into this section.
The section starts immediately after len_cell_values_section field and has size = len_cell_values_section bytes.
</td>
</tr>
</table>
<a name='type-twoda-cell_offsets_array'></a>
<h2>Type: CellOffsetsArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>offsets</td>
<td>u2le</td>
<td>Array of cell value offsets (uint16, little-endian).
Each offset points to a null-terminated string in the cell_values_section.
Offsets are relative to the start of cell_values_section.

Reading continues until we reach 2 bytes before end of file (where len_cell_values_section field is).
Then len_cell_values_section is read, followed by cell_values_section.

The actual count is: row_count * column_count
where column_count = number of tab-separated parts in column_headers_raw.

Cell access pattern:
- Cell at row i, column j = offsets[i * column_count + j]
- Value = read string at cell_values_section start + offsets[i * column_count + j]

Duplicate cell values share the same offset (string deduplication).
</td>
</tr>
</table>
<a name='type-twoda-cell_values_section'></a>
<h2>Type: CellValuesSection</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>raw_data</td>
<td>str(ASCII)</td>
<td>Raw cell values data as a single string.
Contains all null-terminated cell value strings concatenated together.
Individual strings can be extracted using offsets from cell_offsets_array.
Note: To read a specific cell value, seek to (cell_values_section start + offset) and read a null-terminated string.
</td>
</tr>
</table>
<a name='type-twoda-row_label_entry'></a>
<h2>Type: RowLabelEntry</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>label_value</td>
<td>str(term=9, ignore EOS, ASCII)</td>
<td>Row label value (ASCII string terminated by tab character 0x09).
Tab terminator is consumed but not included in the string value.
Row labels uniquely identify each row in the table.
Often numeric (e.g., "0", "1", "2") but can be any string identifier.
</td>
</tr>
</table>
<a name='type-twoda-row_labels_section'></a>
<h2>Type: RowLabelsSection</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>labels</td>
<td><a href="#type-twoda-row_label_entry">RowLabelEntry</a></td>
<td>Array of row label entries, one per row.
Each label is terminated by tab character (0x09).
Total count equals row_count from the header.
Row labels typically identify each data row (e.g., numeric IDs, names, etc.).
</td>
</tr>
</table>
<a name='type-twoda-twoda_header'></a>
<h2>Type: TwodaHeader</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>magic</td>
<td>str(ASCII)</td>
<td>File type signature. Must be "2DA " (space-padded).
Bytes: 0x32 0x44 0x41 0x20
The space after "2DA" is significant and must be present.
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>version</td>
<td>str(ASCII)</td>
<td>File format version. Always "V2.b" for KotOR/TSL TwoDA files.
Bytes: 0x56 0x32 0x2E 0x62
This is the binary version identifier (V2.b = Version 2 binary).
</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>newline</td>
<td>u1</td>
<td>Newline character (0x0A = '\n').
Separates header from column headers section.
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(is_valid_twoda),List(types, twoda_header, instances, is_valid_twoda),BoolOp(And,List(Compare(Name(identifier(magic)),Eq,Str(2DA )), Compare(Name(identifier(version)),Eq,Str(V2.b)), Compare(Name(identifier(newline)),Eq,IntNum(10)))),None,Some(CalcBooleanType),DocSpec(Some(Validation check that the file is a valid TwoDA file.
All header fields must match expected values.
),List()))

  </div>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>
  </body>
</html>
      
