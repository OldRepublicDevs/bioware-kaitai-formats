
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">

    <title>Tlk format specification</title>
  </head>
  <body>
           <div class="container">
  <h1>Tlk format specification</h1>

      
<a name='type-tlk'></a>
<h1>Type: Tlk</h1>

<p>TLK (Talk Table) files contain all text strings used in the game, both written and spoken.
They enable easy localization by providing a lookup table from string reference numbers (StrRef)
to localized text and associated voice-over audio files.

Binary Format Structure:
- File Header (20 bytes): File type signature, version, language ID, string count, entries offset
- String Data Table (40 bytes per entry): Metadata for each string entry (flags, sound ResRef, offsets, lengths)
- String Entries (variable size): Sequential null-terminated text strings starting at entries_offset

The format uses a two-level structure:
1. String Data Table: Contains metadata (flags, sound filename, text offset/length) for each entry
2. String Entries: Actual text data stored sequentially, referenced by offsets in the data table

String references (StrRef) are 0-based indices into the string_data_table array. StrRef 0 refers to
the first entry, StrRef 1 to the second, etc. StrRef -1 indicates no string reference.

References:
- https://github.com/OldRepublicDevs/PyKotor/wiki/TLK-File-Format.md
- https://github.com/seedhartha/reone/blob/master/src/libs/resource/format/tlkreader.cpp:31-84
- https://github.com/xoreos/xoreos/blob/master/src/aurora/talktable.cpp:42-176
- https://github.com/TSLPatcher/TSLPatcher/blob/master/lib/site/Bioware/TLK.pm:1-533
- https://github.com/KotOR-Community-Patches/Kotor.NET/blob/master/Kotor.NET/Formats/KotorTLK/TLKBinaryStructure.cs:11-132
</p>
<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>header</td>
<td><a href="#type-tlk-tlk_header">TlkHeader</a></td>
<td>TLK file header (20 bytes) - contains file signature, version, language, and counts</td>
</tr>
<tr>
<td>20</td>
<td>...</td>
<td>string_data_table</td>
<td><a href="#type-tlk-string_data_table">StringDataTable</a></td>
<td>Array of string data entries (metadata for each string) - 40 bytes per entry</td>
</tr>
</table>
<a name='type-tlk-string_data_entry'></a>
<h2>Type: StringDataEntry</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>flags</td>
<td>u4le</td>
<td>Bit flags indicating what data is present:
- bit 0 (0x0001): Text present - string has text content
- bit 1 (0x0002): Sound present - string has associated voice-over audio
- bit 2 (0x0004): Sound length present - sound length field is valid

Common flag combinations:
- 0x0001: Text only (menu options, item descriptions)
- 0x0003: Text + Sound (voiced dialog lines)
- 0x0007: Text + Sound + Length (fully voiced with duration)
- 0x0000: Empty entry (unused StrRef slots)
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>sound_resref</td>
<td>str(ASCII)</td>
<td>Voice-over audio filename (ResRef), null-terminated ASCII, max 16 chars.
If the string is shorter than 16 bytes, it is null-padded.
Empty string (all nulls) indicates no voice-over audio.
</td>
</tr>
<tr>
<td>20</td>
<td>...</td>
<td>volume_variance</td>
<td>u4le</td>
<td>Volume variance (unused in KotOR, always 0).
Legacy field from Neverwinter Nights, not used by KotOR engine.
</td>
</tr>
<tr>
<td>24</td>
<td>...</td>
<td>pitch_variance</td>
<td>u4le</td>
<td>Pitch variance (unused in KotOR, always 0).
Legacy field from Neverwinter Nights, not used by KotOR engine.
</td>
</tr>
<tr>
<td>28</td>
<td>...</td>
<td>text_offset</td>
<td>u4le</td>
<td>Offset to string text relative to entries_offset.
The actual file offset is: header.entries_offset + text_offset.
First string starts at offset 0, subsequent strings follow sequentially.
</td>
</tr>
<tr>
<td>32</td>
<td>...</td>
<td>text_length</td>
<td>u4le</td>
<td>Length of string text in bytes (not characters).
For single-byte encodings (Windows-1252, etc.), byte length equals character count.
For multi-byte encodings (UTF-8, etc.), byte length may be greater than character count.
</td>
</tr>
<tr>
<td>36</td>
<td>...</td>
<td>sound_length</td>
<td>f4le</td>
<td>Duration of voice-over audio in seconds (float).
Only valid if sound_length_present flag (bit 2) is set.
Used by the engine to determine how long to wait before auto-advancing dialog.
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(entry_size),List(types, string_data_entry, instances, entry_size),IntNum(40),None,Some(Int1Type(true)),DocSpec(Some(Size of each string_data_entry in bytes.
Breakdown: flags (4) + sound_resref (16) + volume_variance (4) + pitch_variance (4) + 
text_offset (4) + text_length (4) + sound_length (4) = 40 bytes total.
),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(sound_length_present),List(types, string_data_entry, instances, sound_length_present),Compare(BinOp(Name(identifier(flags)),BitAnd,IntNum(4)),NotEq,IntNum(0)),None,Some(CalcBooleanType),DocSpec(Some(Whether sound length is valid (bit 2 of flags)),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(sound_present),List(types, string_data_entry, instances, sound_present),Compare(BinOp(Name(identifier(flags)),BitAnd,IntNum(2)),NotEq,IntNum(0)),None,Some(CalcBooleanType),DocSpec(Some(Whether voice-over audio exists (bit 1 of flags)),List()))
<p><b>Parse instance</b>: text_data</p>
<table class="table">
<tr>
<td>text_file_offset</td>
<td>...</td>
<td>text_data</td>
<td>str(ASCII)</td>
<td>Text string data as raw bytes (read as ASCII for byte-level access).
The actual encoding depends on the language_id in the header.
Common encodings:
- English/French/German/Italian/Spanish: Windows-1252 (cp1252)
- Polish: Windows-1250 (cp1250)
- Korean: EUC-KR (cp949)
- Chinese Traditional: Big5 (cp950)
- Chinese Simplified: GB2312 (cp936)
- Japanese: Shift-JIS (cp932)

Note: This field reads the raw bytes as ASCII string for byte-level access.
The application layer should decode based on the language_id field in the header.
To get raw bytes, access the underlying byte representation of this string.

In practice, strings are stored sequentially starting at entries_offset,
so text_offset values are relative to entries_offset (0, len1, len1+len2, etc.).

Strings may be null-terminated, but text_length includes the null terminator.
Application code should trim null bytes when decoding.

If text_present flag (bit 0) is not set, this field may contain garbage data
or be empty. Always check text_present before using this data.
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(text_file_offset),List(types, string_data_entry, instances, text_file_offset),BinOp(Attribute(Attribute(Name(identifier(_root)),identifier(header)),identifier(entries_offset)),Add,Name(identifier(text_offset))),None,Some(CalcIntType),DocSpec(Some(Absolute file offset to the text string.
Calculated as entries_offset (from header) + text_offset (from entry).
),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(text_present),List(types, string_data_entry, instances, text_present),Compare(BinOp(Name(identifier(flags)),BitAnd,IntNum(1)),NotEq,IntNum(0)),None,Some(CalcBooleanType),DocSpec(Some(Whether text content exists (bit 0 of flags)),List()))
<a name='type-tlk-string_data_table'></a>
<h2>Type: StringDataTable</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>entries</td>
<td><a href="#type-tlk-string_data_entry">StringDataEntry</a></td>
<td>Array of string data entries, one per string in the file</td>
</tr>
</table>
<a name='type-tlk-tlk_header'></a>
<h2>Type: TlkHeader</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>file_type</td>
<td>str(ASCII)</td>
<td>File type signature. Must be "TLK " (space-padded).
Validates that this is a TLK file.
Note: Validation removed temporarily due to Kaitai Struct parser issues.
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>file_version</td>
<td>str(ASCII)</td>
<td>File format version. "V3.0" for KotOR, "V4.0" for Jade Empire.
KotOR games use V3.0. Jade Empire uses V4.0.
Note: Validation removed due to Kaitai Struct parser limitations with period in string.
</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>language_id</td>
<td>u4le</td>
<td>Language identifier:
- 0 = English
- 1 = French
- 2 = German
- 3 = Italian
- 4 = Spanish
- 5 = Polish
- 128 = Korean
- 129 = Chinese Traditional
- 130 = Chinese Simplified
- 131 = Japanese
See Language enum for complete list.
</td>
</tr>
<tr>
<td>12</td>
<td>...</td>
<td>string_count</td>
<td>u4le</td>
<td>Number of string entries in the file.
Determines the number of entries in string_data_table.
</td>
</tr>
<tr>
<td>16</td>
<td>...</td>
<td>entries_offset</td>
<td>u4le</td>
<td>Byte offset to string entries array from the beginning of the file.
Typically 20 + (string_count * 40) = header size + string data table size.
Points to where the actual text strings begin.
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(expected_entries_offset),List(types, tlk_header, instances, expected_entries_offset),BinOp(IntNum(20),Add,BinOp(Name(identifier(string_count)),Mult,IntNum(40))),None,Some(CalcIntType),DocSpec(Some(Expected offset to string entries (header + string data table).
Used for validation.
),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(header_size),List(types, tlk_header, instances, header_size),IntNum(20),None,Some(Int1Type(true)),DocSpec(Some(Size of the TLK header in bytes),List()))

  </div>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>
  </body>
</html>
      
