
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">

    <title>Gff format specification</title>
  </head>
  <body>
           <div class="container">
  <h1>Gff format specification</h1>

      
<a name='type-gff'></a>
<h1>Type: Gff</h1>

<p>GFF (Generic File Format) is BioWare's universal container format for structured game data.
It is used by many KotOR file types including UTC (creature), UTI (item), DLG (dialogue),
ARE (area), GIT (game instance template), IFO (module info), and many others.

GFF uses a hierarchical structure with structs containing fields, which can be simple values,
nested structs, or lists of structs. The format supports version V3.2 (KotOR) and later
versions (V3.3, V4.0, V4.1) used in other BioWare games.

Binary Format Structure:
- File Header (56 bytes): File type signature (FourCC), version, counts, and offsets to all
  data tables (structs, fields, labels, field_data, field_indices, list_indices)
- Label Array: Array of 16-byte null-padded field name labels
- Struct Array: Array of struct entries (12 bytes each) - struct_id, data_or_offset, field_count
- Field Array: Array of field entries (12 bytes each) - field_type, label_index, data_or_offset
- Field Data: Storage area for complex field types (strings, binary, vectors, etc.)
- Field Indices Array: Array of field index arrays (used when structs have multiple fields)
- List Indices Array: Array of list entry structures (count + struct indices)

Field Types:
- Simple types (0-5, 8): Stored inline in data_or_offset (uint8, int8, uint16, int16, uint32,
  int32, float)
- Complex types (6-7, 9-13, 16-17): Offset to field_data section (uint64, int64, double, string,
  resref, localized_string, binary, vector4, vector3)
- Struct (14): Struct index stored inline (nested struct)
- List (15): Offset to list_indices_array (list of structs)

Struct Access Pattern:
1. Root struct is always at struct_array index 0
2. If struct.field_count == 1: data_or_offset contains direct field index
3. If struct.field_count > 1: data_or_offset contains offset into field_indices_array
4. Use field_index to access field_array entry
5. Use field.label_index to get field name from label_array
6. Use field.data_or_offset based on field_type (inline, offset, struct index, list offset)

References:
- https://github.com/OldRepublicDevs/PyKotor/wiki/GFF-File-Format.md - Complete GFF format documentation
- https://github.com/OldRepublicDevs/PyKotor/wiki/Bioware-Aurora-GFF.md - Official BioWare Aurora GFF specification
- https://github.com/xoreos/xoreos-docs/blob/master/specs/torlack/itp.html - Tim Smith/Torlack's GFF/ITP documentation
- https://github.com/seedhartha/reone/blob/master/src/libs/resource/format/gffreader.cpp - Complete C++ GFF reader implementation
- https://github.com/xoreos/xoreos/blob/master/src/aurora/gff3file.cpp - Generic Aurora GFF implementation (shared format)
- https://github.com/KotOR-Community-Patches/KotOR.js/blob/master/src/resource/GFFObject.ts - TypeScript GFF parser
- https://github.com/KotOR-Community-Patches/KotOR-Unity/blob/master/Assets/Scripts/FileObjects/GFFObject.cs - C# Unity GFF loader
- https://github.com/KotOR-Community-Patches/Kotor.NET/tree/master/Kotor.NET/Formats/KotorGFF/ - .NET GFF reader/writer
- https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/gff/io_gff.py - PyKotor binary reader/writer
- https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/gff/gff_data.py - GFF data model
</p>
<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>header</td>
<td><a href="#type-gff-gff_header">GffHeader</a></td>
<td>GFF file header (56 bytes total)</td>
</tr>
</table>
<p><b>Parse instance</b>: field_array</p>
<table class="table">
<tr>
<td>header.field_offset</td>
<td>...</td>
<td>field_array</td>
<td><a href="#type-gff-field_array">FieldArray</a></td>
<td>Array of field entries (12 bytes each)</td>
</tr>
</table>
<p><b>Parse instance</b>: field_data</p>
<table class="table">
<tr>
<td>header.field_data_offset</td>
<td>...</td>
<td>field_data</td>
<td><a href="#type-gff-field_data">FieldData</a></td>
<td>Storage area for complex field types (strings, binary, vectors, etc.)</td>
</tr>
</table>
<p><b>Parse instance</b>: field_indices_array</p>
<table class="table">
<tr>
<td>header.field_indices_offset</td>
<td>...</td>
<td>field_indices_array</td>
<td><a href="#type-gff-field_indices_array">FieldIndicesArray</a></td>
<td>Array of field index arrays (used when structs have multiple fields)</td>
</tr>
</table>
<p><b>Parse instance</b>: label_array</p>
<table class="table">
<tr>
<td>header.label_offset</td>
<td>...</td>
<td>label_array</td>
<td><a href="#type-gff-label_array">LabelArray</a></td>
<td>Array of 16-byte null-padded field name labels</td>
</tr>
</table>
<p><b>Parse instance</b>: list_indices_array</p>
<table class="table">
<tr>
<td>header.list_indices_offset</td>
<td>...</td>
<td>list_indices_array</td>
<td><a href="#type-gff-list_indices_array">ListIndicesArray</a></td>
<td>Array of list entry structures (count + struct indices)</td>
</tr>
</table>
<p><b>Parse instance</b>: root_struct_resolved</p>
<table class="table">
<tr>
<td></td>
<td>...</td>
<td>root_struct_resolved</td>
<td><a href="#type-gff-resolved_struct">ResolvedStruct</a></td>
<td>Convenience "decoded" view of the root struct (struct_array[0]).
This resolves field indices to field entries, resolves labels to strings,
and decodes field values (including nested structs and lists) into typed instances.
</td>
</tr>
</table>
<p><b>Parse instance</b>: struct_array</p>
<table class="table">
<tr>
<td>header.struct_offset</td>
<td>...</td>
<td>struct_array</td>
<td><a href="#type-gff-struct_array">StructArray</a></td>
<td>Array of struct entries (12 bytes each)</td>
</tr>
</table>
<a name='enum-gff-gff_field_type'></a>
<h2>Enum: gff_field_type</h2>

<table class="table">
<tr>
<th>ID</th><th>Name</th><th>Note</th>
</tr>
<tr>
<td>0</td><td>uint8</td><td></td></tr>
</tr>
<tr>
<td>1</td><td>int8</td><td></td></tr>
</tr>
<tr>
<td>2</td><td>uint16</td><td></td></tr>
</tr>
<tr>
<td>3</td><td>int16</td><td></td></tr>
</tr>
<tr>
<td>4</td><td>uint32</td><td></td></tr>
</tr>
<tr>
<td>5</td><td>int32</td><td></td></tr>
</tr>
<tr>
<td>6</td><td>uint64</td><td></td></tr>
</tr>
<tr>
<td>7</td><td>int64</td><td></td></tr>
</tr>
<tr>
<td>8</td><td>single</td><td></td></tr>
</tr>
<tr>
<td>9</td><td>double</td><td></td></tr>
</tr>
<tr>
<td>10</td><td>string</td><td></td></tr>
</tr>
<tr>
<td>11</td><td>resref</td><td></td></tr>
</tr>
<tr>
<td>12</td><td>localized_string</td><td></td></tr>
</tr>
<tr>
<td>13</td><td>binary</td><td></td></tr>
</tr>
<tr>
<td>14</td><td>struct</td><td></td></tr>
</tr>
<tr>
<td>15</td><td>list</td><td></td></tr>
</tr>
<tr>
<td>16</td><td>vector4</td><td></td></tr>
</tr>
<tr>
<td>17</td><td>vector3</td><td></td></tr>
</tr>
</table>
<a name='type-gff-field_array'></a>
<h2>Type: FieldArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>entries</td>
<td><a href="#type-gff-field_entry">FieldEntry</a></td>
<td>Array of field entries (12 bytes each)</td>
</tr>
</table>
<a name='type-gff-field_data'></a>
<h2>Type: FieldData</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>raw_data</td>
<td></td>
<td>Raw field data storage. Individual field data entries are accessed via
field_entry.field_data_offset_value offsets. The structure of each entry
depends on the field_type:
- UInt64/Int64/Double: 8 bytes
- String: 4-byte length + string bytes
- ResRef: 1-byte length + string bytes (max 16)
- LocalizedString: variable (see bioware_common::bioware_locstring type)
- Binary: 4-byte length + binary bytes
- Vector3: 12 bytes (3×float)
- Vector4: 16 bytes (4×float)
</td>
</tr>
</table>
<a name='type-gff-field_entry'></a>
<h2>Type: FieldEntry</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>field_type</td>
<td>u4le→GffFieldType</td>
<td>Field data type (see gff_field_type enum):
- 0-5, 8: Simple types (stored inline in data_or_offset)
- 6-7, 9-13, 16-17: Complex types (offset to field_data in data_or_offset)
- 14: Struct (struct index in data_or_offset)
- 15: List (offset to list_indices_array in data_or_offset)
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>label_index</td>
<td>u4le</td>
<td>Index into label_array for field name</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>data_or_offset</td>
<td>u4le</td>
<td>Inline data (simple types) or offset/index (complex types):
- Simple types (0-5, 8): Value stored directly (1-4 bytes, sign/zero extended to 4 bytes)
- Complex types (6-7, 9-13, 16-17): Byte offset into field_data section (relative to field_data_offset)
- Struct (14): Struct index (index into struct_array)
- List (15): Byte offset into list_indices_array (relative to list_indices_offset)
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(field_data_offset_value),List(types, field_entry, instances, field_data_offset_value),BinOp(Attribute(Attribute(Name(identifier(_root)),identifier(header)),identifier(field_data_offset)),Add,Name(identifier(data_or_offset))),Some(Name(identifier(is_complex_type))),Some(CalcIntType),DocSpec(Some(Absolute file offset to field data for complex types),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(is_complex_type),List(types, field_entry, instances, is_complex_type),BoolOp(Or,List(Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(uint64),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(int64),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(double),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(string),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(resref),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(localized_string),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(binary),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(vector4),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(vector3),typeId(false,List(),false))))),None,Some(CalcBooleanType),DocSpec(Some(True if field stores data in field_data section),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(is_list_type),List(types, field_entry, instances, is_list_type),Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(list),typeId(false,List(),false))),None,Some(CalcBooleanType),DocSpec(Some(True if field is a list of structs),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(is_simple_type),List(types, field_entry, instances, is_simple_type),BoolOp(Or,List(Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(uint8),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(int8),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(uint16),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(int16),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(uint32),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(int32),typeId(false,List(),false))), Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(single),typeId(false,List(),false))))),None,Some(CalcBooleanType),DocSpec(Some(True if field stores data inline (simple types)),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(is_struct_type),List(types, field_entry, instances, is_struct_type),Compare(Name(identifier(field_type)),Eq,EnumByLabel(identifier(gff_field_type),identifier(struct),typeId(false,List(),false))),None,Some(CalcBooleanType),DocSpec(Some(True if field is a nested struct),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(list_indices_offset_value),List(types, field_entry, instances, list_indices_offset_value),BinOp(Attribute(Attribute(Name(identifier(_root)),identifier(header)),identifier(list_indices_offset)),Add,Name(identifier(data_or_offset))),Some(Name(identifier(is_list_type))),Some(CalcIntType),DocSpec(Some(Absolute file offset to list indices for list type fields),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(struct_index_value),List(types, field_entry, instances, struct_index_value),Name(identifier(data_or_offset)),Some(Name(identifier(is_struct_type))),Some(IntMultiType(false,Width4,Some(LittleEndian))),DocSpec(Some(Struct index for struct type fields),List()))
<a name='type-gff-field_indices_array'></a>
<h2>Type: FieldIndicesArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>indices</td>
<td>u4le</td>
<td>Array of field indices. When a struct has multiple fields, it stores an offset
into this array, and the next N consecutive u4 values (where N = struct.field_count)
are the field indices for that struct.
</td>
</tr>
</table>
<a name='type-gff-gff_header'></a>
<h2>Type: GffHeader</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>file_type</td>
<td>str(ASCII)</td>
<td>File type signature (FourCC). Examples: "GFF ", "UTC ", "UTI ", "DLG ", "ARE ", etc.
Must match a valid GFFContent enum value.
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>file_version</td>
<td>str(ASCII)</td>
<td>File format version. Must be "V3.2" for KotOR games.
Later BioWare games use "V3.3", "V4.0", or "V4.1".
Valid values: "V3.2" (KotOR), "V3.3", "V4.0", "V4.1" (other BioWare games)
</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>struct_offset</td>
<td>u4le</td>
<td>Byte offset to struct array from beginning of file</td>
</tr>
<tr>
<td>12</td>
<td>...</td>
<td>struct_count</td>
<td>u4le</td>
<td>Number of struct entries in struct array</td>
</tr>
<tr>
<td>16</td>
<td>...</td>
<td>field_offset</td>
<td>u4le</td>
<td>Byte offset to field array from beginning of file</td>
</tr>
<tr>
<td>20</td>
<td>...</td>
<td>field_count</td>
<td>u4le</td>
<td>Number of field entries in field array</td>
</tr>
<tr>
<td>24</td>
<td>...</td>
<td>label_offset</td>
<td>u4le</td>
<td>Byte offset to label array from beginning of file</td>
</tr>
<tr>
<td>28</td>
<td>...</td>
<td>label_count</td>
<td>u4le</td>
<td>Number of labels in label array</td>
</tr>
<tr>
<td>32</td>
<td>...</td>
<td>field_data_offset</td>
<td>u4le</td>
<td>Byte offset to field data section from beginning of file</td>
</tr>
<tr>
<td>36</td>
<td>...</td>
<td>field_data_count</td>
<td>u4le</td>
<td>Size of field data section in bytes</td>
</tr>
<tr>
<td>40</td>
<td>...</td>
<td>field_indices_offset</td>
<td>u4le</td>
<td>Byte offset to field indices array from beginning of file</td>
</tr>
<tr>
<td>44</td>
<td>...</td>
<td>field_indices_count</td>
<td>u4le</td>
<td>Number of field indices (total count across all structs with multiple fields)</td>
</tr>
<tr>
<td>48</td>
<td>...</td>
<td>list_indices_offset</td>
<td>u4le</td>
<td>Byte offset to list indices array from beginning of file</td>
</tr>
<tr>
<td>52</td>
<td>...</td>
<td>list_indices_count</td>
<td>u4le</td>
<td>Number of list indices entries</td>
</tr>
</table>
<a name='type-gff-label_array'></a>
<h2>Type: LabelArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>labels</td>
<td><a href="#type-gff-label_entry">LabelEntry</a></td>
<td>Array of label entries (16 bytes each)</td>
</tr>
</table>
<a name='type-gff-label_entry'></a>
<h2>Type: LabelEntry</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>name</td>
<td>str(ASCII)</td>
<td>Field name label (null-padded to 16 bytes, null-terminated).
The actual label length is determined by the first null byte.
Application code should trim trailing null bytes when using this field.
</td>
</tr>
</table>
<a name='type-gff-label_entry_terminated'></a>
<h2>Type: LabelEntryTerminated</h2>

<p>Label entry as a null-terminated ASCII string within a fixed 16-byte field.
This avoids leaking trailing `\0` bytes into generated-code consumers.
</p>
<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>name</td>
<td>str(ASCII)</td>
<td></td>
</tr>
</table>
<a name='type-gff-list_entry'></a>
<h2>Type: ListEntry</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>num_struct_indices</td>
<td>u4le</td>
<td>Number of struct indices in this list</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>struct_indices</td>
<td>u4le</td>
<td>Array of struct indices (indices into struct_array)</td>
</tr>
</table>
<a name='type-gff-list_indices_array'></a>
<h2>Type: ListIndicesArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>raw_data</td>
<td></td>
<td>Raw list indices data. List entries are accessed via offsets stored in
list-type field entries (field_entry.list_indices_offset_value).
Each entry starts with a count (u4), followed by that many struct indices (u4 each).

Note: This is a raw data block. In practice, list entries are accessed via
offsets stored in list-type field entries, not as a sequential array.
Use list_entry type to parse individual entries at specific offsets.
</td>
</tr>
</table>
<a name='type-gff-resolved_field'></a>
<h2>Type: ResolvedField</h2>

<p>A decoded field: includes resolved label string and decoded typed value.
Exactly one `value_*` instance (or one of `value_struct` / `list_*`) will be non-null.
</p>
<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
</table>
<p><b>Parse instance</b>: entry</p>
<table class="table">
<tr>
<td>_root.header.field_offset + field_index * 12</td>
<td>...</td>
<td>entry</td>
<td><a href="#type-gff-field_entry">FieldEntry</a></td>
<td>Raw field entry at field_index</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(field_entry_pos),List(types, resolved_field, instances, field_entry_pos),BinOp(Attribute(Attribute(Name(identifier(_root)),identifier(header)),identifier(field_offset)),Add,BinOp(Name(identifier(field_index)),Mult,IntNum(12))),None,Some(CalcIntType),DocSpec(Some(Absolute file offset of this field entry (start of 12-byte record)),List()))
<p><b>Parse instance</b>: label</p>
<table class="table">
<tr>
<td>_root.header.label_offset + entry.label_index * 16</td>
<td>...</td>
<td>label</td>
<td><a href="#type-gff-label_entry_terminated">LabelEntryTerminated</a></td>
<td>Resolved field label string</td>
</tr>
</table>
<p><b>Parse instance</b>: list_entry</p>
<table class="table">
<tr>
<td>_root.header.list_indices_offset + entry.data_or_offset</td>
<td>...</td>
<td>list_entry</td>
<td><a href="#type-gff-list_entry">ListEntry</a></td>
<td>Parsed list entry at offset (list indices)</td>
</tr>
</table>
<p><b>Parse instance</b>: list_structs</p>
<table class="table">
<tr>
<td></td>
<td>...</td>
<td>list_structs</td>
<td><a href="#type-gff-resolved_struct">ResolvedStruct</a></td>
<td>Resolved structs referenced by this list</td>
</tr>
</table>
<p><b>Parse instance</b>: value_binary</p>
<table class="table">
<tr>
<td>_root.header.field_data_offset + entry.data_or_offset</td>
<td>...</td>
<td>value_binary</td>
<td><a href="#type-bioware_common-bioware_binary_data">BiowareBinaryData</a></td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_double</p>
<table class="table">
<tr>
<td>_root.header.field_data_offset + entry.data_or_offset</td>
<td>...</td>
<td>value_double</td>
<td>f8le</td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_int16</p>
<table class="table">
<tr>
<td>field_entry_pos + 8</td>
<td>...</td>
<td>value_int16</td>
<td>s2le</td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_int32</p>
<table class="table">
<tr>
<td>field_entry_pos + 8</td>
<td>...</td>
<td>value_int32</td>
<td>s4le</td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_int64</p>
<table class="table">
<tr>
<td>_root.header.field_data_offset + entry.data_or_offset</td>
<td>...</td>
<td>value_int64</td>
<td>s8le</td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_int8</p>
<table class="table">
<tr>
<td>field_entry_pos + 8</td>
<td>...</td>
<td>value_int8</td>
<td>s1</td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_localized_string</p>
<table class="table">
<tr>
<td>_root.header.field_data_offset + entry.data_or_offset</td>
<td>...</td>
<td>value_localized_string</td>
<td><a href="#type-bioware_common-bioware_locstring">BiowareLocstring</a></td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_resref</p>
<table class="table">
<tr>
<td>_root.header.field_data_offset + entry.data_or_offset</td>
<td>...</td>
<td>value_resref</td>
<td><a href="#type-bioware_common-bioware_resref">BiowareResref</a></td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_single</p>
<table class="table">
<tr>
<td>field_entry_pos + 8</td>
<td>...</td>
<td>value_single</td>
<td>f4le</td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_string</p>
<table class="table">
<tr>
<td>_root.header.field_data_offset + entry.data_or_offset</td>
<td>...</td>
<td>value_string</td>
<td><a href="#type-bioware_common-bioware_cexo_string">BiowareCexoString</a></td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_struct</p>
<table class="table">
<tr>
<td></td>
<td>...</td>
<td>value_struct</td>
<td><a href="#type-gff-resolved_struct">ResolvedStruct</a></td>
<td>Nested struct (struct index = entry.data_or_offset)</td>
</tr>
</table>
<p><b>Parse instance</b>: value_uint16</p>
<table class="table">
<tr>
<td>field_entry_pos + 8</td>
<td>...</td>
<td>value_uint16</td>
<td>u2le</td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_uint32</p>
<table class="table">
<tr>
<td>field_entry_pos + 8</td>
<td>...</td>
<td>value_uint32</td>
<td>u4le</td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_uint64</p>
<table class="table">
<tr>
<td>_root.header.field_data_offset + entry.data_or_offset</td>
<td>...</td>
<td>value_uint64</td>
<td>u8le</td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_uint8</p>
<table class="table">
<tr>
<td>field_entry_pos + 8</td>
<td>...</td>
<td>value_uint8</td>
<td>u1</td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_vector3</p>
<table class="table">
<tr>
<td>_root.header.field_data_offset + entry.data_or_offset</td>
<td>...</td>
<td>value_vector3</td>
<td><a href="#type-bioware_common-bioware_vector3">BiowareVector3</a></td>
<td></td>
</tr>
</table>
<p><b>Parse instance</b>: value_vector4</p>
<table class="table">
<tr>
<td>_root.header.field_data_offset + entry.data_or_offset</td>
<td>...</td>
<td>value_vector4</td>
<td><a href="#type-bioware_common-bioware_vector4">BiowareVector4</a></td>
<td></td>
</tr>
</table>
<a name='type-gff-resolved_struct'></a>
<h2>Type: ResolvedStruct</h2>

<p>A decoded struct node: resolves field indices -> field entries -> typed values,
and recursively resolves nested structs and lists.
</p>
<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
</table>
<p><b>Parse instance</b>: entry</p>
<table class="table">
<tr>
<td>_root.header.struct_offset + struct_index * 12</td>
<td>...</td>
<td>entry</td>
<td><a href="#type-gff-struct_entry">StructEntry</a></td>
<td>Raw struct entry at struct_index</td>
</tr>
</table>
<p><b>Parse instance</b>: field_indices</p>
<table class="table">
<tr>
<td>_root.header.field_indices_offset + entry.data_or_offset</td>
<td>...</td>
<td>field_indices</td>
<td>u4le</td>
<td>Field indices for this struct (only present when field_count > 1).
When field_count == 1, the single field index is stored directly in entry.data_or_offset.
</td>
</tr>
</table>
<p><b>Parse instance</b>: fields</p>
<table class="table">
<tr>
<td></td>
<td>...</td>
<td>fields</td>
<td><a href="#type-gff-resolved_field">ResolvedField</a></td>
<td>Resolved fields (multi-field struct)</td>
</tr>
</table>
<p><b>Parse instance</b>: single_field</p>
<table class="table">
<tr>
<td></td>
<td>...</td>
<td>single_field</td>
<td><a href="#type-gff-resolved_field">ResolvedField</a></td>
<td>Resolved field (single-field struct)</td>
</tr>
</table>
<a name='type-gff-struct_array'></a>
<h2>Type: StructArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>entries</td>
<td><a href="#type-gff-struct_entry">StructEntry</a></td>
<td>Array of struct entries (12 bytes each)</td>
</tr>
</table>
<a name='type-gff-struct_entry'></a>
<h2>Type: StructEntry</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>struct_id</td>
<td>s4le</td>
<td>Structure type identifier. Often 0xFFFFFFFF (-1) for generic structs.
Used to identify struct types in schema-aware parsers.
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>data_or_offset</td>
<td>u4le</td>
<td>Field index (if field_count == 1) or byte offset to field indices array (if field_count > 1).
If field_count == 0, this value is unused.
</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>field_count</td>
<td>u4le</td>
<td>Number of fields in this struct:
- 0: No fields
- 1: Single field, data_or_offset contains the field index directly
- >1: Multiple fields, data_or_offset contains byte offset into field_indices_array
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(field_indices_offset),List(types, struct_entry, instances, field_indices_offset),Name(identifier(data_or_offset)),Some(Name(identifier(has_multiple_fields))),Some(IntMultiType(false,Width4,Some(LittleEndian))),DocSpec(Some(Byte offset into field_indices_array when struct has multiple fields),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(has_multiple_fields),List(types, struct_entry, instances, has_multiple_fields),Compare(Name(identifier(field_count)),Gt,IntNum(1)),None,Some(CalcBooleanType),DocSpec(Some(True if struct has multiple fields (offset to field indices in data_or_offset)),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(has_single_field),List(types, struct_entry, instances, has_single_field),Compare(Name(identifier(field_count)),Eq,IntNum(1)),None,Some(CalcBooleanType),DocSpec(Some(True if struct has exactly one field (direct field index in data_or_offset)),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(single_field_index),List(types, struct_entry, instances, single_field_index),Name(identifier(data_or_offset)),Some(Name(identifier(has_single_field))),Some(IntMultiType(false,Width4,Some(LittleEndian))),DocSpec(Some(Direct field index when struct has exactly one field),List()))

  </div>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>
  </body>
</html>
      
