
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">

    <title>Bwm format specification</title>
  </head>
  <body>
           <div class="container">
  <h1>Bwm format specification</h1>

      
<a name='type-bwm'></a>
<h1>Type: Bwm</h1>

<p>BWM (Binary WalkMesh) files define walkable surfaces for pathfinding and collision detection
in Knights of the Old Republic (KotOR) games. BWM files are stored on disk with different
extensions depending on their type:

- WOK: Area walkmesh files (walkmesh_type = 1) - defines walkable regions in game areas
- PWK: Placeable walkmesh files (walkmesh_type = 0) - collision geometry for containers, furniture
- DWK: Door walkmesh files (walkmesh_type = 0) - collision geometry for doors in various states

The format uses a header-based structure where offsets point to various data tables, allowing
efficient random access to vertices, faces, materials, and acceleration structures.

Binary Format Structure:
- File Header (8 bytes): Magic "BWM " and version "V1.0"
- Walkmesh Properties (52 bytes): Type, hook vectors, position
- Data Table Offsets (84 bytes): Counts and offsets for all data tables
- Vertices Array: Array of float3 (x, y, z) per vertex
- Face Indices Array: Array of uint32 triplets (vertex indices per face)
- Materials Array: Array of uint32 (SurfaceMaterial ID per face)
- Normals Array: Array of float3 (face normal per face) - WOK only
- Planar Distances Array: Array of float32 (per face) - WOK only
- AABB Nodes Array: Array of AABB structures (WOK only)
- Adjacencies Array: Array of int32 triplets (WOK only, -1 for no neighbor)
- Edges Array: Array of (edge_index, transition) pairs (WOK only)
- Perimeters Array: Array of edge indices (WOK only)

References:
- https://github.com/OldRepublicDevs/PyKotor/wiki/BWM-File-Format.md
- https://github.com/seedhartha/reone/blob/master/src/libs/graphics/format/bwmreader.cpp:27-171
- https://github.com/xoreos/xoreos/blob/master/src/engines/kotorbase/path/walkmeshloader.cpp:73-248
- https://github.com/KotOR-Community-Patches/KotOR.js/blob/master/src/odyssey/OdysseyWalkMesh.ts:452-473
</p>
<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>header</td>
<td><a href="#type-bwm-bwm_header">BwmHeader</a></td>
<td>BWM file header (8 bytes) - magic and version signature</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>walkmesh_properties</td>
<td><a href="#type-bwm-walkmesh_properties">WalkmeshProperties</a></td>
<td>Walkmesh properties section (52 bytes) - type, hooks, position</td>
</tr>
<tr>
<td>72</td>
<td>...</td>
<td>data_table_offsets</td>
<td><a href="#type-bwm-data_table_offsets">DataTableOffsets</a></td>
<td>Data table offsets section (84 bytes) - counts and offsets for all data tables</td>
</tr>
</table>
<p><b>Parse instance</b>: aabb_nodes</p>
<table class="table">
<tr>
<td>_root.data_table_offsets.aabb_offset</td>
<td>...</td>
<td>aabb_nodes</td>
<td><a href="#type-bwm-aabb_nodes_array">AabbNodesArray</a></td>
<td>Array of AABB tree nodes for spatial acceleration - WOK only</td>
</tr>
</table>
<p><b>Parse instance</b>: adjacencies</p>
<table class="table">
<tr>
<td>_root.data_table_offsets.adjacency_offset</td>
<td>...</td>
<td>adjacencies</td>
<td><a href="#type-bwm-adjacencies_array">AdjacenciesArray</a></td>
<td>Array of adjacency indices (int32 triplets per walkable face) - WOK only</td>
</tr>
</table>
<p><b>Parse instance</b>: edges</p>
<table class="table">
<tr>
<td>_root.data_table_offsets.edge_offset</td>
<td>...</td>
<td>edges</td>
<td><a href="#type-bwm-edges_array">EdgesArray</a></td>
<td>Array of perimeter edges (edge_index, transition pairs) - WOK only</td>
</tr>
</table>
<p><b>Parse instance</b>: face_indices</p>
<table class="table">
<tr>
<td>_root.data_table_offsets.face_indices_offset</td>
<td>...</td>
<td>face_indices</td>
<td><a href="#type-bwm-face_indices_array">FaceIndicesArray</a></td>
<td>Array of face vertex indices (uint32 triplets)</td>
</tr>
</table>
<p><b>Parse instance</b>: materials</p>
<table class="table">
<tr>
<td>_root.data_table_offsets.materials_offset</td>
<td>...</td>
<td>materials</td>
<td><a href="#type-bwm-materials_array">MaterialsArray</a></td>
<td>Array of surface material IDs per face</td>
</tr>
</table>
<p><b>Parse instance</b>: normals</p>
<table class="table">
<tr>
<td>_root.data_table_offsets.normals_offset</td>
<td>...</td>
<td>normals</td>
<td><a href="#type-bwm-normals_array">NormalsArray</a></td>
<td>Array of face normal vectors (float3 triplets) - WOK only</td>
</tr>
</table>
<p><b>Parse instance</b>: perimeters</p>
<table class="table">
<tr>
<td>_root.data_table_offsets.perimeter_offset</td>
<td>...</td>
<td>perimeters</td>
<td><a href="#type-bwm-perimeters_array">PerimetersArray</a></td>
<td>Array of perimeter markers (edge indices marking end of loops) - WOK only</td>
</tr>
</table>
<p><b>Parse instance</b>: planar_distances</p>
<table class="table">
<tr>
<td>_root.data_table_offsets.distances_offset</td>
<td>...</td>
<td>planar_distances</td>
<td><a href="#type-bwm-planar_distances_array">PlanarDistancesArray</a></td>
<td>Array of planar distances (float32 per face) - WOK only</td>
</tr>
</table>
<p><b>Parse instance</b>: vertices</p>
<table class="table">
<tr>
<td>_root.data_table_offsets.vertex_offset</td>
<td>...</td>
<td>vertices</td>
<td><a href="#type-bwm-vertices_array">VerticesArray</a></td>
<td>Array of vertex positions (float3 triplets)</td>
</tr>
</table>
<a name='type-bwm-aabb_node'></a>
<h2>Type: AabbNode</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>bounds_min</td>
<td><a href="#type-bwm-vec3f">Vec3f</a></td>
<td>Minimum bounding box coordinates (x, y, z).
Defines the lower corner of the axis-aligned bounding box.
</td>
</tr>
<tr>
<td>12</td>
<td>...</td>
<td>bounds_max</td>
<td><a href="#type-bwm-vec3f">Vec3f</a></td>
<td>Maximum bounding box coordinates (x, y, z).
Defines the upper corner of the axis-aligned bounding box.
</td>
</tr>
<tr>
<td>24</td>
<td>...</td>
<td>face_index</td>
<td>s4le</td>
<td>Face index for leaf nodes, -1 (0xFFFFFFFF) for internal nodes.
Leaf nodes contain a single face, internal nodes contain child nodes.
</td>
</tr>
<tr>
<td>28</td>
<td>...</td>
<td>unknown</td>
<td>u4le</td>
<td>Unknown field (typically 4).
Purpose is undocumented but appears in all AABB nodes.
</td>
</tr>
<tr>
<td>32</td>
<td>...</td>
<td>most_significant_plane</td>
<td>u4le</td>
<td>Split axis/plane identifier:
- 0x00 = No children (leaf node)
- 0x01 = Positive X axis split
- 0x02 = Positive Y axis split
- 0x03 = Positive Z axis split
- 0xFFFFFFFE (-2) = Negative X axis split
- 0xFFFFFFFD (-3) = Negative Y axis split
- 0xFFFFFFFC (-4) = Negative Z axis split
</td>
</tr>
<tr>
<td>36</td>
<td>...</td>
<td>left_child_index</td>
<td>u4le</td>
<td>Index to left child node (0-based array index).
0xFFFFFFFF indicates no left child.
Child indices are 0-based indices into the AABB nodes array.
</td>
</tr>
<tr>
<td>40</td>
<td>...</td>
<td>right_child_index</td>
<td>u4le</td>
<td>Index to right child node (0-based array index).
0xFFFFFFFF indicates no right child.
Child indices are 0-based indices into the AABB nodes array.
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(has_left_child),List(types, aabb_node, instances, has_left_child),Compare(Name(identifier(left_child_index)),NotEq,IntNum(4294967295)),None,Some(CalcBooleanType),DocSpec(Some(True if this node has a left child),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(has_right_child),List(types, aabb_node, instances, has_right_child),Compare(Name(identifier(right_child_index)),NotEq,IntNum(4294967295)),None,Some(CalcBooleanType),DocSpec(Some(True if this node has a right child),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(is_internal_node),List(types, aabb_node, instances, is_internal_node),Compare(Name(identifier(face_index)),Eq,UnaryOp(Minus,IntNum(1))),None,Some(CalcBooleanType),DocSpec(Some(True if this is an internal node (has children), false if leaf node),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(is_leaf_node),List(types, aabb_node, instances, is_leaf_node),Compare(Name(identifier(face_index)),NotEq,UnaryOp(Minus,IntNum(1))),None,Some(CalcBooleanType),DocSpec(Some(True if this is a leaf node (contains a face), false if internal node),List()))
<a name='type-bwm-aabb_nodes_array'></a>
<h2>Type: AabbNodesArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>nodes</td>
<td><a href="#type-bwm-aabb_node">AabbNode</a></td>
<td>Array of AABB tree nodes for spatial acceleration (WOK only).
AABB trees enable efficient raycasting and point queries (O(log N) vs O(N)).
</td>
</tr>
</table>
<a name='type-bwm-adjacencies_array'></a>
<h2>Type: AdjacenciesArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>adjacencies</td>
<td><a href="#type-bwm-adjacency_triplet">AdjacencyTriplet</a></td>
<td>Array of adjacency triplets, one per walkable face (WOK only).
Each walkable face has exactly three adjacency entries, one for each edge.
Adjacency count equals the number of walkable faces, not the total face count.
</td>
</tr>
</table>
<a name='type-bwm-adjacency_triplet'></a>
<h2>Type: AdjacencyTriplet</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>edge_0_adjacency</td>
<td>s4le</td>
<td>Adjacency index for edge 0 (between v1 and v2).
Encoding: face_index * 3 + edge_index
-1 (0xFFFFFFFF) indicates no adjacent walkable face (boundary edge).
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>edge_1_adjacency</td>
<td>s4le</td>
<td>Adjacency index for edge 1 (between v2 and v3).
Encoding: face_index * 3 + edge_index
-1 (0xFFFFFFFF) indicates no adjacent walkable face (boundary edge).
</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>edge_2_adjacency</td>
<td>s4le</td>
<td>Adjacency index for edge 2 (between v3 and v1).
Encoding: face_index * 3 + edge_index
-1 (0xFFFFFFFF) indicates no adjacent walkable face (boundary edge).
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(edge_0_face_index),List(types, adjacency_triplet, instances, edge_0_face_index),IfExp(Compare(Name(identifier(edge_0_adjacency)),NotEq,UnaryOp(Minus,IntNum(1))),BinOp(Name(identifier(edge_0_adjacency)),Div,IntNum(3)),UnaryOp(Minus,IntNum(1))),None,Some(CalcIntType),DocSpec(Some(Face index of adjacent face for edge 0 (decoded from adjacency index)),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(edge_0_has_neighbor),List(types, adjacency_triplet, instances, edge_0_has_neighbor),Compare(Name(identifier(edge_0_adjacency)),NotEq,UnaryOp(Minus,IntNum(1))),None,Some(CalcBooleanType),DocSpec(Some(True if edge 0 has an adjacent walkable face),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(edge_0_local_edge),List(types, adjacency_triplet, instances, edge_0_local_edge),IfExp(Compare(Name(identifier(edge_0_adjacency)),NotEq,UnaryOp(Minus,IntNum(1))),BinOp(Name(identifier(edge_0_adjacency)),Mod,IntNum(3)),UnaryOp(Minus,IntNum(1))),None,Some(CalcIntType),DocSpec(Some(Local edge index (0, 1, or 2) of adjacent face for edge 0),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(edge_1_face_index),List(types, adjacency_triplet, instances, edge_1_face_index),IfExp(Compare(Name(identifier(edge_1_adjacency)),NotEq,UnaryOp(Minus,IntNum(1))),BinOp(Name(identifier(edge_1_adjacency)),Div,IntNum(3)),UnaryOp(Minus,IntNum(1))),None,Some(CalcIntType),DocSpec(Some(Face index of adjacent face for edge 1 (decoded from adjacency index)),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(edge_1_has_neighbor),List(types, adjacency_triplet, instances, edge_1_has_neighbor),Compare(Name(identifier(edge_1_adjacency)),NotEq,UnaryOp(Minus,IntNum(1))),None,Some(CalcBooleanType),DocSpec(Some(True if edge 1 has an adjacent walkable face),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(edge_1_local_edge),List(types, adjacency_triplet, instances, edge_1_local_edge),IfExp(Compare(Name(identifier(edge_1_adjacency)),NotEq,UnaryOp(Minus,IntNum(1))),BinOp(Name(identifier(edge_1_adjacency)),Mod,IntNum(3)),UnaryOp(Minus,IntNum(1))),None,Some(CalcIntType),DocSpec(Some(Local edge index (0, 1, or 2) of adjacent face for edge 1),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(edge_2_face_index),List(types, adjacency_triplet, instances, edge_2_face_index),IfExp(Compare(Name(identifier(edge_2_adjacency)),NotEq,UnaryOp(Minus,IntNum(1))),BinOp(Name(identifier(edge_2_adjacency)),Div,IntNum(3)),UnaryOp(Minus,IntNum(1))),None,Some(CalcIntType),DocSpec(Some(Face index of adjacent face for edge 2 (decoded from adjacency index)),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(edge_2_has_neighbor),List(types, adjacency_triplet, instances, edge_2_has_neighbor),Compare(Name(identifier(edge_2_adjacency)),NotEq,UnaryOp(Minus,IntNum(1))),None,Some(CalcBooleanType),DocSpec(Some(True if edge 2 has an adjacent walkable face),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(edge_2_local_edge),List(types, adjacency_triplet, instances, edge_2_local_edge),IfExp(Compare(Name(identifier(edge_2_adjacency)),NotEq,UnaryOp(Minus,IntNum(1))),BinOp(Name(identifier(edge_2_adjacency)),Mod,IntNum(3)),UnaryOp(Minus,IntNum(1))),None,Some(CalcIntType),DocSpec(Some(Local edge index (0, 1, or 2) of adjacent face for edge 2),List()))
<a name='type-bwm-bwm_header'></a>
<h2>Type: BwmHeader</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>magic</td>
<td>str(ASCII)</td>
<td>File type signature. Must be "BWM " (space-padded).
The space after "BWM" is significant and must be present.
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>version</td>
<td>str(ASCII)</td>
<td>File format version. Always "V1.0" for KotOR BWM files.
This is the first and only version of the BWM format used in KotOR games.
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(is_valid_bwm),List(types, bwm_header, instances, is_valid_bwm),BoolOp(And,List(Compare(Name(identifier(magic)),Eq,Str(BWM )), Compare(Name(identifier(version)),Eq,Str(V1.0)))),None,Some(CalcBooleanType),DocSpec(Some(Validation check that the file is a valid BWM file.
Both magic and version must match expected values.
),List()))
<a name='type-bwm-data_table_offsets'></a>
<h2>Type: DataTableOffsets</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>vertex_count</td>
<td>u4le</td>
<td>Number of vertices in the walkmesh</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>vertex_offset</td>
<td>u4le</td>
<td>Byte offset to vertex array from the beginning of the file</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>face_count</td>
<td>u4le</td>
<td>Number of faces (triangles) in the walkmesh</td>
</tr>
<tr>
<td>12</td>
<td>...</td>
<td>face_indices_offset</td>
<td>u4le</td>
<td>Byte offset to face indices array from the beginning of the file</td>
</tr>
<tr>
<td>16</td>
<td>...</td>
<td>materials_offset</td>
<td>u4le</td>
<td>Byte offset to materials array from the beginning of the file</td>
</tr>
<tr>
<td>20</td>
<td>...</td>
<td>normals_offset</td>
<td>u4le</td>
<td>Byte offset to face normals array from the beginning of the file.
Only used for WOK files (area walkmeshes).
</td>
</tr>
<tr>
<td>24</td>
<td>...</td>
<td>distances_offset</td>
<td>u4le</td>
<td>Byte offset to planar distances array from the beginning of the file.
Only used for WOK files (area walkmeshes).
</td>
</tr>
<tr>
<td>28</td>
<td>...</td>
<td>aabb_count</td>
<td>u4le</td>
<td>Number of AABB tree nodes (WOK only, 0 for PWK/DWK).
AABB trees provide spatial acceleration for raycasting and point queries.
</td>
</tr>
<tr>
<td>32</td>
<td>...</td>
<td>aabb_offset</td>
<td>u4le</td>
<td>Byte offset to AABB tree nodes array from the beginning of the file (WOK only).
Only present if aabb_count > 0.
</td>
</tr>
<tr>
<td>36</td>
<td>...</td>
<td>unknown</td>
<td>u4le</td>
<td>Unknown field (typically 0 or 4).
Purpose is undocumented but appears in all BWM files.
</td>
</tr>
<tr>
<td>40</td>
<td>...</td>
<td>adjacency_count</td>
<td>u4le</td>
<td>Number of walkable faces for adjacency data (WOK only).
This equals the number of walkable faces, not the total face count.
Adjacencies are stored only for walkable faces.
</td>
</tr>
<tr>
<td>44</td>
<td>...</td>
<td>adjacency_offset</td>
<td>u4le</td>
<td>Byte offset to adjacency array from the beginning of the file (WOK only).
Only present if adjacency_count > 0.
</td>
</tr>
<tr>
<td>48</td>
<td>...</td>
<td>edge_count</td>
<td>u4le</td>
<td>Number of perimeter edges (WOK only).
Perimeter edges are boundary edges with no walkable neighbor.
</td>
</tr>
<tr>
<td>52</td>
<td>...</td>
<td>edge_offset</td>
<td>u4le</td>
<td>Byte offset to edges array from the beginning of the file (WOK only).
Only present if edge_count > 0.
</td>
</tr>
<tr>
<td>56</td>
<td>...</td>
<td>perimeter_count</td>
<td>u4le</td>
<td>Number of perimeter markers (WOK only).
Perimeter markers indicate the end of closed loops of perimeter edges.
</td>
</tr>
<tr>
<td>60</td>
<td>...</td>
<td>perimeter_offset</td>
<td>u4le</td>
<td>Byte offset to perimeters array from the beginning of the file (WOK only).
Only present if perimeter_count > 0.
</td>
</tr>
</table>
<a name='type-bwm-edge_entry'></a>
<h2>Type: EdgeEntry</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>edge_index</td>
<td>u4le</td>
<td>Encoded edge index: face_index * 3 + local_edge_index
Identifies which face and which edge (0, 1, or 2) of that face.
Edge 0: between v1 and v2
Edge 1: between v2 and v3
Edge 2: between v3 and v1
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>transition</td>
<td>s4le</td>
<td>Transition ID for room/area connections, -1 if no transition.
Non-negative values reference door connections or area boundaries.
-1 indicates this is just a boundary edge with no transition.
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(face_index),List(types, edge_entry, instances, face_index),BinOp(Name(identifier(edge_index)),Div,IntNum(3)),None,Some(CalcIntType),DocSpec(Some(Face index that this edge belongs to (decoded from edge_index)),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(has_transition),List(types, edge_entry, instances, has_transition),Compare(Name(identifier(transition)),NotEq,UnaryOp(Minus,IntNum(1))),None,Some(CalcBooleanType),DocSpec(Some(True if this edge has a transition ID (links to door/area connection)),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(local_edge_index),List(types, edge_entry, instances, local_edge_index),BinOp(Name(identifier(edge_index)),Mod,IntNum(3)),None,Some(CalcIntType),DocSpec(Some(Local edge index (0, 1, or 2) within the face (decoded from edge_index)),List()))
<a name='type-bwm-edges_array'></a>
<h2>Type: EdgesArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>edges</td>
<td><a href="#type-bwm-edge_entry">EdgeEntry</a></td>
<td>Array of perimeter edges (WOK only).
Perimeter edges are boundary edges with no walkable neighbor.
Each edge entry contains an edge index and optional transition ID.
</td>
</tr>
</table>
<a name='type-bwm-face_indices'></a>
<h2>Type: FaceIndices</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>v1_index</td>
<td>u4le</td>
<td>Vertex index for first vertex of triangle (0-based index into vertices array).
Vertex indices define the triangle's vertices in counter-clockwise order
when viewed from the front (the side the normal points toward).
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>v2_index</td>
<td>u4le</td>
<td>Vertex index for second vertex of triangle (0-based index into vertices array).
</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>v3_index</td>
<td>u4le</td>
<td>Vertex index for third vertex of triangle (0-based index into vertices array).
</td>
</tr>
</table>
<a name='type-bwm-face_indices_array'></a>
<h2>Type: FaceIndicesArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>faces</td>
<td><a href="#type-bwm-face_indices">FaceIndices</a></td>
<td>Array of face vertex index triplets</td>
</tr>
</table>
<a name='type-bwm-materials_array'></a>
<h2>Type: MaterialsArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>materials</td>
<td>u4le</td>
<td>Array of surface material IDs, one per face.
Material IDs determine walkability and physical properties:
- 0 = NotDefined/UNDEFINED (non-walkable)
- 1 = Dirt (walkable)
- 2 = Obscuring (non-walkable, blocks line of sight)
- 3 = Grass (walkable)
- 4 = Stone (walkable)
- 5 = Wood (walkable)
- 6 = Water (walkable)
- 7 = Nonwalk/NON_WALK (non-walkable)
- 8 = Transparent (non-walkable)
- 9 = Carpet (walkable)
- 10 = Metal (walkable)
- 11 = Puddles (walkable)
- 12 = Swamp (walkable)
- 13 = Mud (walkable)
- 14 = Leaves (walkable)
- 15 = Lava (non-walkable, damage-dealing)
- 16 = BottomlessPit (walkable but dangerous)
- 17 = DeepWater (non-walkable)
- 18 = Door (walkable, special handling)
- 19 = Snow/NON_WALK_GRASS (non-walkable)
- 20+ = Additional materials (Sand, BareBones, StoneBridge, etc.)
</td>
</tr>
</table>
<a name='type-bwm-normals_array'></a>
<h2>Type: NormalsArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>normals</td>
<td><a href="#type-bwm-vec3f">Vec3f</a></td>
<td>Array of face normal vectors, one per face (WOK only).
Normals are precomputed unit vectors perpendicular to each face.
Calculated using cross product: normal = normalize((v2 - v1) × (v3 - v1)).
Normal direction follows right-hand rule based on vertex winding order.
</td>
</tr>
</table>
<a name='type-bwm-perimeters_array'></a>
<h2>Type: PerimetersArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>perimeters</td>
<td>u4le</td>
<td>Array of perimeter markers (WOK only).
Each value is an index into the edges array, marking the end of a perimeter loop.
Perimeter loops are closed chains of perimeter edges forming walkable boundaries.
Values are typically 1-based (marking end of loop), but may be 0-based depending on implementation.
</td>
</tr>
</table>
<a name='type-bwm-planar_distances_array'></a>
<h2>Type: PlanarDistancesArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>distances</td>
<td>f4le</td>
<td>Array of planar distances, one per face (WOK only).
The D component of the plane equation ax + by + cz + d = 0.
Calculated as d = -normal · vertex1 for each face.
Precomputed to allow quick point-plane relationship tests.
</td>
</tr>
</table>
<a name='type-bwm-vec3f'></a>
<h2>Type: Vec3f</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>x</td>
<td>f4le</td>
<td>X coordinate (float32)</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>y</td>
<td>f4le</td>
<td>Y coordinate (float32)</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>z</td>
<td>f4le</td>
<td>Z coordinate (float32)</td>
</tr>
</table>
<a name='type-bwm-vertices_array'></a>
<h2>Type: VerticesArray</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>vertices</td>
<td><a href="#type-bwm-vec3f">Vec3f</a></td>
<td>Array of vertex positions, each vertex is a float3 (x, y, z)</td>
</tr>
</table>
<a name='type-bwm-walkmesh_properties'></a>
<h2>Type: WalkmeshProperties</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>walkmesh_type</td>
<td>u4le</td>
<td>Walkmesh type identifier:
- 0 = PWK/DWK (Placeable/Door walkmesh)
- 1 = WOK (Area walkmesh)
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>relative_use_position_1</td>
<td><a href="#type-bwm-vec3f">Vec3f</a></td>
<td>Relative use hook position 1 (x, y, z).
Position relative to the walkmesh origin, used when the walkmesh may be transformed.
For doors: Defines where the player must stand to interact (relative to door model).
For placeables: Defines interaction points relative to the object's local coordinate system.
</td>
</tr>
<tr>
<td>16</td>
<td>...</td>
<td>relative_use_position_2</td>
<td><a href="#type-bwm-vec3f">Vec3f</a></td>
<td>Relative use hook position 2 (x, y, z).
Second interaction point relative to the walkmesh origin.
</td>
</tr>
<tr>
<td>28</td>
<td>...</td>
<td>absolute_use_position_1</td>
<td><a href="#type-bwm-vec3f">Vec3f</a></td>
<td>Absolute use hook position 1 (x, y, z).
Position in world space, used when the walkmesh position is known.
For doors: Precomputed world-space interaction points (position + relative hook).
For placeables: World-space interaction points accounting for object placement.
</td>
</tr>
<tr>
<td>40</td>
<td>...</td>
<td>absolute_use_position_2</td>
<td><a href="#type-bwm-vec3f">Vec3f</a></td>
<td>Absolute use hook position 2 (x, y, z).
Second absolute interaction point in world space.
</td>
</tr>
<tr>
<td>52</td>
<td>...</td>
<td>position</td>
<td><a href="#type-bwm-vec3f">Vec3f</a></td>
<td>Walkmesh position offset (x, y, z) in world space.
For area walkmeshes (WOK): Typically (0, 0, 0) as areas define their own coordinate system.
For placeable/door walkmeshes: The position where the object is placed in the area.
Used to transform vertices from local to world coordinates.
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(is_area_walkmesh),List(types, walkmesh_properties, instances, is_area_walkmesh),Compare(Name(identifier(walkmesh_type)),Eq,IntNum(1)),None,Some(CalcBooleanType),DocSpec(Some(True if this is an area walkmesh (WOK), false if placeable/door (PWK/DWK)),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(is_placeable_or_door),List(types, walkmesh_properties, instances, is_placeable_or_door),Compare(Name(identifier(walkmesh_type)),Eq,IntNum(0)),None,Some(CalcBooleanType),DocSpec(Some(True if this is a placeable or door walkmesh (PWK/DWK)),List()))

  </div>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>
  </body>
</html>
      
