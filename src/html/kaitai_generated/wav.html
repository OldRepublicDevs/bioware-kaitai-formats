
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">

    <title>Wav format specification</title>
  </head>
  <body>
           <div class="container">
  <h1>Wav format specification</h1>

      
<a name='type-wav'></a>
<h1>Type: Wav</h1>

<p>WAV (Waveform Audio Format) files used in KotOR. KotOR stores both standard WAV voice-over lines
and Bioware-obfuscated sound-effect files. Voice-over assets are regular RIFF containers with PCM
headers, while SFX assets prepend a 470-byte custom block before the RIFF data.

Format Types:
- VO (Voice-over): Plain RIFF/WAVE PCM files readable by any media player
- SFX (Sound effects): Contains a Bioware 470-byte obfuscation header followed by RIFF data
- MP3-in-WAV: Special RIFF container with MP3 data (RIFF size = 50)

Note: This Kaitai Struct definition documents the core RIFF/WAVE structure. SFX and VO headers
(470-byte and 20-byte prefixes respectively) are handled by application-level deobfuscation.

References:
- https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
- https://github.com/seedhartha/reone/blob/master/src/libs/audio/format/wavreader.cpp:30-56
- https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:34-84
</p>
<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>riff_header</td>
<td><a href="#type-wav-riff_header">RiffHeader</a></td>
<td>RIFF container header</td>
</tr>
<tr>
<td>12</td>
<td>...</td>
<td>chunks</td>
<td><a href="#type-wav-chunk">Chunk</a></td>
<td>RIFF chunks in sequence (fmt, fact, data, etc.)
Parsed until end of file
Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:46-55
</td>
</tr>
</table>
<a name='type-wav-chunk'></a>
<h2>Type: Chunk</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>id</td>
<td>str(ASCII)</td>
<td>Chunk ID (4-character ASCII string)
Common values: "fmt ", "data", "fact", "LIST", etc.
Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:58-72
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>size</td>
<td>u4le</td>
<td>Chunk size in bytes (chunk data only, excluding ID and size fields)
Chunks are word-aligned (even byte boundaries)
Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:66
</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>body</td>
<td>SwitchType(Name(identifier(id)),TreeMap(Name(identifier(_)) -> UserTypeInstream(List(unknown_chunk_body),None,List()), Str(data) -> UserTypeInstream(List(data_chunk_body),None,List()), Str(fact) -> UserTypeInstream(List(fact_chunk_body),None,List()), Str(fmt ) -> UserTypeInstream(List(format_chunk_body),None,List())),true,false)</td>
<td>Chunk body (content depends on chunk ID)</td>
</tr>
</table>
<a name='type-wav-data_chunk_body'></a>
<h2>Type: DataChunkBody</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>data</td>
<td></td>
<td>Raw audio data (PCM samples or compressed audio)
Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:79-80
</td>
</tr>
</table>
<a name='type-wav-fact_chunk_body'></a>
<h2>Type: FactChunkBody</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>sample_count</td>
<td>u4le</td>
<td>Sample count (number of samples in compressed audio)
Used for compressed formats like ADPCM
Reference: https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/wav/io_wav.py:189-192
</td>
</tr>
</table>
<a name='type-wav-format_chunk_body'></a>
<h2>Type: FormatChunkBody</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>audio_format</td>
<td>u2le</td>
<td>Audio format code:
- 0x0001 = PCM (Linear PCM, uncompressed)
- 0x0002 = Microsoft ADPCM
- 0x0006 = A-Law companded
- 0x0007 = μ-Law companded
- 0x0011 = IMA ADPCM (DVI ADPCM)
- 0x0055 = MPEG Layer 3 (MP3)
Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
</td>
</tr>
<tr>
<td>2</td>
<td>...</td>
<td>channels</td>
<td>u2le</td>
<td>Number of audio channels:
- 1 = mono
- 2 = stereo
Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>sample_rate</td>
<td>u4le</td>
<td>Sample rate in Hz
Typical values:
- 22050 Hz for SFX
- 44100 Hz for VO
Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>bytes_per_sec</td>
<td>u4le</td>
<td>Byte rate (average bytes per second)
Formula: sample_rate × block_align
Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
</td>
</tr>
<tr>
<td>12</td>
<td>...</td>
<td>block_align</td>
<td>u2le</td>
<td>Block alignment (bytes per sample frame)
Formula for PCM: channels × (bits_per_sample / 8)
Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
</td>
</tr>
<tr>
<td>14</td>
<td>...</td>
<td>bits_per_sample</td>
<td>u2le</td>
<td>Bits per sample
Common values: 8, 16
For PCM: typically 16-bit
Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
</td>
</tr>
<tr>
<td>16</td>
<td>...</td>
<td>extra_format_bytes</td>
<td></td>
<td>Extra format bytes (present when fmt chunk size > 16)
For IMA ADPCM and other compressed formats, contains:
- Extra format size (u2)
- Format-specific data (e.g., ADPCM coefficients)
Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:66
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(is_ima_adpcm),List(types, format_chunk_body, instances, is_ima_adpcm),Compare(Name(identifier(audio_format)),Eq,IntNum(17)),None,Some(CalcBooleanType),DocSpec(Some(True if audio format is IMA ADPCM (compressed)),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(is_mp3),List(types, format_chunk_body, instances, is_mp3),Compare(Name(identifier(audio_format)),Eq,IntNum(85)),None,Some(CalcBooleanType),DocSpec(Some(True if audio format is MP3),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(is_pcm),List(types, format_chunk_body, instances, is_pcm),Compare(Name(identifier(audio_format)),Eq,IntNum(1)),None,Some(CalcBooleanType),DocSpec(Some(True if audio format is PCM (uncompressed)),List()))
<a name='type-wav-riff_header'></a>
<h2>Type: RiffHeader</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>riff_id</td>
<td>str(ASCII)</td>
<td>RIFF chunk ID: "RIFF"</td>
</tr>
<tr>
<td>4</td>
<td>...</td>
<td>riff_size</td>
<td>u4le</td>
<td>File size minus 8 bytes (RIFF_ID + RIFF_SIZE itself)
For MP3-in-WAV format, this is 50
Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
</td>
</tr>
<tr>
<td>8</td>
<td>...</td>
<td>wave_id</td>
<td>str(ASCII)</td>
<td>Format tag: "WAVE"</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(is_mp3_in_wav),List(types, riff_header, instances, is_mp3_in_wav),Compare(Name(identifier(riff_size)),Eq,IntNum(50)),None,Some(CalcBooleanType),DocSpec(Some(MP3-in-WAV format detected when RIFF size = 50
Reference: https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/wav/wav_obfuscation.py:60-64
),List()))
<a name='type-wav-unknown_chunk_body'></a>
<h2>Type: UnknownChunkBody</h2>

<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>data</td>
<td></td>
<td>Unknown chunk body (skip for compatibility)
Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:53-54
</td>
</tr>
<tr>
<td>???</td>
<td>...</td>
<td>padding</td>
<td>u1</td>
<td>Padding byte to align to word boundary (only if chunk size is odd)
RIFF chunks must be aligned to 2-byte boundaries
Reference: https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/wav/io_wav.py:153-156
</td>
</tr>
</table>

  </div>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>
  </body>
</html>
      
