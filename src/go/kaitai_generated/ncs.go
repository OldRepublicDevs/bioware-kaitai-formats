// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"


/**
 * NCS (NWScript Compiled) files contain compiled NWScript bytecode used in KotOR and TSL.
 * Scripts run inside a stack-based virtual machine shared across Aurora engine games.
 * 
 * Format Structure:
 * - Header (13 bytes): Signature "NCS ", version "V1.0", size marker (0x42), file size
 * - Instruction Stream: Sequence of bytecode instructions
 * 
 * All multi-byte values in NCS files are stored in BIG-ENDIAN byte order (network byte order).
 * 
 * References:
 * - https://github.com/OldRepublicDevs/PyKotor/wiki/NCS-File-Format.md - Complete NCS format documentation
 * - NSS.ksy - NWScript source code that compiles to NCS
 */
type Ncs struct {
	FileType string
	FileVersion string
	SizeMarker uint8
	FileSize uint32
	Instructions []*Ncs_Instruction
	_io *kaitai.Stream
	_root *Ncs
	_parent kaitai.Struct
}
func NewNcs() *Ncs {
	return &Ncs{
	}
}

func (this Ncs) IO_() *kaitai.Stream {
	return this._io
}

func (this *Ncs) Read(io *kaitai.Stream, parent kaitai.Struct, root *Ncs) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp1 = tmp1
	this.FileType = string(tmp1)
	if !(this.FileType == "NCS ") {
		return kaitai.NewValidationNotEqualError("NCS ", this.FileType, this._io, "/seq/0")
	}
	tmp2, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp2 = tmp2
	this.FileVersion = string(tmp2)
	if !(this.FileVersion == "V1.0") {
		return kaitai.NewValidationNotEqualError("V1.0", this.FileVersion, this._io, "/seq/1")
	}
	tmp3, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.SizeMarker = tmp3
	if !(this.SizeMarker == 66) {
		return kaitai.NewValidationNotEqualError(66, this.SizeMarker, this._io, "/seq/2")
	}
	tmp4, err := this._io.ReadU4be()
	if err != nil {
		return err
	}
	this.FileSize = uint32(tmp4)
	for i := 1;; i++ {
		tmp5 := NewNcs_Instruction()
		err = tmp5.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		_it := tmp5
		this.Instructions = append(this.Instructions, _it)
		tmp6, err := this._io.Pos()
		if err != nil {
			return err
		}
		if tmp6 >= this.FileSize {
			break
		}
	}
	return err
}

/**
 * File type signature. Must be "NCS " (0x4E 0x43 0x53 0x20).
 */

/**
 * File format version. Must be "V1.0" (0x56 0x31 0x2E 0x30).
 */

/**
 * Program size marker opcode. Must be 0x42.
 * This is not a real instruction but a metadata field containing the total file size.
 * All implementations validate this marker before parsing instructions.
 */

/**
 * Total file size in bytes (big-endian).
 * This value should match the actual file size.
 */

/**
 * Stream of bytecode instructions.
 * Execution begins at offset 13 (0x0D) after the header.
 * Instructions continue until end of file.
 */

/**
 * NWScript bytecode instruction.
 * Format: <opcode: uint8> <qualifier: uint8> <arguments: variable>
 * 
 * Instruction size varies by opcode:
 * - Base: 2 bytes (opcode + qualifier)
 * - Arguments: 0 to variable bytes depending on instruction type
 * 
 * Common instruction types:
 * - Constants: CONSTI (6B), CONSTF (6B), CONSTS (2+N B), CONSTO (6B)
 * - Stack ops: CPDOWNSP, CPTOPSP, MOVSP (variable size)
 * - Arithmetic: ADDxx, SUBxx, MULxx, DIVxx (2B)
 * - Control flow: JMP, JSR, JZ, JNZ (6B), RETN (2B)
 * - Function calls: ACTION (5B)
 * - And many more (see NCS format documentation)
 */
type Ncs_Instruction struct {
	Opcode uint8
	Qualifier uint8
	Arguments []uint8
	_io *kaitai.Stream
	_root *Ncs
	_parent *Ncs
}
func NewNcs_Instruction() *Ncs_Instruction {
	return &Ncs_Instruction{
	}
}

func (this Ncs_Instruction) IO_() *kaitai.Stream {
	return this._io
}

func (this *Ncs_Instruction) Read(io *kaitai.Stream, parent *Ncs, root *Ncs) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp7, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Opcode = tmp7
	tmp8, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Qualifier = tmp8
	for i := 1;; i++ {
		tmp9, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		_it := tmp9
		this.Arguments = append(this.Arguments, _it)
		tmp10, err := this._io.Pos()
		if err != nil {
			return err
		}
		tmp11, err := this._io.Size()
		if err != nil {
			return err
		}
		if tmp10 >= tmp11 {
			break
		}
	}
	return err
}

/**
 * Instruction opcode (0x01-0x2D, excluding 0x42 which is reserved for size marker).
 * Determines the instruction type and argument format.
 */

/**
 * Qualifier byte that refines the instruction to specific operand types.
 * Examples: 0x03=Int, 0x04=Float, 0x05=String, 0x06=Object, 0x24=Structure
 */

/**
 * Instruction arguments (variable size).
 * Format depends on opcode:
 * - No args: None (total 2B)
 * - Int/Float/Object: 4 bytes (total 6B)
 * - String: 2B length + data (total 2+N B)
 * - Jump: 4B signed offset (total 6B)
 * - Stack copy: 4B offset + 2B size (total 8B)
 * - ACTION: 2B routine + 1B argCount (total 5B)
 * - DESTRUCT: 2B size + 2B offset + 2B sizeNoDestroy (total 8B)
 * - STORE_STATE: 4B size + 4B sizeLocals (total 10B)
 * - And others (see documentation)
 */
