// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"


/**
 * LTR (Letter) resources store third-order Markov chain probability tables that the game uses
 * to procedurally generate NPC names. The data encodes likelihoods for characters appearing at
 * the start, middle, and end of names given zero, one, or two-character context.
 * 
 * KotOR always uses the 28-character alphabet (a-z plus ' and -). Neverwinter Nights (NWN) used
 * 26 characters; the header explicitly stores the count. This is a KotOR-specific difference from NWN.
 * 
 * LTR files are binary and consist of a short header followed by three probability tables
 * (singles, doubles, triples) stored as contiguous float arrays.
 * 
 * References:
 * - https://github.com/OldRepublicDevs/PyKotor/wiki/LTR-File-Format.md
 * - https://github.com/seedhartha/reone/blob/master/src/libs/resource/format/ltrreader.cpp:27-74
 * - https://github.com/xoreos/xoreos/blob/master/src/aurora/ltrfile.cpp:135-168
 * - https://github.com/KotOR-Community-Patches/KotOR.js/blob/master/src/resource/LTRObject.ts:61-117
 */
type Ltr struct {
	FileType string
	FileVersion string
	LetterCount uint8
	SingleLetterBlock *Ltr_LetterBlock
	DoubleLetterBlocks *Ltr_DoubleLetterBlocksArray
	TripleLetterBlocks *Ltr_TripleLetterBlocksArray
	_io *kaitai.Stream
	_root *Ltr
	_parent kaitai.Struct
}
func NewLtr() *Ltr {
	return &Ltr{
	}
}

func (this Ltr) IO_() *kaitai.Stream {
	return this._io
}

func (this *Ltr) Read(io *kaitai.Stream, parent kaitai.Struct, root *Ltr) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp1 = tmp1
	this.FileType = string(tmp1)
	tmp2, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp2 = tmp2
	this.FileVersion = string(tmp2)
	tmp3, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.LetterCount = tmp3
	tmp4 := NewLtr_LetterBlock()
	err = tmp4.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.SingleLetterBlock = tmp4
	tmp5 := NewLtr_DoubleLetterBlocksArray()
	err = tmp5.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.DoubleLetterBlocks = tmp5
	tmp6 := NewLtr_TripleLetterBlocksArray()
	err = tmp6.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.TripleLetterBlocks = tmp6
	return err
}

/**
 * File type signature. Must be "LTR " (space-padded) for LTR files.
 */

/**
 * File format version. Must be "V1.0" for LTR files.
 */

/**
 * Number of characters in the alphabet. Must be 26 (NWN) or 28 (KotOR).
 * KotOR uses 28 characters: "abcdefghijklmnopqrstuvwxyz'-"
 * NWN uses 26 characters: "abcdefghijklmnopqrstuvwxyz"
 */

/**
 * Single-letter probability block (no context).
 * Used for generating the first character of names.
 * Contains start/middle/end probability arrays, each with letter_count floats.
 * Total size: letter_count × 3 × 4 bytes = 336 bytes for KotOR (28 chars).
 */

/**
 * Double-letter probability blocks (1-character context).
 * Array of letter_count blocks, each indexed by the previous character.
 * Used for generating the second character based on the first character.
 * Each block contains start/middle/end probability arrays.
 * Total size: letter_count × 3 × letter_count × 4 bytes = 9,408 bytes for KotOR.
 */

/**
 * Triple-letter probability blocks (2-character context).
 * Two-dimensional array of letter_count × letter_count blocks.
 * Each block is indexed by the previous two characters.
 * Used for generating third and subsequent characters.
 * Each block contains start/middle/end probability arrays.
 * Total size: letter_count × letter_count × 3 × letter_count × 4 bytes = 73,472 bytes for KotOR.
 */

/**
 * Array of double-letter blocks. One block per character in the alphabet.
 * Each block is indexed by the previous character (context length 1).
 */
type Ltr_DoubleLetterBlocksArray struct {
	Blocks []*Ltr_LetterBlock
	_io *kaitai.Stream
	_root *Ltr
	_parent *Ltr
}
func NewLtr_DoubleLetterBlocksArray() *Ltr_DoubleLetterBlocksArray {
	return &Ltr_DoubleLetterBlocksArray{
	}
}

func (this Ltr_DoubleLetterBlocksArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Ltr_DoubleLetterBlocksArray) Read(io *kaitai.Stream, parent *Ltr, root *Ltr) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.LetterCount); i++ {
		_ = i
		tmp7 := NewLtr_LetterBlock()
		err = tmp7.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Blocks = append(this.Blocks, tmp7)
	}
	return err
}

/**
 * Array of letter_count blocks, each containing start/middle/end probability arrays.
 * Block index corresponds to the previous character in the alphabet.
 */

/**
 * A probability block containing three arrays of probabilities (start, middle, end).
 * Each array has letter_count floats representing cumulative probabilities for each character
 * in the alphabet appearing at that position (start, middle, or end of name).
 * 
 * Blocks store cumulative probabilities (monotonically increasing floats) that are compared
 * against random roll values during name generation.
 */
type Ltr_LetterBlock struct {
	StartProbabilities []float32
	MiddleProbabilities []float32
	EndProbabilities []float32
	_io *kaitai.Stream
	_root *Ltr
	_parent kaitai.Struct
}
func NewLtr_LetterBlock() *Ltr_LetterBlock {
	return &Ltr_LetterBlock{
	}
}

func (this Ltr_LetterBlock) IO_() *kaitai.Stream {
	return this._io
}

func (this *Ltr_LetterBlock) Read(io *kaitai.Stream, parent kaitai.Struct, root *Ltr) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.LetterCount); i++ {
		_ = i
		tmp8, err := this._io.ReadF4le()
		if err != nil {
			return err
		}
		this.StartProbabilities = append(this.StartProbabilities, tmp8)
	}
	for i := 0; i < int(this._root.LetterCount); i++ {
		_ = i
		tmp9, err := this._io.ReadF4le()
		if err != nil {
			return err
		}
		this.MiddleProbabilities = append(this.MiddleProbabilities, tmp9)
	}
	for i := 0; i < int(this._root.LetterCount); i++ {
		_ = i
		tmp10, err := this._io.ReadF4le()
		if err != nil {
			return err
		}
		this.EndProbabilities = append(this.EndProbabilities, tmp10)
	}
	return err
}

/**
 * Array of start probabilities. One float per character in alphabet.
 * Probability of each letter starting a name (no context for singles,
 * after previous character for doubles, after previous two for triples).
 */

/**
 * Array of middle probabilities. One float per character in alphabet.
 * Probability of each letter appearing in the middle of a name.
 */

/**
 * Array of end probabilities. One float per character in alphabet.
 * Probability of each letter ending a name.
 */

/**
 * Two-dimensional array of triple-letter blocks. letter_count × letter_count blocks total.
 * Each block is indexed by the previous two characters (context length 2).
 */
type Ltr_TripleLetterBlocksArray struct {
	Rows []*Ltr_TripleLetterRow
	_io *kaitai.Stream
	_root *Ltr
	_parent *Ltr
}
func NewLtr_TripleLetterBlocksArray() *Ltr_TripleLetterBlocksArray {
	return &Ltr_TripleLetterBlocksArray{
	}
}

func (this Ltr_TripleLetterBlocksArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Ltr_TripleLetterBlocksArray) Read(io *kaitai.Stream, parent *Ltr, root *Ltr) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.LetterCount); i++ {
		_ = i
		tmp11 := NewLtr_TripleLetterRow()
		err = tmp11.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Rows = append(this.Rows, tmp11)
	}
	return err
}

/**
 * Array of letter_count rows, each containing letter_count blocks.
 * First index corresponds to the second-to-last character.
 * Second index corresponds to the last character.
 */

/**
 * A row in the triple-letter blocks array. Contains letter_count blocks,
 * each indexed by the last character in the two-character context.
 */
type Ltr_TripleLetterRow struct {
	Blocks []*Ltr_LetterBlock
	_io *kaitai.Stream
	_root *Ltr
	_parent *Ltr_TripleLetterBlocksArray
}
func NewLtr_TripleLetterRow() *Ltr_TripleLetterRow {
	return &Ltr_TripleLetterRow{
	}
}

func (this Ltr_TripleLetterRow) IO_() *kaitai.Stream {
	return this._io
}

func (this *Ltr_TripleLetterRow) Read(io *kaitai.Stream, parent *Ltr_TripleLetterBlocksArray, root *Ltr) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.LetterCount); i++ {
		_ = i
		tmp12 := NewLtr_LetterBlock()
		err = tmp12.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Blocks = append(this.Blocks, tmp12)
	}
	return err
}

/**
 * Array of letter_count blocks, each containing start/middle/end probability arrays.
 * Block index corresponds to the last character in the two-character context.
 */
