// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"


/**
 * WAV (Waveform Audio Format) files used in KotOR. KotOR stores both standard WAV voice-over lines
 * and Bioware-obfuscated sound-effect files. Voice-over assets are regular RIFF containers with PCM
 * headers, while SFX assets prepend a 470-byte custom block before the RIFF data.
 * 
 * Format Types:
 * - VO (Voice-over): Plain RIFF/WAVE PCM files readable by any media player
 * - SFX (Sound effects): Contains a Bioware 470-byte obfuscation header followed by RIFF data
 * - MP3-in-WAV: Special RIFF container with MP3 data (RIFF size = 50)
 * 
 * Note: This Kaitai Struct definition documents the core RIFF/WAVE structure. SFX and VO headers
 * (470-byte and 20-byte prefixes respectively) are handled by application-level deobfuscation.
 * 
 * References:
 * - https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
 * - https://github.com/seedhartha/reone/blob/master/src/libs/audio/format/wavreader.cpp:30-56
 * - https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:34-84
 */
type Wav struct {
	RiffHeader *Wav_RiffHeader
	Chunks []*Wav_Chunk
	_io *kaitai.Stream
	_root *Wav
	_parent kaitai.Struct
}
func NewWav() *Wav {
	return &Wav{
	}
}

func (this Wav) IO_() *kaitai.Stream {
	return this._io
}

func (this *Wav) Read(io *kaitai.Stream, parent kaitai.Struct, root *Wav) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1 := NewWav_RiffHeader()
	err = tmp1.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.RiffHeader = tmp1
	for i := 1;; i++ {
		tmp2 := NewWav_Chunk()
		err = tmp2.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		_it := tmp2
		this.Chunks = append(this.Chunks, _it)
		tmp3, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp3 {
			break
		}
	}
	return err
}

/**
 * RIFF container header
 */

/**
 * RIFF chunks in sequence (fmt, fact, data, etc.)
 * Parsed until end of file
 * Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:46-55
 */
type Wav_Chunk struct {
	Id string
	Size uint32
	Body kaitai.Struct
	_io *kaitai.Stream
	_root *Wav
	_parent *Wav
}
func NewWav_Chunk() *Wav_Chunk {
	return &Wav_Chunk{
	}
}

func (this Wav_Chunk) IO_() *kaitai.Stream {
	return this._io
}

func (this *Wav_Chunk) Read(io *kaitai.Stream, parent *Wav, root *Wav) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp4, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp4 = tmp4
	this.Id = string(tmp4)
	tmp5, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Size = uint32(tmp5)
	switch (this.Id) {
	case "data":
		tmp6 := NewWav_DataChunkBody()
		err = tmp6.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp6
	case "fact":
		tmp7 := NewWav_FactChunkBody()
		err = tmp7.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp7
	case "fmt ":
		tmp8 := NewWav_FormatChunkBody()
		err = tmp8.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp8
	default:
		tmp9 := NewWav_UnknownChunkBody()
		err = tmp9.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Body = tmp9
	}
	return err
}

/**
 * Chunk ID (4-character ASCII string)
 * Common values: "fmt ", "data", "fact", "LIST", etc.
 * Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:58-72
 */

/**
 * Chunk size in bytes (chunk data only, excluding ID and size fields)
 * Chunks are word-aligned (even byte boundaries)
 * Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:66
 */

/**
 * Chunk body (content depends on chunk ID)
 */
type Wav_DataChunkBody struct {
	Data []byte
	_io *kaitai.Stream
	_root *Wav
	_parent *Wav_Chunk
}
func NewWav_DataChunkBody() *Wav_DataChunkBody {
	return &Wav_DataChunkBody{
	}
}

func (this Wav_DataChunkBody) IO_() *kaitai.Stream {
	return this._io
}

func (this *Wav_DataChunkBody) Read(io *kaitai.Stream, parent *Wav_Chunk, root *Wav) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp10, err := this._io.ReadBytes(int(this._parent.Size))
	if err != nil {
		return err
	}
	tmp10 = tmp10
	this.Data = tmp10
	return err
}

/**
 * Raw audio data (PCM samples or compressed audio)
 * Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:79-80
 */
type Wav_FactChunkBody struct {
	SampleCount uint32
	_io *kaitai.Stream
	_root *Wav
	_parent *Wav_Chunk
}
func NewWav_FactChunkBody() *Wav_FactChunkBody {
	return &Wav_FactChunkBody{
	}
}

func (this Wav_FactChunkBody) IO_() *kaitai.Stream {
	return this._io
}

func (this *Wav_FactChunkBody) Read(io *kaitai.Stream, parent *Wav_Chunk, root *Wav) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp11, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.SampleCount = uint32(tmp11)
	return err
}

/**
 * Sample count (number of samples in compressed audio)
 * Used for compressed formats like ADPCM
 * Reference: https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/wav/io_wav.py:189-192
 */
type Wav_FormatChunkBody struct {
	AudioFormat uint16
	Channels uint16
	SampleRate uint32
	BytesPerSec uint32
	BlockAlign uint16
	BitsPerSample uint16
	ExtraFormatBytes []byte
	_io *kaitai.Stream
	_root *Wav
	_parent *Wav_Chunk
	_f_isImaAdpcm bool
	isImaAdpcm bool
	_f_isMp3 bool
	isMp3 bool
	_f_isPcm bool
	isPcm bool
}
func NewWav_FormatChunkBody() *Wav_FormatChunkBody {
	return &Wav_FormatChunkBody{
	}
}

func (this Wav_FormatChunkBody) IO_() *kaitai.Stream {
	return this._io
}

func (this *Wav_FormatChunkBody) Read(io *kaitai.Stream, parent *Wav_Chunk, root *Wav) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp12, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.AudioFormat = uint16(tmp12)
	tmp13, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Channels = uint16(tmp13)
	tmp14, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.SampleRate = uint32(tmp14)
	tmp15, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.BytesPerSec = uint32(tmp15)
	tmp16, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.BlockAlign = uint16(tmp16)
	tmp17, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.BitsPerSample = uint16(tmp17)
	if (this._parent.Size > 16) {
		tmp18, err := this._io.ReadBytes(int(this._parent.Size - 16))
		if err != nil {
			return err
		}
		tmp18 = tmp18
		this.ExtraFormatBytes = tmp18
	}
	return err
}

/**
 * True if audio format is IMA ADPCM (compressed)
 */
func (this *Wav_FormatChunkBody) IsImaAdpcm() (v bool, err error) {
	if (this._f_isImaAdpcm) {
		return this.isImaAdpcm, nil
	}
	this._f_isImaAdpcm = true
	this.isImaAdpcm = bool(this.AudioFormat == 17)
	return this.isImaAdpcm, nil
}

/**
 * True if audio format is MP3
 */
func (this *Wav_FormatChunkBody) IsMp3() (v bool, err error) {
	if (this._f_isMp3) {
		return this.isMp3, nil
	}
	this._f_isMp3 = true
	this.isMp3 = bool(this.AudioFormat == 85)
	return this.isMp3, nil
}

/**
 * True if audio format is PCM (uncompressed)
 */
func (this *Wav_FormatChunkBody) IsPcm() (v bool, err error) {
	if (this._f_isPcm) {
		return this.isPcm, nil
	}
	this._f_isPcm = true
	this.isPcm = bool(this.AudioFormat == 1)
	return this.isPcm, nil
}

/**
 * Audio format code:
 * - 0x0001 = PCM (Linear PCM, uncompressed)
 * - 0x0002 = Microsoft ADPCM
 * - 0x0006 = A-Law companded
 * - 0x0007 = μ-Law companded
 * - 0x0011 = IMA ADPCM (DVI ADPCM)
 * - 0x0055 = MPEG Layer 3 (MP3)
 * Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
 */

/**
 * Number of audio channels:
 * - 1 = mono
 * - 2 = stereo
 * Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
 */

/**
 * Sample rate in Hz
 * Typical values:
 * - 22050 Hz for SFX
 * - 44100 Hz for VO
 * Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
 */

/**
 * Byte rate (average bytes per second)
 * Formula: sample_rate × block_align
 * Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
 */

/**
 * Block alignment (bytes per sample frame)
 * Formula for PCM: channels × (bits_per_sample / 8)
 * Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
 */

/**
 * Bits per sample
 * Common values: 8, 16
 * For PCM: typically 16-bit
 * Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
 */

/**
 * Extra format bytes (present when fmt chunk size > 16)
 * For IMA ADPCM and other compressed formats, contains:
 * - Extra format size (u2)
 * - Format-specific data (e.g., ADPCM coefficients)
 * Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:66
 */
type Wav_RiffHeader struct {
	RiffId string
	RiffSize uint32
	WaveId string
	_io *kaitai.Stream
	_root *Wav
	_parent *Wav
	_f_isMp3InWav bool
	isMp3InWav bool
}
func NewWav_RiffHeader() *Wav_RiffHeader {
	return &Wav_RiffHeader{
	}
}

func (this Wav_RiffHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Wav_RiffHeader) Read(io *kaitai.Stream, parent *Wav, root *Wav) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp19, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp19 = tmp19
	this.RiffId = string(tmp19)
	if !(this.RiffId == "RIFF") {
		return kaitai.NewValidationNotEqualError("RIFF", this.RiffId, this._io, "/types/riff_header/seq/0")
	}
	tmp20, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.RiffSize = uint32(tmp20)
	tmp21, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp21 = tmp21
	this.WaveId = string(tmp21)
	if !(this.WaveId == "WAVE") {
		return kaitai.NewValidationNotEqualError("WAVE", this.WaveId, this._io, "/types/riff_header/seq/2")
	}
	return err
}

/**
 * MP3-in-WAV format detected when RIFF size = 50
 * Reference: https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/wav/wav_obfuscation.py:60-64
 */
func (this *Wav_RiffHeader) IsMp3InWav() (v bool, err error) {
	if (this._f_isMp3InWav) {
		return this.isMp3InWav, nil
	}
	this._f_isMp3InWav = true
	this.isMp3InWav = bool(this.RiffSize == 50)
	return this.isMp3InWav, nil
}

/**
 * RIFF chunk ID: "RIFF"
 */

/**
 * File size minus 8 bytes (RIFF_ID + RIFF_SIZE itself)
 * For MP3-in-WAV format, this is 50
 * Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/WAV-File-Format.md
 */

/**
 * Format tag: "WAVE"
 */
type Wav_UnknownChunkBody struct {
	Data []byte
	Padding uint8
	_io *kaitai.Stream
	_root *Wav
	_parent *Wav_Chunk
}
func NewWav_UnknownChunkBody() *Wav_UnknownChunkBody {
	return &Wav_UnknownChunkBody{
	}
}

func (this Wav_UnknownChunkBody) IO_() *kaitai.Stream {
	return this._io
}

func (this *Wav_UnknownChunkBody) Read(io *kaitai.Stream, parent *Wav_Chunk, root *Wav) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp22, err := this._io.ReadBytes(int(this._parent.Size))
	if err != nil {
		return err
	}
	tmp22 = tmp22
	this.Data = tmp22
	tmp23 := this._parent.Size % 2
	if tmp23 < 0 {
		tmp23 += 2
	}
	if (tmp23 == 1) {
		tmp24, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Padding = tmp24
	}
	return err
}

/**
 * Unknown chunk body (skip for compatibility)
 * Reference: https://github.com/xoreos/xoreos/blob/master/src/sound/decoders/wave.cpp:53-54
 */

/**
 * Padding byte to align to word boundary (only if chunk size is odd)
 * RIFF chunks must be aligned to 2-byte boundaries
 * Reference: https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/wav/io_wav.py:153-156
 */
