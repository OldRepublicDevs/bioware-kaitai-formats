// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"io"
	"bytes"
)


/**
 * BioWare MDL Model Format
 * 
 * The MDL file contains:
 * - File header (12 bytes)
 * - Model header (196 bytes) which begins with a Geometry header (80 bytes)
 * - Name offset array + name strings
 * - Animation offset array + animation headers + animation nodes
 * - Node hierarchy with geometry data
 * 
 * Reference implementations:
 * - https://github.com/th3w1zard1/MDLOpsM.pm
 * - https://github.com/OldRepublicDevs/PyKotor/wiki/MDL-MDX-File-Format.md
 * @see <a href="https://github.com/th3w1zard1/PyKotor/wiki/MDL-MDX-File-Format.md">Source</a>
 */

type Mdl_ControllerType int
const (
	Mdl_ControllerType__Position Mdl_ControllerType = 8
	Mdl_ControllerType__Orientation Mdl_ControllerType = 20
	Mdl_ControllerType__Scale Mdl_ControllerType = 36
	Mdl_ControllerType__Color Mdl_ControllerType = 76
	Mdl_ControllerType__Radius Mdl_ControllerType = 88
	Mdl_ControllerType__ShadowRadius Mdl_ControllerType = 96
	Mdl_ControllerType__VerticalDisplacementOrDragOrSelfillumcolor Mdl_ControllerType = 100
	Mdl_ControllerType__Alpha Mdl_ControllerType = 132
	Mdl_ControllerType__MultiplierOrRandvel Mdl_ControllerType = 140
)
var values_Mdl_ControllerType = map[Mdl_ControllerType]struct{}{8: {}, 20: {}, 36: {}, 76: {}, 88: {}, 96: {}, 100: {}, 132: {}, 140: {}}
func (v Mdl_ControllerType) isDefined() bool {
	_, ok := values_Mdl_ControllerType[v]
	return ok
}

type Mdl_ModelClassification int
const (
	Mdl_ModelClassification__Other Mdl_ModelClassification = 0
	Mdl_ModelClassification__Effect Mdl_ModelClassification = 1
	Mdl_ModelClassification__Tile Mdl_ModelClassification = 2
	Mdl_ModelClassification__Character Mdl_ModelClassification = 4
	Mdl_ModelClassification__Door Mdl_ModelClassification = 8
	Mdl_ModelClassification__Lightsaber Mdl_ModelClassification = 16
	Mdl_ModelClassification__Placeable Mdl_ModelClassification = 32
	Mdl_ModelClassification__Flyer Mdl_ModelClassification = 64
)
var values_Mdl_ModelClassification = map[Mdl_ModelClassification]struct{}{0: {}, 1: {}, 2: {}, 4: {}, 8: {}, 16: {}, 32: {}, 64: {}}
func (v Mdl_ModelClassification) isDefined() bool {
	_, ok := values_Mdl_ModelClassification[v]
	return ok
}

type Mdl_NodeTypeValue int
const (
	Mdl_NodeTypeValue__Dummy Mdl_NodeTypeValue = 1
	Mdl_NodeTypeValue__Light Mdl_NodeTypeValue = 3
	Mdl_NodeTypeValue__Emitter Mdl_NodeTypeValue = 5
	Mdl_NodeTypeValue__Reference Mdl_NodeTypeValue = 17
	Mdl_NodeTypeValue__Trimesh Mdl_NodeTypeValue = 33
	Mdl_NodeTypeValue__Skinmesh Mdl_NodeTypeValue = 97
	Mdl_NodeTypeValue__Animmesh Mdl_NodeTypeValue = 161
	Mdl_NodeTypeValue__Danglymesh Mdl_NodeTypeValue = 289
	Mdl_NodeTypeValue__Aabb Mdl_NodeTypeValue = 545
	Mdl_NodeTypeValue__Lightsaber Mdl_NodeTypeValue = 2081
)
var values_Mdl_NodeTypeValue = map[Mdl_NodeTypeValue]struct{}{1: {}, 3: {}, 5: {}, 17: {}, 33: {}, 97: {}, 161: {}, 289: {}, 545: {}, 2081: {}}
func (v Mdl_NodeTypeValue) isDefined() bool {
	_, ok := values_Mdl_NodeTypeValue[v]
	return ok
}
type Mdl struct {
	FileHeader *Mdl_FileHeader
	ModelHeader *Mdl_ModelHeader
	_io *kaitai.Stream
	_root *Mdl
	_parent kaitai.Struct
	_raw_namesData []byte
	_f_animationOffsets bool
	animationOffsets []uint32
	_f_animations bool
	animations []*Mdl_AnimationHeader
	_f_dataStart bool
	dataStart int8
	_f_nameOffsets bool
	nameOffsets []uint32
	_f_namesData bool
	namesData *Mdl_NameStrings
	_f_rootNode bool
	rootNode *Mdl_Node
}
func NewMdl() *Mdl {
	return &Mdl{
	}
}

func (this Mdl) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1 := NewMdl_FileHeader()
	err = tmp1.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.FileHeader = tmp1
	tmp2 := NewMdl_ModelHeader()
	err = tmp2.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.ModelHeader = tmp2
	return err
}

/**
 * Animation header offsets (relative to data_start)
 */
func (this *Mdl) AnimationOffsets() (v []uint32, err error) {
	if (this._f_animationOffsets) {
		return this.animationOffsets, nil
	}
	this._f_animationOffsets = true
	if (this.ModelHeader.AnimationCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		tmp3, err := this.DataStart()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(tmp3 + this.ModelHeader.OffsetToAnimations), io.SeekStart)
		if err != nil {
			return nil, err
		}
		for i := 0; i < int(this.ModelHeader.AnimationCount); i++ {
			_ = i
			tmp4, err := this._io.ReadU4le()
			if err != nil {
				return nil, err
			}
			this.animationOffsets = append(this.animationOffsets, tmp4)
		}
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.animationOffsets, nil
}

/**
 * Animation headers (resolved via animation_offsets)
 */
func (this *Mdl) Animations() (v []*Mdl_AnimationHeader, err error) {
	if (this._f_animations) {
		return this.animations, nil
	}
	this._f_animations = true
	if (this.ModelHeader.AnimationCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		tmp5, err := this.DataStart()
		if err != nil {
			return nil, err
		}
		tmp6, err := this.AnimationOffsets()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(tmp5 + tmp6[i]), io.SeekStart)
		if err != nil {
			return nil, err
		}
		for i := 0; i < int(this.ModelHeader.AnimationCount); i++ {
			_ = i
			tmp7 := NewMdl_AnimationHeader()
			err = tmp7.Read(this._io, this, this._root)
			if err != nil {
				return nil, err
			}
			this.animations = append(this.animations, tmp7)
		}
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.animations, nil
}

/**
 * MDL "data start" offset. Most offsets in this file are relative to the start of the MDL data
 * section, which begins immediately after the 12-byte file header.
 */
func (this *Mdl) DataStart() (v int8, err error) {
	if (this._f_dataStart) {
		return this.dataStart, nil
	}
	this._f_dataStart = true
	this.dataStart = int8(12)
	return this.dataStart, nil
}

/**
 * Name string offsets (relative to data_start)
 */
func (this *Mdl) NameOffsets() (v []uint32, err error) {
	if (this._f_nameOffsets) {
		return this.nameOffsets, nil
	}
	this._f_nameOffsets = true
	if (this.ModelHeader.NameOffsetsCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		tmp8, err := this.DataStart()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(tmp8 + this.ModelHeader.OffsetToNameOffsets), io.SeekStart)
		if err != nil {
			return nil, err
		}
		for i := 0; i < int(this.ModelHeader.NameOffsetsCount); i++ {
			_ = i
			tmp9, err := this._io.ReadU4le()
			if err != nil {
				return nil, err
			}
			this.nameOffsets = append(this.nameOffsets, tmp9)
		}
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.nameOffsets, nil
}

/**
 * Name string blob (substream). This follows the name offset array and continues up to the animation offset array.
 * Parsed as null-terminated ASCII strings in `name_strings`.
 */
func (this *Mdl) NamesData() (v *Mdl_NameStrings, err error) {
	if (this._f_namesData) {
		return this.namesData, nil
	}
	this._f_namesData = true
	if (this.ModelHeader.NameOffsetsCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		tmp10, err := this.DataStart()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64((tmp10 + this.ModelHeader.OffsetToNameOffsets) + 4 * this.ModelHeader.NameOffsetsCount), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp11, err := this.DataStart()
		if err != nil {
			return nil, err
		}
		tmp12, err := this.DataStart()
		if err != nil {
			return nil, err
		}
		tmp13, err := this._io.ReadBytes(int((tmp11 + this.ModelHeader.OffsetToAnimations) - ((tmp12 + this.ModelHeader.OffsetToNameOffsets) + 4 * this.ModelHeader.NameOffsetsCount)))
		if err != nil {
			return nil, err
		}
		tmp13 = tmp13
		this._raw_namesData = tmp13
		_io__raw_namesData := kaitai.NewStream(bytes.NewReader(this._raw_namesData))
		tmp14 := NewMdl_NameStrings()
		err = tmp14.Read(_io__raw_namesData, this, this._root)
		if err != nil {
			return nil, err
		}
		this.namesData = tmp14
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.namesData, nil
}
func (this *Mdl) RootNode() (v *Mdl_Node, err error) {
	if (this._f_rootNode) {
		return this.rootNode, nil
	}
	this._f_rootNode = true
	if (this.ModelHeader.Geometry.RootNodeOffset > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		tmp15, err := this.DataStart()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(tmp15 + this.ModelHeader.Geometry.RootNodeOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp16 := NewMdl_Node()
		err = tmp16.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.rootNode = tmp16
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.rootNode, nil
}

/**
 * AABB (Axis-Aligned Bounding Box) header (336 bytes KOTOR 1, 344 bytes KOTOR 2) - extends trimesh_header
 */
type Mdl_AabbHeader struct {
	TrimeshBase *Mdl_TrimeshHeader
	Unknown uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl_Node
}
func NewMdl_AabbHeader() *Mdl_AabbHeader {
	return &Mdl_AabbHeader{
	}
}

func (this Mdl_AabbHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_AabbHeader) Read(io *kaitai.Stream, parent *Mdl_Node, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp17 := NewMdl_TrimeshHeader()
	err = tmp17.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.TrimeshBase = tmp17
	tmp18, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown = uint32(tmp18)
	return err
}

/**
 * Standard trimesh header
 */

/**
 * Purpose unknown
 */

/**
 * Animation event (36 bytes)
 */
type Mdl_AnimationEvent struct {
	ActivationTime float32
	EventName string
	_io *kaitai.Stream
	_root *Mdl
	_parent kaitai.Struct
}
func NewMdl_AnimationEvent() *Mdl_AnimationEvent {
	return &Mdl_AnimationEvent{
	}
}

func (this Mdl_AnimationEvent) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_AnimationEvent) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp19, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.ActivationTime = float32(tmp19)
	tmp20, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp20 = kaitai.BytesTerminate(tmp20, 0, false)
	this.EventName = string(tmp20)
	return err
}

/**
 * Time in seconds when event triggers during animation playback
 */

/**
 * Name of event (null-terminated string, e.g., "detonate")
 */

/**
 * Animation header (136 bytes = 80 byte geometry header + 56 byte animation header)
 */
type Mdl_AnimationHeader struct {
	GeoHeader *Mdl_GeometryHeader
	AnimationLength float32
	TransitionTime float32
	AnimationRoot string
	EventArrayOffset uint32
	EventCount uint32
	EventCountDuplicate uint32
	Unknown uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl
}
func NewMdl_AnimationHeader() *Mdl_AnimationHeader {
	return &Mdl_AnimationHeader{
	}
}

func (this Mdl_AnimationHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_AnimationHeader) Read(io *kaitai.Stream, parent *Mdl, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp21 := NewMdl_GeometryHeader()
	err = tmp21.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.GeoHeader = tmp21
	tmp22, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.AnimationLength = float32(tmp22)
	tmp23, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.TransitionTime = float32(tmp23)
	tmp24, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp24 = kaitai.BytesTerminate(tmp24, 0, false)
	this.AnimationRoot = string(tmp24)
	tmp25, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.EventArrayOffset = uint32(tmp25)
	tmp26, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.EventCount = uint32(tmp26)
	tmp27, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.EventCountDuplicate = uint32(tmp27)
	tmp28, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown = uint32(tmp28)
	return err
}

/**
 * Standard 80-byte geometry header (geometry_type = 0x01 for animation)
 */

/**
 * Duration of animation in seconds
 */

/**
 * Transition/blend time to this animation in seconds
 */

/**
 * Root node name for animation (null-terminated string)
 */

/**
 * Offset to animation events array
 */

/**
 * Number of animation events
 */

/**
 * Duplicate value of event count
 */

/**
 * Purpose unknown
 */

/**
 * Animmesh header (388 bytes KOTOR 1, 396 bytes KOTOR 2) - extends trimesh_header
 */
type Mdl_AnimmeshHeader struct {
	TrimeshBase *Mdl_TrimeshHeader
	Unknown float32
	UnknownArray *Mdl_ArrayDefinition
	UnknownFloats []float32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl_Node
}
func NewMdl_AnimmeshHeader() *Mdl_AnimmeshHeader {
	return &Mdl_AnimmeshHeader{
	}
}

func (this Mdl_AnimmeshHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_AnimmeshHeader) Read(io *kaitai.Stream, parent *Mdl_Node, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp29 := NewMdl_TrimeshHeader()
	err = tmp29.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.TrimeshBase = tmp29
	tmp30, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Unknown = float32(tmp30)
	tmp31 := NewMdl_ArrayDefinition()
	err = tmp31.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.UnknownArray = tmp31
	for i := 0; i < int(9); i++ {
		_ = i
		tmp32, err := this._io.ReadF4le()
		if err != nil {
			return err
		}
		this.UnknownFloats = append(this.UnknownFloats, tmp32)
	}
	return err
}

/**
 * Standard trimesh header
 */

/**
 * Purpose unknown
 */

/**
 * Unknown array definition
 */

/**
 * Unknown float values
 */

/**
 * Array definition structure (offset, count, count duplicate)
 */
type Mdl_ArrayDefinition struct {
	Offset int32
	Count uint32
	CountDuplicate uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent kaitai.Struct
}
func NewMdl_ArrayDefinition() *Mdl_ArrayDefinition {
	return &Mdl_ArrayDefinition{
	}
}

func (this Mdl_ArrayDefinition) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_ArrayDefinition) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp33, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.Offset = int32(tmp33)
	tmp34, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Count = uint32(tmp34)
	tmp35, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.CountDuplicate = uint32(tmp35)
	return err
}

/**
 * Offset to array (relative to MDL data start, offset 12)
 */

/**
 * Number of used entries
 */

/**
 * Duplicate of count (allocated entries)
 */

/**
 * Controller structure (16 bytes) - defines animation data for a node property over time
 */
type Mdl_Controller struct {
	Type uint32
	Unknown uint16
	RowCount uint16
	TimeIndex uint16
	DataIndex uint16
	ColumnCount uint8
	Padding []uint8
	_io *kaitai.Stream
	_root *Mdl
	_parent kaitai.Struct
	_f_usesBezier bool
	usesBezier bool
}
func NewMdl_Controller() *Mdl_Controller {
	return &Mdl_Controller{
	}
}

func (this Mdl_Controller) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_Controller) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp36, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Type = uint32(tmp36)
	tmp37, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Unknown = uint16(tmp37)
	tmp38, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.RowCount = uint16(tmp38)
	tmp39, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.TimeIndex = uint16(tmp39)
	tmp40, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.DataIndex = uint16(tmp40)
	tmp41, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.ColumnCount = tmp41
	for i := 0; i < int(3); i++ {
		_ = i
		tmp42, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Padding = append(this.Padding, tmp42)
	}
	return err
}

/**
 * True if controller uses Bezier interpolation
 */
func (this *Mdl_Controller) UsesBezier() (v bool, err error) {
	if (this._f_usesBezier) {
		return this.usesBezier, nil
	}
	this._f_usesBezier = true
	this.usesBezier = bool(this.ColumnCount & 16 != 0)
	return this.usesBezier, nil
}

/**
 * Controller type identifier. Controllers define animation data for node properties over time.
 * 
 * Common Node Controllers (used by all node types):
 * - 8: Position (3 floats: X, Y, Z translation)
 * - 20: Orientation (4 floats: quaternion W, X, Y, Z rotation)
 * - 36: Scale (3 floats: X, Y, Z scale factors)
 * 
 * Light Controllers (specific to light nodes):
 * - 76: Color (light color, 3 floats: R, G, B)
 * - 88: Radius (light radius, 1 float)
 * - 96: Shadow Radius (shadow casting radius, 1 float)
 * - 100: Vertical Displacement (vertical offset, 1 float)
 * - 140: Multiplier (light intensity multiplier, 1 float)
 * 
 * Emitter Controllers (specific to emitter nodes):
 * - 80: Alpha End (final alpha value, 1 float)
 * - 84: Alpha Start (initial alpha value, 1 float)
 * - 88: Birth Rate (particle spawn rate, 1 float)
 * - 92: Bounce Coefficient (particle bounce factor, 1 float)
 * - 96: Combine Time (particle combination timing, 1 float)
 * - 100: Drag (particle drag/resistance, 1 float)
 * - 104: FPS (frames per second, 1 float)
 * - 108: Frame End (ending frame number, 1 float)
 * - 112: Frame Start (starting frame number, 1 float)
 * - 116: Gravity (gravity force, 1 float)
 * - 120: Life Expectancy (particle lifetime, 1 float)
 * - 124: Mass (particle mass, 1 float)
 * - 128: P2P Bezier 2 (point-to-point bezier control point 2, varies)
 * - 132: P2P Bezier 3 (point-to-point bezier control point 3, varies)
 * - 136: Particle Rotation (particle rotation speed/angle, 1 float)
 * - 140: Random Velocity (random velocity component, 3 floats: X, Y, Z)
 * - 144: Size Start (initial particle size, 1 float)
 * - 148: Size End (final particle size, 1 float)
 * - 152: Size Start Y (initial particle size Y component, 1 float)
 * - 156: Size End Y (final particle size Y component, 1 float)
 * - 160: Spread (particle spread angle, 1 float)
 * - 164: Threshold (threshold value, 1 float)
 * - 168: Velocity (particle velocity, 3 floats: X, Y, Z)
 * - 172: X Size (particle X dimension size, 1 float)
 * - 176: Y Size (particle Y dimension size, 1 float)
 * - 180: Blur Length (motion blur length, 1 float)
 * - 184: Lightning Delay (lightning effect delay, 1 float)
 * - 188: Lightning Radius (lightning effect radius, 1 float)
 * - 192: Lightning Scale (lightning effect scale factor, 1 float)
 * - 196: Lightning Subdivide (lightning subdivision count, 1 float)
 * - 200: Lightning Zig Zag (lightning zigzag pattern, 1 float)
 * - 216: Alpha Mid (mid-point alpha value, 1 float)
 * - 220: Percent Start (starting percentage, 1 float)
 * - 224: Percent Mid (mid-point percentage, 1 float)
 * - 228: Percent End (ending percentage, 1 float)
 * - 232: Size Mid (mid-point particle size, 1 float)
 * - 236: Size Mid Y (mid-point particle size Y component, 1 float)
 * - 240: Random Birth Rate (randomized particle spawn rate, 1 float)
 * - 252: Target Size (target particle size, 1 float)
 * - 256: Number of Control Points (control point count, 1 float)
 * - 260: Control Point Radius (control point radius, 1 float)
 * - 264: Control Point Delay (control point delay timing, 1 float)
 * - 268: Tangent Spread (tangent spread angle, 1 float)
 * - 272: Tangent Length (tangent vector length, 1 float)
 * - 284: Color Mid (mid-point color, 3 floats: R, G, B)
 * - 380: Color End (final color, 3 floats: R, G, B)
 * - 392: Color Start (initial color, 3 floats: R, G, B)
 * - 502: Emitter Detonate (detonation trigger, 1 float)
 * 
 * Mesh Controllers (used by all mesh node types: trimesh, skinmesh, animmesh, danglymesh, AABB, lightsaber):
 * - 100: SelfIllumColor (self-illumination color, 3 floats: R, G, B)
 * - 128: Alpha (transparency/opacity, 1 float)
 * 
 * Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/MDL-MDX-File-Format.md - Additional Controller Types section
 * Reference: https://github.com/OldRepublicDevs/PyKotor/blob/master/vendor/MDLOps/MDLOpsM.pm:342-407 - Controller type definitions
 * Reference: https://github.com/xoreos/xoreos-docs/blob/master/specs/torlack/binmdl.html - Comprehensive controller list
 */

/**
 * Purpose unknown, typically 0xFFFF
 */

/**
 * Number of keyframe rows (timepoints) for this controller
 */

/**
 * Index into controller data array where time values begin
 */

/**
 * Index into controller data array where property values begin
 */

/**
 * Number of float values per keyframe (e.g., 3 for position XYZ, 4 for quaternion WXYZ)
 * If bit 4 (0x10) is set, controller uses Bezier interpolation and stores 3× data per keyframe
 */

/**
 * Padding bytes for 16-byte alignment
 */

/**
 * Danglymesh header (360 bytes KOTOR 1, 368 bytes KOTOR 2) - extends trimesh_header
 */
type Mdl_DanglymeshHeader struct {
	TrimeshBase *Mdl_TrimeshHeader
	ConstraintsOffset uint32
	ConstraintsCount uint32
	ConstraintsCountDuplicate uint32
	Displacement float32
	Tightness float32
	Period float32
	Unknown uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl_Node
}
func NewMdl_DanglymeshHeader() *Mdl_DanglymeshHeader {
	return &Mdl_DanglymeshHeader{
	}
}

func (this Mdl_DanglymeshHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_DanglymeshHeader) Read(io *kaitai.Stream, parent *Mdl_Node, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp43 := NewMdl_TrimeshHeader()
	err = tmp43.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.TrimeshBase = tmp43
	tmp44, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ConstraintsOffset = uint32(tmp44)
	tmp45, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ConstraintsCount = uint32(tmp45)
	tmp46, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ConstraintsCountDuplicate = uint32(tmp46)
	tmp47, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Displacement = float32(tmp47)
	tmp48, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Tightness = float32(tmp48)
	tmp49, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Period = float32(tmp49)
	tmp50, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown = uint32(tmp50)
	return err
}

/**
 * Standard trimesh header
 */

/**
 * Offset to vertex constraint values array
 */

/**
 * Number of vertex constraints (matches vertex count)
 */

/**
 * Duplicate of constraints count
 */

/**
 * Maximum displacement distance for physics simulation
 */

/**
 * Tightness/stiffness of spring simulation (0.0-1.0)
 */

/**
 * Oscillation period in seconds
 */

/**
 * Purpose unknown
 */

/**
 * Emitter header (224 bytes)
 */
type Mdl_EmitterHeader struct {
	DeadSpace float32
	BlastRadius float32
	BlastLength float32
	BranchCount uint32
	ControlPointSmoothing float32
	XGrid uint32
	YGrid uint32
	PaddingUnknown uint32
	UpdateScript string
	RenderScript string
	BlendScript string
	TextureName string
	ChunkName string
	TwoSidedTexture uint32
	Loop uint32
	RenderOrder uint16
	FrameBlending uint8
	DepthTextureName string
	Padding uint8
	Flags uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl_Node
}
func NewMdl_EmitterHeader() *Mdl_EmitterHeader {
	return &Mdl_EmitterHeader{
	}
}

func (this Mdl_EmitterHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_EmitterHeader) Read(io *kaitai.Stream, parent *Mdl_Node, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp51, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.DeadSpace = float32(tmp51)
	tmp52, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.BlastRadius = float32(tmp52)
	tmp53, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.BlastLength = float32(tmp53)
	tmp54, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.BranchCount = uint32(tmp54)
	tmp55, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.ControlPointSmoothing = float32(tmp55)
	tmp56, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.XGrid = uint32(tmp56)
	tmp57, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.YGrid = uint32(tmp57)
	tmp58, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.PaddingUnknown = uint32(tmp58)
	tmp59, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp59 = kaitai.BytesTerminate(tmp59, 0, false)
	this.UpdateScript = string(tmp59)
	tmp60, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp60 = kaitai.BytesTerminate(tmp60, 0, false)
	this.RenderScript = string(tmp60)
	tmp61, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp61 = kaitai.BytesTerminate(tmp61, 0, false)
	this.BlendScript = string(tmp61)
	tmp62, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp62 = kaitai.BytesTerminate(tmp62, 0, false)
	this.TextureName = string(tmp62)
	tmp63, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp63 = kaitai.BytesTerminate(tmp63, 0, false)
	this.ChunkName = string(tmp63)
	tmp64, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TwoSidedTexture = uint32(tmp64)
	tmp65, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Loop = uint32(tmp65)
	tmp66, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.RenderOrder = uint16(tmp66)
	tmp67, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.FrameBlending = tmp67
	tmp68, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp68 = kaitai.BytesTerminate(tmp68, 0, false)
	this.DepthTextureName = string(tmp68)
	tmp69, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Padding = tmp69
	tmp70, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Flags = uint32(tmp70)
	return err
}

/**
 * Minimum distance from emitter before particles become visible
 */

/**
 * Radius of explosive/blast particle effects
 */

/**
 * Length/duration of blast effects
 */

/**
 * Number of branching paths for particle trails
 */

/**
 * Smoothing factor for particle path control points
 */

/**
 * Grid subdivisions along X axis for particle spawning
 */

/**
 * Grid subdivisions along Y axis for particle spawning
 */

/**
 * Purpose unknown or padding
 */

/**
 * Update behavior script name (e.g., "single", "fountain")
 */

/**
 * Render mode script name (e.g., "normal", "billboard_to_local_z")
 */

/**
 * Blend mode script name (e.g., "normal", "lighten")
 */

/**
 * Particle texture name (null-terminated string)
 */

/**
 * Associated model chunk name (null-terminated string)
 */

/**
 * 1 if texture should render two-sided, 0 for single-sided
 */

/**
 * 1 if particle system loops, 0 for single playback
 */

/**
 * Rendering priority/order for particle sorting
 */

/**
 * 1 if frame blending enabled, 0 otherwise
 */

/**
 * Depth/softparticle texture name (null-terminated string)
 */

/**
 * Padding byte for alignment
 */

/**
 * Emitter behavior flags bitmask (P2P, bounce, inherit, etc.)
 */

/**
 * MDL file header (12 bytes)
 */
type Mdl_FileHeader struct {
	Unused uint32
	MdlSize uint32
	MdxSize uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl
}
func NewMdl_FileHeader() *Mdl_FileHeader {
	return &Mdl_FileHeader{
	}
}

func (this Mdl_FileHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_FileHeader) Read(io *kaitai.Stream, parent *Mdl, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp71, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unused = uint32(tmp71)
	tmp72, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MdlSize = uint32(tmp72)
	tmp73, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MdxSize = uint32(tmp73)
	return err
}

/**
 * Always 0
 */

/**
 * Size of MDL file in bytes
 */

/**
 * Size of MDX file in bytes
 */

/**
 * Geometry header (80 bytes) - Located at offset 12
 */
type Mdl_GeometryHeader struct {
	FunctionPointer0 uint32
	FunctionPointer1 uint32
	ModelName string
	RootNodeOffset uint32
	NodeCount uint32
	UnknownArray1 *Mdl_ArrayDefinition
	UnknownArray2 *Mdl_ArrayDefinition
	ReferenceCount uint32
	GeometryType uint8
	Padding []uint8
	_io *kaitai.Stream
	_root *Mdl
	_parent kaitai.Struct
	_f_isKotor2 bool
	isKotor2 bool
}
func NewMdl_GeometryHeader() *Mdl_GeometryHeader {
	return &Mdl_GeometryHeader{
	}
}

func (this Mdl_GeometryHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_GeometryHeader) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp74, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FunctionPointer0 = uint32(tmp74)
	tmp75, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FunctionPointer1 = uint32(tmp75)
	tmp76, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp76 = kaitai.BytesTerminate(tmp76, 0, false)
	this.ModelName = string(tmp76)
	tmp77, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.RootNodeOffset = uint32(tmp77)
	tmp78, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NodeCount = uint32(tmp78)
	tmp79 := NewMdl_ArrayDefinition()
	err = tmp79.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.UnknownArray1 = tmp79
	tmp80 := NewMdl_ArrayDefinition()
	err = tmp80.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.UnknownArray2 = tmp80
	tmp81, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ReferenceCount = uint32(tmp81)
	tmp82, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.GeometryType = tmp82
	for i := 0; i < int(3); i++ {
		_ = i
		tmp83, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Padding = append(this.Padding, tmp83)
	}
	return err
}

/**
 * True if this is a KOTOR 2 model
 */
func (this *Mdl_GeometryHeader) IsKotor2() (v bool, err error) {
	if (this._f_isKotor2) {
		return this.isKotor2, nil
	}
	this._f_isKotor2 = true
	this.isKotor2 = bool( ((this.FunctionPointer0 == 4285200) || (this.FunctionPointer0 == 4285872)) )
	return this.isKotor2, nil
}

/**
 * Game engine version identifier:
 * - KOTOR 1 PC: 4273776 (0x413750)
 * - KOTOR 2 PC: 4285200 (0x416610)
 * - KOTOR 1 Xbox: 4254992 (0x40EE90)
 * - KOTOR 2 Xbox: 4285872 (0x416950)
 */

/**
 * Function pointer to ASCII model parser
 */

/**
 * Model name (null-terminated string, max 32 bytes)
 */

/**
 * Offset to root node structure (relative to MDL data start, offset 12)
 */

/**
 * Total number of nodes in model hierarchy
 */

/**
 * Unknown array definition (offset, count, count duplicate)
 */

/**
 * Unknown array definition (offset, count, count duplicate)
 */

/**
 * Reference count (initialized to 0, incremented when model is referenced)
 */

/**
 * Geometry type:
 * - 0x01: Basic geometry header (not in models)
 * - 0x02: Model geometry header
 * - 0x05: Animation geometry header
 * If bit 7 (0x80) is set, model is compiled binary with absolute addresses
 */

/**
 * Padding bytes for alignment
 */

/**
 * Light header (92 bytes)
 */
type Mdl_LightHeader struct {
	Unknown []float32
	FlareSizesOffset uint32
	FlareSizesCount uint32
	FlareSizesCountDuplicate uint32
	FlarePositionsOffset uint32
	FlarePositionsCount uint32
	FlarePositionsCountDuplicate uint32
	FlareColorShiftsOffset uint32
	FlareColorShiftsCount uint32
	FlareColorShiftsCountDuplicate uint32
	FlareTextureNamesOffset uint32
	FlareTextureNamesCount uint32
	FlareTextureNamesCountDuplicate uint32
	FlareRadius float32
	LightPriority uint32
	AmbientOnly uint32
	DynamicType uint32
	AffectDynamic uint32
	Shadow uint32
	Flare uint32
	FadingLight uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl_Node
}
func NewMdl_LightHeader() *Mdl_LightHeader {
	return &Mdl_LightHeader{
	}
}

func (this Mdl_LightHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_LightHeader) Read(io *kaitai.Stream, parent *Mdl_Node, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(4); i++ {
		_ = i
		tmp84, err := this._io.ReadF4le()
		if err != nil {
			return err
		}
		this.Unknown = append(this.Unknown, tmp84)
	}
	tmp85, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlareSizesOffset = uint32(tmp85)
	tmp86, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlareSizesCount = uint32(tmp86)
	tmp87, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlareSizesCountDuplicate = uint32(tmp87)
	tmp88, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlarePositionsOffset = uint32(tmp88)
	tmp89, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlarePositionsCount = uint32(tmp89)
	tmp90, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlarePositionsCountDuplicate = uint32(tmp90)
	tmp91, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlareColorShiftsOffset = uint32(tmp91)
	tmp92, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlareColorShiftsCount = uint32(tmp92)
	tmp93, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlareColorShiftsCountDuplicate = uint32(tmp93)
	tmp94, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlareTextureNamesOffset = uint32(tmp94)
	tmp95, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlareTextureNamesCount = uint32(tmp95)
	tmp96, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FlareTextureNamesCountDuplicate = uint32(tmp96)
	tmp97, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.FlareRadius = float32(tmp97)
	tmp98, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LightPriority = uint32(tmp98)
	tmp99, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.AmbientOnly = uint32(tmp99)
	tmp100, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.DynamicType = uint32(tmp100)
	tmp101, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.AffectDynamic = uint32(tmp101)
	tmp102, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Shadow = uint32(tmp102)
	tmp103, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Flare = uint32(tmp103)
	tmp104, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FadingLight = uint32(tmp104)
	return err
}

/**
 * Purpose unknown, possibly padding or reserved values
 */

/**
 * Offset to flare sizes array (floats)
 */

/**
 * Number of flare size entries
 */

/**
 * Duplicate of flare sizes count
 */

/**
 * Offset to flare positions array (floats, 0.0-1.0 along light ray)
 */

/**
 * Number of flare position entries
 */

/**
 * Duplicate of flare positions count
 */

/**
 * Offset to flare color shift array (RGB floats)
 */

/**
 * Number of flare color shift entries
 */

/**
 * Duplicate of flare color shifts count
 */

/**
 * Offset to flare texture name string offsets array
 */

/**
 * Number of flare texture names
 */

/**
 * Duplicate of flare texture names count
 */

/**
 * Radius of flare effect
 */

/**
 * Rendering priority for light culling/sorting
 */

/**
 * 1 if light only affects ambient, 0 for full lighting
 */

/**
 * Type of dynamic lighting behavior
 */

/**
 * 1 if light affects dynamic objects, 0 otherwise
 */

/**
 * 1 if light casts shadows, 0 otherwise
 */

/**
 * 1 if lens flare effect enabled, 0 otherwise
 */

/**
 * 1 if light intensity fades with distance, 0 otherwise
 */

/**
 * Lightsaber header (352 bytes KOTOR 1, 360 bytes KOTOR 2) - extends trimesh_header
 */
type Mdl_LightsaberHeader struct {
	TrimeshBase *Mdl_TrimeshHeader
	VerticesOffset uint32
	TexcoordsOffset uint32
	NormalsOffset uint32
	Unknown1 uint32
	Unknown2 uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl_Node
}
func NewMdl_LightsaberHeader() *Mdl_LightsaberHeader {
	return &Mdl_LightsaberHeader{
	}
}

func (this Mdl_LightsaberHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_LightsaberHeader) Read(io *kaitai.Stream, parent *Mdl_Node, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp105 := NewMdl_TrimeshHeader()
	err = tmp105.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.TrimeshBase = tmp105
	tmp106, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.VerticesOffset = uint32(tmp106)
	tmp107, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TexcoordsOffset = uint32(tmp107)
	tmp108, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NormalsOffset = uint32(tmp108)
	tmp109, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown1 = uint32(tmp109)
	tmp110, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown2 = uint32(tmp110)
	return err
}

/**
 * Standard trimesh header
 */

/**
 * Offset to vertex position array in MDL file (3 floats × 8 vertices × 20 pieces)
 */

/**
 * Offset to texture coordinates array in MDL file (2 floats × 8 vertices × 20)
 */

/**
 * Offset to vertex normals array in MDL file (3 floats × 8 vertices × 20)
 */

/**
 * Purpose unknown
 */

/**
 * Purpose unknown
 */

/**
 * Model header (196 bytes) starting at offset 12 (data_start).
 * This matches MDLOps / PyKotor's _ModelHeader layout: a geometry header followed by
 * model-wide metadata, offsets, and counts.
 */
type Mdl_ModelHeader struct {
	Geometry *Mdl_GeometryHeader
	ModelType uint8
	Unknown0 uint8
	Padding0 uint8
	Fog uint8
	Unknown1 uint32
	OffsetToAnimations uint32
	AnimationCount uint32
	AnimationCount2 uint32
	Unknown2 uint32
	BoundingBoxMin *Mdl_Vec3f
	BoundingBoxMax *Mdl_Vec3f
	Radius float32
	AnimationScale float32
	SupermodelName string
	OffsetToSuperRoot uint32
	Unknown3 uint32
	MdxDataSize uint32
	MdxDataOffset uint32
	OffsetToNameOffsets uint32
	NameOffsetsCount uint32
	NameOffsetsCount2 uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl
}
func NewMdl_ModelHeader() *Mdl_ModelHeader {
	return &Mdl_ModelHeader{
	}
}

func (this Mdl_ModelHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_ModelHeader) Read(io *kaitai.Stream, parent *Mdl, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp111 := NewMdl_GeometryHeader()
	err = tmp111.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Geometry = tmp111
	tmp112, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.ModelType = tmp112
	tmp113, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Unknown0 = tmp113
	tmp114, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Padding0 = tmp114
	tmp115, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Fog = tmp115
	tmp116, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown1 = uint32(tmp116)
	tmp117, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.OffsetToAnimations = uint32(tmp117)
	tmp118, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.AnimationCount = uint32(tmp118)
	tmp119, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.AnimationCount2 = uint32(tmp119)
	tmp120, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown2 = uint32(tmp120)
	tmp121 := NewMdl_Vec3f()
	err = tmp121.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.BoundingBoxMin = tmp121
	tmp122 := NewMdl_Vec3f()
	err = tmp122.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.BoundingBoxMax = tmp122
	tmp123, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Radius = float32(tmp123)
	tmp124, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.AnimationScale = float32(tmp124)
	tmp125, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp125 = kaitai.BytesTerminate(tmp125, 0, false)
	this.SupermodelName = string(tmp125)
	tmp126, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.OffsetToSuperRoot = uint32(tmp126)
	tmp127, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown3 = uint32(tmp127)
	tmp128, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MdxDataSize = uint32(tmp128)
	tmp129, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MdxDataOffset = uint32(tmp129)
	tmp130, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.OffsetToNameOffsets = uint32(tmp130)
	tmp131, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NameOffsetsCount = uint32(tmp131)
	tmp132, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NameOffsetsCount2 = uint32(tmp132)
	return err
}

/**
 * Geometry header (80 bytes)
 */

/**
 * Model classification byte
 */

/**
 * TODO: VERIFY - unknown field (MDLOps / PyKotor preserve)
 */

/**
 * Padding byte
 */

/**
 * Fog interaction (1 = affected, 0 = ignore fog)
 */

/**
 * TODO: VERIFY - unknown field (MDLOps / PyKotor preserve)
 */

/**
 * Offset to animation offset array (relative to data_start)
 */

/**
 * Number of animations
 */

/**
 * Duplicate animation count / allocated count
 */

/**
 * TODO: VERIFY - unknown field (MDLOps / PyKotor preserve)
 */

/**
 * Minimum coordinates of bounding box (X, Y, Z)
 */

/**
 * Maximum coordinates of bounding box (X, Y, Z)
 */

/**
 * Radius of model's bounding sphere
 */

/**
 * Scale factor for animations (typically 1.0)
 */

/**
 * Name of supermodel (null-terminated string, "null" if empty)
 */

/**
 * TODO: VERIFY - offset to super-root node (relative to data_start)
 */

/**
 * TODO: VERIFY - unknown field after offset_to_super_root (MDLOps / PyKotor preserve)
 */

/**
 * Size of MDX file data in bytes
 */

/**
 * Offset to MDX data (typically 0)
 */

/**
 * Offset to name offset array (relative to data_start)
 */

/**
 * Count of name offsets / partnames
 */

/**
 * Duplicate name offsets count / allocated count
 */

/**
 * Array of null-terminated name strings
 */
type Mdl_NameStrings struct {
	Strings []string
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl
}
func NewMdl_NameStrings() *Mdl_NameStrings {
	return &Mdl_NameStrings{
	}
}

func (this Mdl_NameStrings) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_NameStrings) Read(io *kaitai.Stream, parent *Mdl, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp133, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp133 {
			break
		}
		tmp134, err := this._io.ReadBytesTerm(0, false, true, true)
		if err != nil {
			return err
		}
		this.Strings = append(this.Strings, string(tmp134))
	}
	return err
}

/**
 * Node structure - starts with 80-byte header, followed by type-specific sub-header
 */
type Mdl_Node struct {
	Header *Mdl_NodeHeader
	LightSubHeader *Mdl_LightHeader
	EmitterSubHeader *Mdl_EmitterHeader
	ReferenceSubHeader *Mdl_ReferenceHeader
	TrimeshSubHeader *Mdl_TrimeshHeader
	SkinmeshSubHeader *Mdl_SkinmeshHeader
	AnimmeshSubHeader *Mdl_AnimmeshHeader
	DanglymeshSubHeader *Mdl_DanglymeshHeader
	AabbSubHeader *Mdl_AabbHeader
	LightsaberSubHeader *Mdl_LightsaberHeader
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl
}
func NewMdl_Node() *Mdl_Node {
	return &Mdl_Node{
	}
}

func (this Mdl_Node) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_Node) Read(io *kaitai.Stream, parent *Mdl, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp135 := NewMdl_NodeHeader()
	err = tmp135.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Header = tmp135
	if (this.Header.NodeType == 3) {
		tmp136 := NewMdl_LightHeader()
		err = tmp136.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.LightSubHeader = tmp136
	}
	if (this.Header.NodeType == 5) {
		tmp137 := NewMdl_EmitterHeader()
		err = tmp137.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.EmitterSubHeader = tmp137
	}
	if (this.Header.NodeType == 17) {
		tmp138 := NewMdl_ReferenceHeader()
		err = tmp138.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.ReferenceSubHeader = tmp138
	}
	if (this.Header.NodeType == 33) {
		tmp139 := NewMdl_TrimeshHeader()
		err = tmp139.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.TrimeshSubHeader = tmp139
	}
	if (this.Header.NodeType == 97) {
		tmp140 := NewMdl_SkinmeshHeader()
		err = tmp140.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.SkinmeshSubHeader = tmp140
	}
	if (this.Header.NodeType == 161) {
		tmp141 := NewMdl_AnimmeshHeader()
		err = tmp141.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.AnimmeshSubHeader = tmp141
	}
	if (this.Header.NodeType == 289) {
		tmp142 := NewMdl_DanglymeshHeader()
		err = tmp142.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.DanglymeshSubHeader = tmp142
	}
	if (this.Header.NodeType == 545) {
		tmp143 := NewMdl_AabbHeader()
		err = tmp143.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.AabbSubHeader = tmp143
	}
	if (this.Header.NodeType == 2081) {
		tmp144 := NewMdl_LightsaberHeader()
		err = tmp144.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.LightsaberSubHeader = tmp144
	}
	return err
}

/**
 * Node header (80 bytes) - present in all node types
 */
type Mdl_NodeHeader struct {
	NodeType uint16
	NodeIndex uint16
	NodeNameIndex uint16
	Padding uint16
	RootNodeOffset uint32
	ParentNodeOffset uint32
	Position *Mdl_Vec3f
	Orientation *Mdl_Quaternion
	ChildArrayOffset uint32
	ChildCount uint32
	ChildCountDuplicate uint32
	ControllerArrayOffset uint32
	ControllerCount uint32
	ControllerCountDuplicate uint32
	ControllerDataOffset uint32
	ControllerDataCount uint32
	ControllerDataCountDuplicate uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl_Node
	_f_hasAabb bool
	hasAabb bool
	_f_hasAnim bool
	hasAnim bool
	_f_hasDangly bool
	hasDangly bool
	_f_hasEmitter bool
	hasEmitter bool
	_f_hasLight bool
	hasLight bool
	_f_hasMesh bool
	hasMesh bool
	_f_hasReference bool
	hasReference bool
	_f_hasSaber bool
	hasSaber bool
	_f_hasSkin bool
	hasSkin bool
}
func NewMdl_NodeHeader() *Mdl_NodeHeader {
	return &Mdl_NodeHeader{
	}
}

func (this Mdl_NodeHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_NodeHeader) Read(io *kaitai.Stream, parent *Mdl_Node, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp145, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.NodeType = uint16(tmp145)
	tmp146, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.NodeIndex = uint16(tmp146)
	tmp147, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.NodeNameIndex = uint16(tmp147)
	tmp148, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Padding = uint16(tmp148)
	tmp149, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.RootNodeOffset = uint32(tmp149)
	tmp150, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ParentNodeOffset = uint32(tmp150)
	tmp151 := NewMdl_Vec3f()
	err = tmp151.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Position = tmp151
	tmp152 := NewMdl_Quaternion()
	err = tmp152.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Orientation = tmp152
	tmp153, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ChildArrayOffset = uint32(tmp153)
	tmp154, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ChildCount = uint32(tmp154)
	tmp155, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ChildCountDuplicate = uint32(tmp155)
	tmp156, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ControllerArrayOffset = uint32(tmp156)
	tmp157, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ControllerCount = uint32(tmp157)
	tmp158, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ControllerCountDuplicate = uint32(tmp158)
	tmp159, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ControllerDataOffset = uint32(tmp159)
	tmp160, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ControllerDataCount = uint32(tmp160)
	tmp161, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ControllerDataCountDuplicate = uint32(tmp161)
	return err
}
func (this *Mdl_NodeHeader) HasAabb() (v bool, err error) {
	if (this._f_hasAabb) {
		return this.hasAabb, nil
	}
	this._f_hasAabb = true
	this.hasAabb = bool(this.NodeType & 512 != 0)
	return this.hasAabb, nil
}
func (this *Mdl_NodeHeader) HasAnim() (v bool, err error) {
	if (this._f_hasAnim) {
		return this.hasAnim, nil
	}
	this._f_hasAnim = true
	this.hasAnim = bool(this.NodeType & 128 != 0)
	return this.hasAnim, nil
}
func (this *Mdl_NodeHeader) HasDangly() (v bool, err error) {
	if (this._f_hasDangly) {
		return this.hasDangly, nil
	}
	this._f_hasDangly = true
	this.hasDangly = bool(this.NodeType & 256 != 0)
	return this.hasDangly, nil
}
func (this *Mdl_NodeHeader) HasEmitter() (v bool, err error) {
	if (this._f_hasEmitter) {
		return this.hasEmitter, nil
	}
	this._f_hasEmitter = true
	this.hasEmitter = bool(this.NodeType & 4 != 0)
	return this.hasEmitter, nil
}
func (this *Mdl_NodeHeader) HasLight() (v bool, err error) {
	if (this._f_hasLight) {
		return this.hasLight, nil
	}
	this._f_hasLight = true
	this.hasLight = bool(this.NodeType & 2 != 0)
	return this.hasLight, nil
}
func (this *Mdl_NodeHeader) HasMesh() (v bool, err error) {
	if (this._f_hasMesh) {
		return this.hasMesh, nil
	}
	this._f_hasMesh = true
	this.hasMesh = bool(this.NodeType & 32 != 0)
	return this.hasMesh, nil
}
func (this *Mdl_NodeHeader) HasReference() (v bool, err error) {
	if (this._f_hasReference) {
		return this.hasReference, nil
	}
	this._f_hasReference = true
	this.hasReference = bool(this.NodeType & 16 != 0)
	return this.hasReference, nil
}
func (this *Mdl_NodeHeader) HasSaber() (v bool, err error) {
	if (this._f_hasSaber) {
		return this.hasSaber, nil
	}
	this._f_hasSaber = true
	this.hasSaber = bool(this.NodeType & 2048 != 0)
	return this.hasSaber, nil
}
func (this *Mdl_NodeHeader) HasSkin() (v bool, err error) {
	if (this._f_hasSkin) {
		return this.hasSkin, nil
	}
	this._f_hasSkin = true
	this.hasSkin = bool(this.NodeType & 64 != 0)
	return this.hasSkin, nil
}

/**
 * Bitmask indicating node features:
 * - 0x0001: NODE_HAS_HEADER
 * - 0x0002: NODE_HAS_LIGHT
 * - 0x0004: NODE_HAS_EMITTER
 * - 0x0008: NODE_HAS_CAMERA
 * - 0x0010: NODE_HAS_REFERENCE
 * - 0x0020: NODE_HAS_MESH
 * - 0x0040: NODE_HAS_SKIN
 * - 0x0080: NODE_HAS_ANIM
 * - 0x0100: NODE_HAS_DANGLY
 * - 0x0200: NODE_HAS_AABB
 * - 0x0800: NODE_HAS_SABER
 */

/**
 * Sequential index of this node in the model
 */

/**
 * Index into names array for this node's name
 */

/**
 * Padding for alignment
 */

/**
 * Offset to model's root node
 */

/**
 * Offset to this node's parent node (0 if root)
 */

/**
 * Node position in local space (X, Y, Z)
 */

/**
 * Node orientation as quaternion (W, X, Y, Z)
 */

/**
 * Offset to array of child node offsets
 */

/**
 * Number of child nodes
 */

/**
 * Duplicate value of child count
 */

/**
 * Offset to array of controller structures
 */

/**
 * Number of controllers attached to this node
 */

/**
 * Duplicate value of controller count
 */

/**
 * Offset to controller keyframe/data array
 */

/**
 * Number of floats in controller data array
 */

/**
 * Duplicate value of controller data count
 */

/**
 * Quaternion rotation (4 floats W, X, Y, Z)
 */
type Mdl_Quaternion struct {
	W float32
	X float32
	Y float32
	Z float32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl_NodeHeader
}
func NewMdl_Quaternion() *Mdl_Quaternion {
	return &Mdl_Quaternion{
	}
}

func (this Mdl_Quaternion) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_Quaternion) Read(io *kaitai.Stream, parent *Mdl_NodeHeader, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp162, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.W = float32(tmp162)
	tmp163, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.X = float32(tmp163)
	tmp164, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Y = float32(tmp164)
	tmp165, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Z = float32(tmp165)
	return err
}

/**
 * Reference header (36 bytes)
 */
type Mdl_ReferenceHeader struct {
	ModelResref string
	Reattachable uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl_Node
}
func NewMdl_ReferenceHeader() *Mdl_ReferenceHeader {
	return &Mdl_ReferenceHeader{
	}
}

func (this Mdl_ReferenceHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_ReferenceHeader) Read(io *kaitai.Stream, parent *Mdl_Node, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp166, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp166 = kaitai.BytesTerminate(tmp166, 0, false)
	this.ModelResref = string(tmp166)
	tmp167, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Reattachable = uint32(tmp167)
	return err
}

/**
 * Referenced model resource name without extension (null-terminated string)
 */

/**
 * 1 if model can be detached and reattached dynamically, 0 if permanent
 */

/**
 * Skinmesh header (432 bytes KOTOR 1, 440 bytes KOTOR 2) - extends trimesh_header
 */
type Mdl_SkinmeshHeader struct {
	TrimeshBase *Mdl_TrimeshHeader
	UnknownWeights int32
	Padding1 []uint8
	MdxBoneWeightsOffset uint32
	MdxBoneIndicesOffset uint32
	BoneMapOffset uint32
	BoneMapCount uint32
	QbonesOffset uint32
	QbonesCount uint32
	QbonesCountDuplicate uint32
	TbonesOffset uint32
	TbonesCount uint32
	TbonesCountDuplicate uint32
	UnknownArray uint32
	BoneNodeSerialNumbers []uint16
	Padding2 uint16
	_io *kaitai.Stream
	_root *Mdl
	_parent *Mdl_Node
}
func NewMdl_SkinmeshHeader() *Mdl_SkinmeshHeader {
	return &Mdl_SkinmeshHeader{
	}
}

func (this Mdl_SkinmeshHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_SkinmeshHeader) Read(io *kaitai.Stream, parent *Mdl_Node, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp168 := NewMdl_TrimeshHeader()
	err = tmp168.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.TrimeshBase = tmp168
	tmp169, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.UnknownWeights = int32(tmp169)
	for i := 0; i < int(8); i++ {
		_ = i
		tmp170, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Padding1 = append(this.Padding1, tmp170)
	}
	tmp171, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MdxBoneWeightsOffset = uint32(tmp171)
	tmp172, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MdxBoneIndicesOffset = uint32(tmp172)
	tmp173, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.BoneMapOffset = uint32(tmp173)
	tmp174, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.BoneMapCount = uint32(tmp174)
	tmp175, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.QbonesOffset = uint32(tmp175)
	tmp176, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.QbonesCount = uint32(tmp176)
	tmp177, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.QbonesCountDuplicate = uint32(tmp177)
	tmp178, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TbonesOffset = uint32(tmp178)
	tmp179, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TbonesCount = uint32(tmp179)
	tmp180, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TbonesCountDuplicate = uint32(tmp180)
	tmp181, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.UnknownArray = uint32(tmp181)
	for i := 0; i < int(16); i++ {
		_ = i
		tmp182, err := this._io.ReadU2le()
		if err != nil {
			return err
		}
		this.BoneNodeSerialNumbers = append(this.BoneNodeSerialNumbers, tmp182)
	}
	tmp183, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Padding2 = uint16(tmp183)
	return err
}

/**
 * Standard trimesh header
 */

/**
 * Purpose unknown (possibly compilation weights)
 */

/**
 * Padding
 */

/**
 * Offset to bone weight data in MDX file (4 floats per vertex)
 */

/**
 * Offset to bone index data in MDX file (4 floats per vertex, cast to uint16)
 */

/**
 * Offset to bone map array (maps local bone indices to skeleton bone numbers)
 */

/**
 * Number of bones referenced by this mesh (max 16)
 */

/**
 * Offset to quaternion bind pose array (4 floats per bone)
 */

/**
 * Number of quaternion bind poses
 */

/**
 * Duplicate of QBones count
 */

/**
 * Offset to translation bind pose array (3 floats per bone)
 */

/**
 * Number of translation bind poses
 */

/**
 * Duplicate of TBones count
 */

/**
 * Purpose unknown
 */

/**
 * Serial indices of bone nodes (0xFFFF for unused slots)
 */

/**
 * Padding for alignment
 */

/**
 * Trimesh header (332 bytes KOTOR 1, 340 bytes KOTOR 2)
 */
type Mdl_TrimeshHeader struct {
	FunctionPointer0 uint32
	FunctionPointer1 uint32
	FacesArrayOffset uint32
	FacesCount uint32
	FacesCountDuplicate uint32
	BoundingBoxMin *Mdl_Vec3f
	BoundingBoxMax *Mdl_Vec3f
	Radius float32
	AveragePoint *Mdl_Vec3f
	DiffuseColor *Mdl_Vec3f
	AmbientColor *Mdl_Vec3f
	TransparencyHint uint32
	Texture0Name string
	Texture1Name string
	Texture2Name string
	Texture3Name string
	IndicesCountArrayOffset uint32
	IndicesCountArrayCount uint32
	IndicesCountArrayCountDuplicate uint32
	IndicesOffsetArrayOffset uint32
	IndicesOffsetArrayCount uint32
	IndicesOffsetArrayCountDuplicate uint32
	InvertedCounterArrayOffset uint32
	InvertedCounterArrayCount uint32
	InvertedCounterArrayCountDuplicate uint32
	UnknownValues []int32
	SaberUnknownData []uint8
	Unknown uint32
	UvDirection *Mdl_Vec3f
	UvJitter float32
	UvJitterSpeed float32
	MdxVertexSize uint32
	MdxDataFlags uint32
	MdxVerticesOffset int32
	MdxNormalsOffset int32
	MdxVertexColorsOffset int32
	MdxTex0UvsOffset int32
	MdxTex1UvsOffset int32
	MdxTex2UvsOffset int32
	MdxTex3UvsOffset int32
	MdxTangentSpaceOffset int32
	MdxUnknownOffset1 int32
	MdxUnknownOffset2 int32
	MdxUnknownOffset3 int32
	VertexCount uint16
	TextureCount uint16
	Lightmapped uint8
	RotateTexture uint8
	BackgroundGeometry uint8
	Shadow uint8
	Beaming uint8
	Render uint8
	UnknownFlag uint8
	Padding uint8
	TotalArea float32
	Unknown2 uint32
	K2Unknown1 uint32
	K2Unknown2 uint32
	MdxDataOffset uint32
	MdlVerticesOffset uint32
	_io *kaitai.Stream
	_root *Mdl
	_parent kaitai.Struct
}
func NewMdl_TrimeshHeader() *Mdl_TrimeshHeader {
	return &Mdl_TrimeshHeader{
	}
}

func (this Mdl_TrimeshHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_TrimeshHeader) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp184, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FunctionPointer0 = uint32(tmp184)
	tmp185, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FunctionPointer1 = uint32(tmp185)
	tmp186, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FacesArrayOffset = uint32(tmp186)
	tmp187, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FacesCount = uint32(tmp187)
	tmp188, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FacesCountDuplicate = uint32(tmp188)
	tmp189 := NewMdl_Vec3f()
	err = tmp189.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.BoundingBoxMin = tmp189
	tmp190 := NewMdl_Vec3f()
	err = tmp190.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.BoundingBoxMax = tmp190
	tmp191, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Radius = float32(tmp191)
	tmp192 := NewMdl_Vec3f()
	err = tmp192.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.AveragePoint = tmp192
	tmp193 := NewMdl_Vec3f()
	err = tmp193.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.DiffuseColor = tmp193
	tmp194 := NewMdl_Vec3f()
	err = tmp194.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.AmbientColor = tmp194
	tmp195, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TransparencyHint = uint32(tmp195)
	tmp196, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp196 = kaitai.BytesTerminate(tmp196, 0, false)
	this.Texture0Name = string(tmp196)
	tmp197, err := this._io.ReadBytes(int(32))
	if err != nil {
		return err
	}
	tmp197 = kaitai.BytesTerminate(tmp197, 0, false)
	this.Texture1Name = string(tmp197)
	tmp198, err := this._io.ReadBytes(int(12))
	if err != nil {
		return err
	}
	tmp198 = kaitai.BytesTerminate(tmp198, 0, false)
	this.Texture2Name = string(tmp198)
	tmp199, err := this._io.ReadBytes(int(12))
	if err != nil {
		return err
	}
	tmp199 = kaitai.BytesTerminate(tmp199, 0, false)
	this.Texture3Name = string(tmp199)
	tmp200, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.IndicesCountArrayOffset = uint32(tmp200)
	tmp201, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.IndicesCountArrayCount = uint32(tmp201)
	tmp202, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.IndicesCountArrayCountDuplicate = uint32(tmp202)
	tmp203, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.IndicesOffsetArrayOffset = uint32(tmp203)
	tmp204, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.IndicesOffsetArrayCount = uint32(tmp204)
	tmp205, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.IndicesOffsetArrayCountDuplicate = uint32(tmp205)
	tmp206, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.InvertedCounterArrayOffset = uint32(tmp206)
	tmp207, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.InvertedCounterArrayCount = uint32(tmp207)
	tmp208, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.InvertedCounterArrayCountDuplicate = uint32(tmp208)
	for i := 0; i < int(3); i++ {
		_ = i
		tmp209, err := this._io.ReadS4le()
		if err != nil {
			return err
		}
		this.UnknownValues = append(this.UnknownValues, tmp209)
	}
	for i := 0; i < int(8); i++ {
		_ = i
		tmp210, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.SaberUnknownData = append(this.SaberUnknownData, tmp210)
	}
	tmp211, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown = uint32(tmp211)
	tmp212 := NewMdl_Vec3f()
	err = tmp212.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.UvDirection = tmp212
	tmp213, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.UvJitter = float32(tmp213)
	tmp214, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.UvJitterSpeed = float32(tmp214)
	tmp215, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MdxVertexSize = uint32(tmp215)
	tmp216, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MdxDataFlags = uint32(tmp216)
	tmp217, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.MdxVerticesOffset = int32(tmp217)
	tmp218, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.MdxNormalsOffset = int32(tmp218)
	tmp219, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.MdxVertexColorsOffset = int32(tmp219)
	tmp220, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.MdxTex0UvsOffset = int32(tmp220)
	tmp221, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.MdxTex1UvsOffset = int32(tmp221)
	tmp222, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.MdxTex2UvsOffset = int32(tmp222)
	tmp223, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.MdxTex3UvsOffset = int32(tmp223)
	tmp224, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.MdxTangentSpaceOffset = int32(tmp224)
	tmp225, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.MdxUnknownOffset1 = int32(tmp225)
	tmp226, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.MdxUnknownOffset2 = int32(tmp226)
	tmp227, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.MdxUnknownOffset3 = int32(tmp227)
	tmp228, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.VertexCount = uint16(tmp228)
	tmp229, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.TextureCount = uint16(tmp229)
	tmp230, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Lightmapped = tmp230
	tmp231, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.RotateTexture = tmp231
	tmp232, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.BackgroundGeometry = tmp232
	tmp233, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Shadow = tmp233
	tmp234, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Beaming = tmp234
	tmp235, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Render = tmp235
	tmp236, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.UnknownFlag = tmp236
	tmp237, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Padding = tmp237
	tmp238, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.TotalArea = float32(tmp238)
	tmp239, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown2 = uint32(tmp239)
	tmp240, err := this._root.ModelHeader.Geometry.IsKotor2()
	if err != nil {
		return err
	}
	if (tmp240) {
		tmp241, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.K2Unknown1 = uint32(tmp241)
	}
	tmp242, err := this._root.ModelHeader.Geometry.IsKotor2()
	if err != nil {
		return err
	}
	if (tmp242) {
		tmp243, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.K2Unknown2 = uint32(tmp243)
	}
	tmp244, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MdxDataOffset = uint32(tmp244)
	tmp245, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MdlVerticesOffset = uint32(tmp245)
	return err
}

/**
 * Game engine function pointer (version-specific)
 */

/**
 * Secondary game engine function pointer
 */

/**
 * Offset to face definitions array
 */

/**
 * Number of triangular faces in mesh
 */

/**
 * Duplicate of faces count
 */

/**
 * Minimum bounding box coordinates (X, Y, Z)
 */

/**
 * Maximum bounding box coordinates (X, Y, Z)
 */

/**
 * Bounding sphere radius
 */

/**
 * Average vertex position (centroid) X, Y, Z
 */

/**
 * Material diffuse color (R, G, B, range 0.0-1.0)
 */

/**
 * Material ambient color (R, G, B, range 0.0-1.0)
 */

/**
 * Transparency rendering mode
 */

/**
 * Primary diffuse texture name (null-terminated string)
 */

/**
 * Secondary texture name, often lightmap (null-terminated string)
 */

/**
 * Tertiary texture name (null-terminated string)
 */

/**
 * Quaternary texture name (null-terminated string)
 */

/**
 * Offset to vertex indices count array
 */

/**
 * Number of entries in indices count array
 */

/**
 * Duplicate of indices count array count
 */

/**
 * Offset to vertex indices offset array
 */

/**
 * Number of entries in indices offset array
 */

/**
 * Duplicate of indices offset array count
 */

/**
 * Offset to inverted counter array
 */

/**
 * Number of entries in inverted counter array
 */

/**
 * Duplicate of inverted counter array count
 */

/**
 * Typically {-1, -1, 0}, purpose unknown
 */

/**
 * Data specific to lightsaber meshes
 */

/**
 * Purpose unknown
 */

/**
 * UV animation direction X, Y components (Z = jitter speed)
 */

/**
 * UV animation jitter amount
 */

/**
 * UV animation jitter speed
 */

/**
 * Size in bytes of each vertex in MDX data
 */

/**
 * Bitmask of present vertex attributes:
 * - 0x00000001: MDX_VERTICES (vertex positions)
 * - 0x00000002: MDX_TEX0_VERTICES (primary texture coordinates)
 * - 0x00000004: MDX_TEX1_VERTICES (secondary texture coordinates)
 * - 0x00000008: MDX_TEX2_VERTICES (tertiary texture coordinates)
 * - 0x00000010: MDX_TEX3_VERTICES (quaternary texture coordinates)
 * - 0x00000020: MDX_VERTEX_NORMALS (vertex normals)
 * - 0x00000040: MDX_VERTEX_COLORS (vertex colors)
 * - 0x00000080: MDX_TANGENT_SPACE (tangent space data)
 */

/**
 * Relative offset to vertex positions in MDX (or -1 if none)
 */

/**
 * Relative offset to vertex normals in MDX (or -1 if none)
 */

/**
 * Relative offset to vertex colors in MDX (or -1 if none)
 */

/**
 * Relative offset to primary texture UVs in MDX (or -1 if none)
 */

/**
 * Relative offset to secondary texture UVs in MDX (or -1 if none)
 */

/**
 * Relative offset to tertiary texture UVs in MDX (or -1 if none)
 */

/**
 * Relative offset to quaternary texture UVs in MDX (or -1 if none)
 */

/**
 * Relative offset to tangent space data in MDX (or -1 if none)
 */

/**
 * Relative offset to unknown MDX data (or -1 if none)
 */

/**
 * Relative offset to unknown MDX data (or -1 if none)
 */

/**
 * Relative offset to unknown MDX data (or -1 if none)
 */

/**
 * Number of vertices in mesh
 */

/**
 * Number of textures used by mesh
 */

/**
 * 1 if mesh uses lightmap, 0 otherwise
 */

/**
 * 1 if texture should rotate, 0 otherwise
 */

/**
 * 1 if background geometry, 0 otherwise
 */

/**
 * 1 if mesh casts shadows, 0 otherwise
 */

/**
 * 1 if beaming effect enabled, 0 otherwise
 */

/**
 * 1 if mesh is renderable, 0 if hidden
 */

/**
 * Purpose unknown (possibly UV animation enable)
 */

/**
 * Padding byte
 */

/**
 * Total surface area of all faces
 */

/**
 * Purpose unknown
 */

/**
 * KOTOR 2 only: Additional unknown field
 */

/**
 * KOTOR 2 only: Additional unknown field
 */

/**
 * Absolute offset to this mesh's vertex data in MDX file
 */

/**
 * Offset to vertex coordinate array in MDL file (for walkmesh/AABB nodes)
 */

/**
 * 3D vector (3 floats)
 */
type Mdl_Vec3f struct {
	X float32
	Y float32
	Z float32
	_io *kaitai.Stream
	_root *Mdl
	_parent kaitai.Struct
}
func NewMdl_Vec3f() *Mdl_Vec3f {
	return &Mdl_Vec3f{
	}
}

func (this Mdl_Vec3f) IO_() *kaitai.Stream {
	return this._io
}

func (this *Mdl_Vec3f) Read(io *kaitai.Stream, parent kaitai.Struct, root *Mdl) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp246, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.X = float32(tmp246)
	tmp247, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Y = float32(tmp247)
	tmp248, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Z = float32(tmp248)
	return err
}
