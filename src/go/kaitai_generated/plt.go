// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"


/**
 * PLT (Palette Texture) is a texture format used in Neverwinter Nights that allows runtime color
 * palette selection. Instead of fixed colors, PLT files store palette group indices and color indices
 * that reference external palette files, enabling dynamic color customization for character models
 * (skin, hair, armor colors, etc.).
 * 
 * **Note**: This format is Neverwinter Nights-specific and is NOT used in KotOR games. While the PLT
 * resource type (0x0006) exists in KotOR's resource system due to shared Aurora engine heritage, KotOR
 * does not load, parse, or use PLT files. KotOR uses standard TPC/TGA/DDS textures for all textures,
 * including character models. This documentation is provided for reference only.
 * 
 * Binary Format Structure:
 * - Header (24 bytes): Signature, Version, Unknown fields, Width, Height
 * - Pixel Data: Array of 2-byte pixel entries (color index + palette group index)
 * 
 * Palette System:
 * PLT files work in conjunction with external palette files (.pal files) that contain the actual
 * color values. The PLT file itself stores:
 * 1. Palette Group index (0-9): Which palette group to use for each pixel
 * 2. Color index (0-255): Which color within the selected palette to use
 * 
 * At runtime, the game:
 * 1. Loads the appropriate palette file for the selected palette group
 * 2. Uses the palette index (supplied by the content creator) to select a row in the palette file
 * 3. Uses the color index from the PLT file to retrieve the final color value
 * 
 * Palette Groups (10 total):
 * 0 = Skin, 1 = Hair, 2 = Metal 1, 3 = Metal 2, 4 = Cloth 1, 5 = Cloth 2,
 * 6 = Leather 1, 7 = Leather 2, 8 = Tattoo 1, 9 = Tattoo 2
 * 
 * References:
 * - https://github.com/OldRepublicDevs/PyKotor/wiki/PLT-File-Format.md
 * - https://github.com/xoreos/xoreos-docs/blob/master/specs/torlack/plt.html
 * - https://github.com/xoreos/xoreos/blob/master/src/graphics/aurora/pltfile.cpp
 */
type Plt struct {
	Header *Plt_PltHeader
	PixelData *Plt_PixelDataSection
	_io *kaitai.Stream
	_root *Plt
	_parent kaitai.Struct
}
func NewPlt() *Plt {
	return &Plt{
	}
}

func (this Plt) IO_() *kaitai.Stream {
	return this._io
}

func (this *Plt) Read(io *kaitai.Stream, parent kaitai.Struct, root *Plt) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1 := NewPlt_PltHeader()
	err = tmp1.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Header = tmp1
	tmp2 := NewPlt_PixelDataSection()
	err = tmp2.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.PixelData = tmp2
	return err
}

/**
 * PLT file header (24 bytes)
 */

/**
 * Array of pixel entries (width × height entries, 2 bytes each)
 */
type Plt_PixelDataSection struct {
	Pixels []*Plt_PltPixel
	_io *kaitai.Stream
	_root *Plt
	_parent *Plt
}
func NewPlt_PixelDataSection() *Plt_PixelDataSection {
	return &Plt_PixelDataSection{
	}
}

func (this Plt_PixelDataSection) IO_() *kaitai.Stream {
	return this._io
}

func (this *Plt_PixelDataSection) Read(io *kaitai.Stream, parent *Plt, root *Plt) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.Header.Width * this._root.Header.Height); i++ {
		_ = i
		tmp3 := NewPlt_PltPixel()
		err = tmp3.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Pixels = append(this.Pixels, tmp3)
	}
	return err
}

/**
 * Array of pixel entries, stored row by row, left to right, top to bottom.
 * Total size = width × height × 2 bytes.
 * Each pixel entry contains a color index and palette group index.
 */
type Plt_PltHeader struct {
	Signature string
	Version string
	Unknown1 uint32
	Unknown2 uint32
	Width uint32
	Height uint32
	_io *kaitai.Stream
	_root *Plt
	_parent *Plt
}
func NewPlt_PltHeader() *Plt_PltHeader {
	return &Plt_PltHeader{
	}
}

func (this Plt_PltHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Plt_PltHeader) Read(io *kaitai.Stream, parent *Plt, root *Plt) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp4, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp4 = tmp4
	this.Signature = string(tmp4)
	if !(this.Signature == "PLT ") {
		return kaitai.NewValidationNotEqualError("PLT ", this.Signature, this._io, "/types/plt_header/seq/0")
	}
	tmp5, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp5 = tmp5
	this.Version = string(tmp5)
	if !(this.Version == "V1  ") {
		return kaitai.NewValidationNotEqualError("V1  ", this.Version, this._io, "/types/plt_header/seq/1")
	}
	tmp6, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown1 = uint32(tmp6)
	tmp7, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown2 = uint32(tmp7)
	tmp8, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Width = uint32(tmp8)
	tmp9, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Height = uint32(tmp9)
	return err
}

/**
 * File signature. Must be "PLT " (space-padded).
 * This identifies the file as a PLT palette texture.
 */

/**
 * File format version. Must be "V1  " (space-padded).
 * This is the only known version of the PLT format.
 */

/**
 * Unknown field (4 bytes).
 * Purpose is unknown, may be reserved for future use or internal engine flags.
 */

/**
 * Unknown field (4 bytes).
 * Purpose is unknown, may be reserved for future use or internal engine flags.
 */

/**
 * Texture width in pixels (uint32).
 * Used to calculate the number of pixel entries in the pixel data section.
 */

/**
 * Texture height in pixels (uint32).
 * Used to calculate the number of pixel entries in the pixel data section.
 * Total pixel count = width × height
 */
type Plt_PltPixel struct {
	ColorIndex uint8
	PaletteGroupIndex uint8
	_io *kaitai.Stream
	_root *Plt
	_parent *Plt_PixelDataSection
}
func NewPlt_PltPixel() *Plt_PltPixel {
	return &Plt_PltPixel{
	}
}

func (this Plt_PltPixel) IO_() *kaitai.Stream {
	return this._io
}

func (this *Plt_PltPixel) Read(io *kaitai.Stream, parent *Plt_PixelDataSection, root *Plt) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp10, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.ColorIndex = tmp10
	tmp11, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.PaletteGroupIndex = tmp11
	return err
}

/**
 * Color index (0-255) within the selected palette.
 * This value selects which color from the palette file row to use.
 * The palette file contains 256 rows (one for each palette index 0-255),
 * and each row contains 256 color values (one for each color index 0-255).
 */

/**
 * Palette group index (0-9) that determines which palette file to use.
 * Palette groups:
 * 0 = Skin (pal_skin01.jpg)
 * 1 = Hair (pal_hair01.jpg)
 * 2 = Metal 1 (pal_armor01.jpg)
 * 3 = Metal 2 (pal_armor02.jpg)
 * 4 = Cloth 1 (pal_cloth01.jpg)
 * 5 = Cloth 2 (pal_cloth01.jpg)
 * 6 = Leather 1 (pal_leath01.jpg)
 * 7 = Leather 2 (pal_leath01.jpg)
 * 8 = Tattoo 1 (pal_tattoo01.jpg)
 * 9 = Tattoo 2 (pal_tattoo01.jpg)
 */
