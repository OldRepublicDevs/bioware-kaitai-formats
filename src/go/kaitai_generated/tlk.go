// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"io"
)


/**
 * TLK (Talk Table) files contain all text strings used in the game, both written and spoken.
 * They enable easy localization by providing a lookup table from string reference numbers (StrRef)
 * to localized text and associated voice-over audio files.
 * 
 * Binary Format Structure:
 * - File Header (20 bytes): File type signature, version, language ID, string count, entries offset
 * - String Data Table (40 bytes per entry): Metadata for each string entry (flags, sound ResRef, offsets, lengths)
 * - String Entries (variable size): Sequential null-terminated text strings starting at entries_offset
 * 
 * The format uses a two-level structure:
 * 1. String Data Table: Contains metadata (flags, sound filename, text offset/length) for each entry
 * 2. String Entries: Actual text data stored sequentially, referenced by offsets in the data table
 * 
 * String references (StrRef) are 0-based indices into the string_data_table array. StrRef 0 refers to
 * the first entry, StrRef 1 to the second, etc. StrRef -1 indicates no string reference.
 * 
 * References:
 * - https://github.com/OldRepublicDevs/PyKotor/wiki/TLK-File-Format.md
 * - https://github.com/seedhartha/reone/blob/master/src/libs/resource/format/tlkreader.cpp:31-84
 * - https://github.com/xoreos/xoreos/blob/master/src/aurora/talktable.cpp:42-176
 * - https://github.com/TSLPatcher/TSLPatcher/blob/master/lib/site/Bioware/TLK.pm:1-533
 * - https://github.com/KotOR-Community-Patches/Kotor.NET/blob/master/Kotor.NET/Formats/KotorTLK/TLKBinaryStructure.cs:11-132
 */
type Tlk struct {
	Header *Tlk_TlkHeader
	StringDataTable *Tlk_StringDataTable
	_io *kaitai.Stream
	_root *Tlk
	_parent kaitai.Struct
}
func NewTlk() *Tlk {
	return &Tlk{
	}
}

func (this Tlk) IO_() *kaitai.Stream {
	return this._io
}

func (this *Tlk) Read(io *kaitai.Stream, parent kaitai.Struct, root *Tlk) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1 := NewTlk_TlkHeader()
	err = tmp1.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Header = tmp1
	tmp2 := NewTlk_StringDataTable()
	err = tmp2.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.StringDataTable = tmp2
	return err
}

/**
 * TLK file header (20 bytes) - contains file signature, version, language, and counts
 */

/**
 * Array of string data entries (metadata for each string) - 40 bytes per entry
 */
type Tlk_StringDataEntry struct {
	Flags uint32
	SoundResref string
	VolumeVariance uint32
	PitchVariance uint32
	TextOffset uint32
	TextLength uint32
	SoundLength float32
	_io *kaitai.Stream
	_root *Tlk
	_parent *Tlk_StringDataTable
	_f_entrySize bool
	entrySize int8
	_f_soundLengthPresent bool
	soundLengthPresent bool
	_f_soundPresent bool
	soundPresent bool
	_f_textData bool
	textData string
	_f_textFileOffset bool
	textFileOffset int
	_f_textPresent bool
	textPresent bool
}
func NewTlk_StringDataEntry() *Tlk_StringDataEntry {
	return &Tlk_StringDataEntry{
	}
}

func (this Tlk_StringDataEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Tlk_StringDataEntry) Read(io *kaitai.Stream, parent *Tlk_StringDataTable, root *Tlk) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp3, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Flags = uint32(tmp3)
	tmp4, err := this._io.ReadBytes(int(16))
	if err != nil {
		return err
	}
	tmp4 = tmp4
	this.SoundResref = string(tmp4)
	tmp5, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.VolumeVariance = uint32(tmp5)
	tmp6, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.PitchVariance = uint32(tmp6)
	tmp7, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TextOffset = uint32(tmp7)
	tmp8, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.TextLength = uint32(tmp8)
	tmp9, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.SoundLength = float32(tmp9)
	return err
}

/**
 * Size of each string_data_entry in bytes.
 * Breakdown: flags (4) + sound_resref (16) + volume_variance (4) + pitch_variance (4) + 
 * text_offset (4) + text_length (4) + sound_length (4) = 40 bytes total.
 */
func (this *Tlk_StringDataEntry) EntrySize() (v int8, err error) {
	if (this._f_entrySize) {
		return this.entrySize, nil
	}
	this._f_entrySize = true
	this.entrySize = int8(40)
	return this.entrySize, nil
}

/**
 * Whether sound length is valid (bit 2 of flags)
 */
func (this *Tlk_StringDataEntry) SoundLengthPresent() (v bool, err error) {
	if (this._f_soundLengthPresent) {
		return this.soundLengthPresent, nil
	}
	this._f_soundLengthPresent = true
	this.soundLengthPresent = bool(this.Flags & 4 != 0)
	return this.soundLengthPresent, nil
}

/**
 * Whether voice-over audio exists (bit 1 of flags)
 */
func (this *Tlk_StringDataEntry) SoundPresent() (v bool, err error) {
	if (this._f_soundPresent) {
		return this.soundPresent, nil
	}
	this._f_soundPresent = true
	this.soundPresent = bool(this.Flags & 2 != 0)
	return this.soundPresent, nil
}

/**
 * Text string data as raw bytes (read as ASCII for byte-level access).
 * The actual encoding depends on the language_id in the header.
 * Common encodings:
 * - English/French/German/Italian/Spanish: Windows-1252 (cp1252)
 * - Polish: Windows-1250 (cp1250)
 * - Korean: EUC-KR (cp949)
 * - Chinese Traditional: Big5 (cp950)
 * - Chinese Simplified: GB2312 (cp936)
 * - Japanese: Shift-JIS (cp932)
 * 
 * Note: This field reads the raw bytes as ASCII string for byte-level access.
 * The application layer should decode based on the language_id field in the header.
 * To get raw bytes, access the underlying byte representation of this string.
 * 
 * In practice, strings are stored sequentially starting at entries_offset,
 * so text_offset values are relative to entries_offset (0, len1, len1+len2, etc.).
 * 
 * Strings may be null-terminated, but text_length includes the null terminator.
 * Application code should trim null bytes when decoding.
 * 
 * If text_present flag (bit 0) is not set, this field may contain garbage data
 * or be empty. Always check text_present before using this data.
 */
func (this *Tlk_StringDataEntry) TextData() (v string, err error) {
	if (this._f_textData) {
		return this.textData, nil
	}
	this._f_textData = true
	_pos, err := this._io.Pos()
	if err != nil {
		return "", err
	}
	tmp10, err := this.TextFileOffset()
	if err != nil {
		return "", err
	}
	_, err = this._io.Seek(int64(tmp10), io.SeekStart)
	if err != nil {
		return "", err
	}
	tmp11, err := this._io.ReadBytes(int(this.TextLength))
	if err != nil {
		return "", err
	}
	tmp11 = tmp11
	this.textData = string(tmp11)
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return "", err
	}
	return this.textData, nil
}

/**
 * Absolute file offset to the text string.
 * Calculated as entries_offset (from header) + text_offset (from entry).
 */
func (this *Tlk_StringDataEntry) TextFileOffset() (v int, err error) {
	if (this._f_textFileOffset) {
		return this.textFileOffset, nil
	}
	this._f_textFileOffset = true
	this.textFileOffset = int(this._root.Header.EntriesOffset + this.TextOffset)
	return this.textFileOffset, nil
}

/**
 * Whether text content exists (bit 0 of flags)
 */
func (this *Tlk_StringDataEntry) TextPresent() (v bool, err error) {
	if (this._f_textPresent) {
		return this.textPresent, nil
	}
	this._f_textPresent = true
	this.textPresent = bool(this.Flags & 1 != 0)
	return this.textPresent, nil
}

/**
 * Bit flags indicating what data is present:
 * - bit 0 (0x0001): Text present - string has text content
 * - bit 1 (0x0002): Sound present - string has associated voice-over audio
 * - bit 2 (0x0004): Sound length present - sound length field is valid
 * 
 * Common flag combinations:
 * - 0x0001: Text only (menu options, item descriptions)
 * - 0x0003: Text + Sound (voiced dialog lines)
 * - 0x0007: Text + Sound + Length (fully voiced with duration)
 * - 0x0000: Empty entry (unused StrRef slots)
 */

/**
 * Voice-over audio filename (ResRef), null-terminated ASCII, max 16 chars.
 * If the string is shorter than 16 bytes, it is null-padded.
 * Empty string (all nulls) indicates no voice-over audio.
 */

/**
 * Volume variance (unused in KotOR, always 0).
 * Legacy field from Neverwinter Nights, not used by KotOR engine.
 */

/**
 * Pitch variance (unused in KotOR, always 0).
 * Legacy field from Neverwinter Nights, not used by KotOR engine.
 */

/**
 * Offset to string text relative to entries_offset.
 * The actual file offset is: header.entries_offset + text_offset.
 * First string starts at offset 0, subsequent strings follow sequentially.
 */

/**
 * Length of string text in bytes (not characters).
 * For single-byte encodings (Windows-1252, etc.), byte length equals character count.
 * For multi-byte encodings (UTF-8, etc.), byte length may be greater than character count.
 */

/**
 * Duration of voice-over audio in seconds (float).
 * Only valid if sound_length_present flag (bit 2) is set.
 * Used by the engine to determine how long to wait before auto-advancing dialog.
 */
type Tlk_StringDataTable struct {
	Entries []*Tlk_StringDataEntry
	_io *kaitai.Stream
	_root *Tlk
	_parent *Tlk
}
func NewTlk_StringDataTable() *Tlk_StringDataTable {
	return &Tlk_StringDataTable{
	}
}

func (this Tlk_StringDataTable) IO_() *kaitai.Stream {
	return this._io
}

func (this *Tlk_StringDataTable) Read(io *kaitai.Stream, parent *Tlk, root *Tlk) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.Header.StringCount); i++ {
		_ = i
		tmp12 := NewTlk_StringDataEntry()
		err = tmp12.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Entries = append(this.Entries, tmp12)
	}
	return err
}

/**
 * Array of string data entries, one per string in the file
 */
type Tlk_TlkHeader struct {
	FileType string
	FileVersion string
	LanguageId uint32
	StringCount uint32
	EntriesOffset uint32
	_io *kaitai.Stream
	_root *Tlk
	_parent *Tlk
	_f_expectedEntriesOffset bool
	expectedEntriesOffset int
	_f_headerSize bool
	headerSize int8
}
func NewTlk_TlkHeader() *Tlk_TlkHeader {
	return &Tlk_TlkHeader{
	}
}

func (this Tlk_TlkHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Tlk_TlkHeader) Read(io *kaitai.Stream, parent *Tlk, root *Tlk) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp13, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp13 = tmp13
	this.FileType = string(tmp13)
	tmp14, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp14 = tmp14
	this.FileVersion = string(tmp14)
	tmp15, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LanguageId = uint32(tmp15)
	tmp16, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.StringCount = uint32(tmp16)
	tmp17, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.EntriesOffset = uint32(tmp17)
	return err
}

/**
 * Expected offset to string entries (header + string data table).
 * Used for validation.
 */
func (this *Tlk_TlkHeader) ExpectedEntriesOffset() (v int, err error) {
	if (this._f_expectedEntriesOffset) {
		return this.expectedEntriesOffset, nil
	}
	this._f_expectedEntriesOffset = true
	this.expectedEntriesOffset = int(20 + this.StringCount * 40)
	return this.expectedEntriesOffset, nil
}

/**
 * Size of the TLK header in bytes
 */
func (this *Tlk_TlkHeader) HeaderSize() (v int8, err error) {
	if (this._f_headerSize) {
		return this.headerSize, nil
	}
	this._f_headerSize = true
	this.headerSize = int8(20)
	return this.headerSize, nil
}

/**
 * File type signature. Must be "TLK " (space-padded).
 * Validates that this is a TLK file.
 * Note: Validation removed temporarily due to Kaitai Struct parser issues.
 */

/**
 * File format version. "V3.0" for KotOR, "V4.0" for Jade Empire.
 * KotOR games use V3.0. Jade Empire uses V4.0.
 * Note: Validation removed due to Kaitai Struct parser limitations with period in string.
 */

/**
 * Language identifier:
 * - 0 = English
 * - 1 = French
 * - 2 = German
 * - 3 = Italian
 * - 4 = Spanish
 * - 5 = Polish
 * - 128 = Korean
 * - 129 = Chinese Traditional
 * - 130 = Chinese Simplified
 * - 131 = Japanese
 * See Language enum for complete list.
 */

/**
 * Number of string entries in the file.
 * Determines the number of entries in string_data_table.
 */

/**
 * Byte offset to string entries array from the beginning of the file.
 * Typically 20 + (string_count * 40) = header size + string data table size.
 * Points to where the actual text strings begin.
 */
