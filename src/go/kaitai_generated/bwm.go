// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"io"
)


/**
 * BWM (Binary WalkMesh) files define walkable surfaces for pathfinding and collision detection
 * in Knights of the Old Republic (KotOR) games. BWM files are stored on disk with different
 * extensions depending on their type:
 * 
 * - WOK: Area walkmesh files (walkmesh_type = 1) - defines walkable regions in game areas
 * - PWK: Placeable walkmesh files (walkmesh_type = 0) - collision geometry for containers, furniture
 * - DWK: Door walkmesh files (walkmesh_type = 0) - collision geometry for doors in various states
 * 
 * The format uses a header-based structure where offsets point to various data tables, allowing
 * efficient random access to vertices, faces, materials, and acceleration structures.
 * 
 * Binary Format Structure:
 * - File Header (8 bytes): Magic "BWM " and version "V1.0"
 * - Walkmesh Properties (52 bytes): Type, hook vectors, position
 * - Data Table Offsets (84 bytes): Counts and offsets for all data tables
 * - Vertices Array: Array of float3 (x, y, z) per vertex
 * - Face Indices Array: Array of uint32 triplets (vertex indices per face)
 * - Materials Array: Array of uint32 (SurfaceMaterial ID per face)
 * - Normals Array: Array of float3 (face normal per face) - WOK only
 * - Planar Distances Array: Array of float32 (per face) - WOK only
 * - AABB Nodes Array: Array of AABB structures (WOK only)
 * - Adjacencies Array: Array of int32 triplets (WOK only, -1 for no neighbor)
 * - Edges Array: Array of (edge_index, transition) pairs (WOK only)
 * - Perimeters Array: Array of edge indices (WOK only)
 * 
 * References:
 * - https://github.com/OldRepublicDevs/PyKotor/wiki/BWM-File-Format.md
 * - https://github.com/seedhartha/reone/blob/master/src/libs/graphics/format/bwmreader.cpp:27-171
 * - https://github.com/xoreos/xoreos/blob/master/src/engines/kotorbase/path/walkmeshloader.cpp:73-248
 * - https://github.com/KotOR-Community-Patches/KotOR.js/blob/master/src/odyssey/OdysseyWalkMesh.ts:452-473
 */
type Bwm struct {
	Header *Bwm_BwmHeader
	WalkmeshProperties *Bwm_WalkmeshProperties
	DataTableOffsets *Bwm_DataTableOffsets
	_io *kaitai.Stream
	_root *Bwm
	_parent kaitai.Struct
	_f_aabbNodes bool
	aabbNodes *Bwm_AabbNodesArray
	_f_adjacencies bool
	adjacencies *Bwm_AdjacenciesArray
	_f_edges bool
	edges *Bwm_EdgesArray
	_f_faceIndices bool
	faceIndices *Bwm_FaceIndicesArray
	_f_materials bool
	materials *Bwm_MaterialsArray
	_f_normals bool
	normals *Bwm_NormalsArray
	_f_perimeters bool
	perimeters *Bwm_PerimetersArray
	_f_planarDistances bool
	planarDistances *Bwm_PlanarDistancesArray
	_f_vertices bool
	vertices *Bwm_VerticesArray
}
func NewBwm() *Bwm {
	return &Bwm{
	}
}

func (this Bwm) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm) Read(io *kaitai.Stream, parent kaitai.Struct, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1 := NewBwm_BwmHeader()
	err = tmp1.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Header = tmp1
	tmp2 := NewBwm_WalkmeshProperties()
	err = tmp2.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.WalkmeshProperties = tmp2
	tmp3 := NewBwm_DataTableOffsets()
	err = tmp3.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.DataTableOffsets = tmp3
	return err
}

/**
 * Array of AABB tree nodes for spatial acceleration - WOK only
 */
func (this *Bwm) AabbNodes() (v *Bwm_AabbNodesArray, err error) {
	if (this._f_aabbNodes) {
		return this.aabbNodes, nil
	}
	this._f_aabbNodes = true
	if ( ((this._root.WalkmeshProperties.WalkmeshType == 1) && (this._root.DataTableOffsets.AabbCount > 0)) ) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this._root.DataTableOffsets.AabbOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp4 := NewBwm_AabbNodesArray()
		err = tmp4.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.aabbNodes = tmp4
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.aabbNodes, nil
}

/**
 * Array of adjacency indices (int32 triplets per walkable face) - WOK only
 */
func (this *Bwm) Adjacencies() (v *Bwm_AdjacenciesArray, err error) {
	if (this._f_adjacencies) {
		return this.adjacencies, nil
	}
	this._f_adjacencies = true
	if ( ((this._root.WalkmeshProperties.WalkmeshType == 1) && (this._root.DataTableOffsets.AdjacencyCount > 0)) ) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this._root.DataTableOffsets.AdjacencyOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp5 := NewBwm_AdjacenciesArray()
		err = tmp5.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.adjacencies = tmp5
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.adjacencies, nil
}

/**
 * Array of perimeter edges (edge_index, transition pairs) - WOK only
 */
func (this *Bwm) Edges() (v *Bwm_EdgesArray, err error) {
	if (this._f_edges) {
		return this.edges, nil
	}
	this._f_edges = true
	if ( ((this._root.WalkmeshProperties.WalkmeshType == 1) && (this._root.DataTableOffsets.EdgeCount > 0)) ) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this._root.DataTableOffsets.EdgeOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp6 := NewBwm_EdgesArray()
		err = tmp6.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.edges = tmp6
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.edges, nil
}

/**
 * Array of face vertex indices (uint32 triplets)
 */
func (this *Bwm) FaceIndices() (v *Bwm_FaceIndicesArray, err error) {
	if (this._f_faceIndices) {
		return this.faceIndices, nil
	}
	this._f_faceIndices = true
	if (this._root.DataTableOffsets.FaceCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this._root.DataTableOffsets.FaceIndicesOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp7 := NewBwm_FaceIndicesArray()
		err = tmp7.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.faceIndices = tmp7
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.faceIndices, nil
}

/**
 * Array of surface material IDs per face
 */
func (this *Bwm) Materials() (v *Bwm_MaterialsArray, err error) {
	if (this._f_materials) {
		return this.materials, nil
	}
	this._f_materials = true
	if (this._root.DataTableOffsets.FaceCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this._root.DataTableOffsets.MaterialsOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp8 := NewBwm_MaterialsArray()
		err = tmp8.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.materials = tmp8
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.materials, nil
}

/**
 * Array of face normal vectors (float3 triplets) - WOK only
 */
func (this *Bwm) Normals() (v *Bwm_NormalsArray, err error) {
	if (this._f_normals) {
		return this.normals, nil
	}
	this._f_normals = true
	if ( ((this._root.WalkmeshProperties.WalkmeshType == 1) && (this._root.DataTableOffsets.FaceCount > 0)) ) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this._root.DataTableOffsets.NormalsOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp9 := NewBwm_NormalsArray()
		err = tmp9.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.normals = tmp9
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.normals, nil
}

/**
 * Array of perimeter markers (edge indices marking end of loops) - WOK only
 */
func (this *Bwm) Perimeters() (v *Bwm_PerimetersArray, err error) {
	if (this._f_perimeters) {
		return this.perimeters, nil
	}
	this._f_perimeters = true
	if ( ((this._root.WalkmeshProperties.WalkmeshType == 1) && (this._root.DataTableOffsets.PerimeterCount > 0)) ) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this._root.DataTableOffsets.PerimeterOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp10 := NewBwm_PerimetersArray()
		err = tmp10.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.perimeters = tmp10
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.perimeters, nil
}

/**
 * Array of planar distances (float32 per face) - WOK only
 */
func (this *Bwm) PlanarDistances() (v *Bwm_PlanarDistancesArray, err error) {
	if (this._f_planarDistances) {
		return this.planarDistances, nil
	}
	this._f_planarDistances = true
	if ( ((this._root.WalkmeshProperties.WalkmeshType == 1) && (this._root.DataTableOffsets.FaceCount > 0)) ) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this._root.DataTableOffsets.DistancesOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp11 := NewBwm_PlanarDistancesArray()
		err = tmp11.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.planarDistances = tmp11
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.planarDistances, nil
}

/**
 * Array of vertex positions (float3 triplets)
 */
func (this *Bwm) Vertices() (v *Bwm_VerticesArray, err error) {
	if (this._f_vertices) {
		return this.vertices, nil
	}
	this._f_vertices = true
	if (this._root.DataTableOffsets.VertexCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this._root.DataTableOffsets.VertexOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp12 := NewBwm_VerticesArray()
		err = tmp12.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.vertices = tmp12
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.vertices, nil
}

/**
 * BWM file header (8 bytes) - magic and version signature
 */

/**
 * Walkmesh properties section (52 bytes) - type, hooks, position
 */

/**
 * Data table offsets section (84 bytes) - counts and offsets for all data tables
 */
type Bwm_AabbNode struct {
	BoundsMin *Bwm_Vec3f
	BoundsMax *Bwm_Vec3f
	FaceIndex int32
	Unknown uint32
	MostSignificantPlane uint32
	LeftChildIndex uint32
	RightChildIndex uint32
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm_AabbNodesArray
	_f_hasLeftChild bool
	hasLeftChild bool
	_f_hasRightChild bool
	hasRightChild bool
	_f_isInternalNode bool
	isInternalNode bool
	_f_isLeafNode bool
	isLeafNode bool
}
func NewBwm_AabbNode() *Bwm_AabbNode {
	return &Bwm_AabbNode{
	}
}

func (this Bwm_AabbNode) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_AabbNode) Read(io *kaitai.Stream, parent *Bwm_AabbNodesArray, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp13 := NewBwm_Vec3f()
	err = tmp13.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.BoundsMin = tmp13
	tmp14 := NewBwm_Vec3f()
	err = tmp14.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.BoundsMax = tmp14
	tmp15, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.FaceIndex = int32(tmp15)
	tmp16, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown = uint32(tmp16)
	tmp17, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MostSignificantPlane = uint32(tmp17)
	tmp18, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LeftChildIndex = uint32(tmp18)
	tmp19, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.RightChildIndex = uint32(tmp19)
	return err
}

/**
 * True if this node has a left child
 */
func (this *Bwm_AabbNode) HasLeftChild() (v bool, err error) {
	if (this._f_hasLeftChild) {
		return this.hasLeftChild, nil
	}
	this._f_hasLeftChild = true
	this.hasLeftChild = bool(this.LeftChildIndex != uint32(4294967295))
	return this.hasLeftChild, nil
}

/**
 * True if this node has a right child
 */
func (this *Bwm_AabbNode) HasRightChild() (v bool, err error) {
	if (this._f_hasRightChild) {
		return this.hasRightChild, nil
	}
	this._f_hasRightChild = true
	this.hasRightChild = bool(this.RightChildIndex != uint32(4294967295))
	return this.hasRightChild, nil
}

/**
 * True if this is an internal node (has children), false if leaf node
 */
func (this *Bwm_AabbNode) IsInternalNode() (v bool, err error) {
	if (this._f_isInternalNode) {
		return this.isInternalNode, nil
	}
	this._f_isInternalNode = true
	this.isInternalNode = bool(this.FaceIndex == -1)
	return this.isInternalNode, nil
}

/**
 * True if this is a leaf node (contains a face), false if internal node
 */
func (this *Bwm_AabbNode) IsLeafNode() (v bool, err error) {
	if (this._f_isLeafNode) {
		return this.isLeafNode, nil
	}
	this._f_isLeafNode = true
	this.isLeafNode = bool(this.FaceIndex != -1)
	return this.isLeafNode, nil
}

/**
 * Minimum bounding box coordinates (x, y, z).
 * Defines the lower corner of the axis-aligned bounding box.
 */

/**
 * Maximum bounding box coordinates (x, y, z).
 * Defines the upper corner of the axis-aligned bounding box.
 */

/**
 * Face index for leaf nodes, -1 (0xFFFFFFFF) for internal nodes.
 * Leaf nodes contain a single face, internal nodes contain child nodes.
 */

/**
 * Unknown field (typically 4).
 * Purpose is undocumented but appears in all AABB nodes.
 */

/**
 * Split axis/plane identifier:
 * - 0x00 = No children (leaf node)
 * - 0x01 = Positive X axis split
 * - 0x02 = Positive Y axis split
 * - 0x03 = Positive Z axis split
 * - 0xFFFFFFFE (-2) = Negative X axis split
 * - 0xFFFFFFFD (-3) = Negative Y axis split
 * - 0xFFFFFFFC (-4) = Negative Z axis split
 */

/**
 * Index to left child node (0-based array index).
 * 0xFFFFFFFF indicates no left child.
 * Child indices are 0-based indices into the AABB nodes array.
 */

/**
 * Index to right child node (0-based array index).
 * 0xFFFFFFFF indicates no right child.
 * Child indices are 0-based indices into the AABB nodes array.
 */
type Bwm_AabbNodesArray struct {
	Nodes []*Bwm_AabbNode
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
}
func NewBwm_AabbNodesArray() *Bwm_AabbNodesArray {
	return &Bwm_AabbNodesArray{
	}
}

func (this Bwm_AabbNodesArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_AabbNodesArray) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.DataTableOffsets.AabbCount); i++ {
		_ = i
		tmp20 := NewBwm_AabbNode()
		err = tmp20.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Nodes = append(this.Nodes, tmp20)
	}
	return err
}

/**
 * Array of AABB tree nodes for spatial acceleration (WOK only).
 * AABB trees enable efficient raycasting and point queries (O(log N) vs O(N)).
 */
type Bwm_AdjacenciesArray struct {
	Adjacencies []*Bwm_AdjacencyTriplet
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
}
func NewBwm_AdjacenciesArray() *Bwm_AdjacenciesArray {
	return &Bwm_AdjacenciesArray{
	}
}

func (this Bwm_AdjacenciesArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_AdjacenciesArray) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.DataTableOffsets.AdjacencyCount); i++ {
		_ = i
		tmp21 := NewBwm_AdjacencyTriplet()
		err = tmp21.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Adjacencies = append(this.Adjacencies, tmp21)
	}
	return err
}

/**
 * Array of adjacency triplets, one per walkable face (WOK only).
 * Each walkable face has exactly three adjacency entries, one for each edge.
 * Adjacency count equals the number of walkable faces, not the total face count.
 */
type Bwm_AdjacencyTriplet struct {
	Edge0Adjacency int32
	Edge1Adjacency int32
	Edge2Adjacency int32
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm_AdjacenciesArray
	_f_edge0FaceIndex bool
	edge0FaceIndex int
	_f_edge0HasNeighbor bool
	edge0HasNeighbor bool
	_f_edge0LocalEdge bool
	edge0LocalEdge int
	_f_edge1FaceIndex bool
	edge1FaceIndex int
	_f_edge1HasNeighbor bool
	edge1HasNeighbor bool
	_f_edge1LocalEdge bool
	edge1LocalEdge int
	_f_edge2FaceIndex bool
	edge2FaceIndex int
	_f_edge2HasNeighbor bool
	edge2HasNeighbor bool
	_f_edge2LocalEdge bool
	edge2LocalEdge int
}
func NewBwm_AdjacencyTriplet() *Bwm_AdjacencyTriplet {
	return &Bwm_AdjacencyTriplet{
	}
}

func (this Bwm_AdjacencyTriplet) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_AdjacencyTriplet) Read(io *kaitai.Stream, parent *Bwm_AdjacenciesArray, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp22, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.Edge0Adjacency = int32(tmp22)
	tmp23, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.Edge1Adjacency = int32(tmp23)
	tmp24, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.Edge2Adjacency = int32(tmp24)
	return err
}

/**
 * Face index of adjacent face for edge 0 (decoded from adjacency index)
 */
func (this *Bwm_AdjacencyTriplet) Edge0FaceIndex() (v int, err error) {
	if (this._f_edge0FaceIndex) {
		return this.edge0FaceIndex, nil
	}
	this._f_edge0FaceIndex = true
	var tmp25 int;
	if (this.Edge0Adjacency != -1) {
		tmp25 = this.Edge0Adjacency / 3
	} else {
		tmp25 = -1
	}
	this.edge0FaceIndex = int(tmp25)
	return this.edge0FaceIndex, nil
}

/**
 * True if edge 0 has an adjacent walkable face
 */
func (this *Bwm_AdjacencyTriplet) Edge0HasNeighbor() (v bool, err error) {
	if (this._f_edge0HasNeighbor) {
		return this.edge0HasNeighbor, nil
	}
	this._f_edge0HasNeighbor = true
	this.edge0HasNeighbor = bool(this.Edge0Adjacency != -1)
	return this.edge0HasNeighbor, nil
}

/**
 * Local edge index (0, 1, or 2) of adjacent face for edge 0
 */
func (this *Bwm_AdjacencyTriplet) Edge0LocalEdge() (v int, err error) {
	if (this._f_edge0LocalEdge) {
		return this.edge0LocalEdge, nil
	}
	this._f_edge0LocalEdge = true
	var tmp26 int;
	if (this.Edge0Adjacency != -1) {
		tmp27 := this.Edge0Adjacency % 3
		if tmp27 < 0 {
			tmp27 += 3
		}
		tmp26 = tmp27
	} else {
		tmp26 = -1
	}
	this.edge0LocalEdge = int(tmp26)
	return this.edge0LocalEdge, nil
}

/**
 * Face index of adjacent face for edge 1 (decoded from adjacency index)
 */
func (this *Bwm_AdjacencyTriplet) Edge1FaceIndex() (v int, err error) {
	if (this._f_edge1FaceIndex) {
		return this.edge1FaceIndex, nil
	}
	this._f_edge1FaceIndex = true
	var tmp28 int;
	if (this.Edge1Adjacency != -1) {
		tmp28 = this.Edge1Adjacency / 3
	} else {
		tmp28 = -1
	}
	this.edge1FaceIndex = int(tmp28)
	return this.edge1FaceIndex, nil
}

/**
 * True if edge 1 has an adjacent walkable face
 */
func (this *Bwm_AdjacencyTriplet) Edge1HasNeighbor() (v bool, err error) {
	if (this._f_edge1HasNeighbor) {
		return this.edge1HasNeighbor, nil
	}
	this._f_edge1HasNeighbor = true
	this.edge1HasNeighbor = bool(this.Edge1Adjacency != -1)
	return this.edge1HasNeighbor, nil
}

/**
 * Local edge index (0, 1, or 2) of adjacent face for edge 1
 */
func (this *Bwm_AdjacencyTriplet) Edge1LocalEdge() (v int, err error) {
	if (this._f_edge1LocalEdge) {
		return this.edge1LocalEdge, nil
	}
	this._f_edge1LocalEdge = true
	var tmp29 int;
	if (this.Edge1Adjacency != -1) {
		tmp30 := this.Edge1Adjacency % 3
		if tmp30 < 0 {
			tmp30 += 3
		}
		tmp29 = tmp30
	} else {
		tmp29 = -1
	}
	this.edge1LocalEdge = int(tmp29)
	return this.edge1LocalEdge, nil
}

/**
 * Face index of adjacent face for edge 2 (decoded from adjacency index)
 */
func (this *Bwm_AdjacencyTriplet) Edge2FaceIndex() (v int, err error) {
	if (this._f_edge2FaceIndex) {
		return this.edge2FaceIndex, nil
	}
	this._f_edge2FaceIndex = true
	var tmp31 int;
	if (this.Edge2Adjacency != -1) {
		tmp31 = this.Edge2Adjacency / 3
	} else {
		tmp31 = -1
	}
	this.edge2FaceIndex = int(tmp31)
	return this.edge2FaceIndex, nil
}

/**
 * True if edge 2 has an adjacent walkable face
 */
func (this *Bwm_AdjacencyTriplet) Edge2HasNeighbor() (v bool, err error) {
	if (this._f_edge2HasNeighbor) {
		return this.edge2HasNeighbor, nil
	}
	this._f_edge2HasNeighbor = true
	this.edge2HasNeighbor = bool(this.Edge2Adjacency != -1)
	return this.edge2HasNeighbor, nil
}

/**
 * Local edge index (0, 1, or 2) of adjacent face for edge 2
 */
func (this *Bwm_AdjacencyTriplet) Edge2LocalEdge() (v int, err error) {
	if (this._f_edge2LocalEdge) {
		return this.edge2LocalEdge, nil
	}
	this._f_edge2LocalEdge = true
	var tmp32 int;
	if (this.Edge2Adjacency != -1) {
		tmp33 := this.Edge2Adjacency % 3
		if tmp33 < 0 {
			tmp33 += 3
		}
		tmp32 = tmp33
	} else {
		tmp32 = -1
	}
	this.edge2LocalEdge = int(tmp32)
	return this.edge2LocalEdge, nil
}

/**
 * Adjacency index for edge 0 (between v1 and v2).
 * Encoding: face_index * 3 + edge_index
 * -1 (0xFFFFFFFF) indicates no adjacent walkable face (boundary edge).
 */

/**
 * Adjacency index for edge 1 (between v2 and v3).
 * Encoding: face_index * 3 + edge_index
 * -1 (0xFFFFFFFF) indicates no adjacent walkable face (boundary edge).
 */

/**
 * Adjacency index for edge 2 (between v3 and v1).
 * Encoding: face_index * 3 + edge_index
 * -1 (0xFFFFFFFF) indicates no adjacent walkable face (boundary edge).
 */
type Bwm_BwmHeader struct {
	Magic string
	Version string
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
	_f_isValidBwm bool
	isValidBwm bool
}
func NewBwm_BwmHeader() *Bwm_BwmHeader {
	return &Bwm_BwmHeader{
	}
}

func (this Bwm_BwmHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_BwmHeader) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp34, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp34 = tmp34
	this.Magic = string(tmp34)
	tmp35, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp35 = tmp35
	this.Version = string(tmp35)
	return err
}

/**
 * Validation check that the file is a valid BWM file.
 * Both magic and version must match expected values.
 */
func (this *Bwm_BwmHeader) IsValidBwm() (v bool, err error) {
	if (this._f_isValidBwm) {
		return this.isValidBwm, nil
	}
	this._f_isValidBwm = true
	this.isValidBwm = bool( ((this.Magic == "BWM ") && (this.Version == "V1.0")) )
	return this.isValidBwm, nil
}

/**
 * File type signature. Must be "BWM " (space-padded).
 * The space after "BWM" is significant and must be present.
 */

/**
 * File format version. Always "V1.0" for KotOR BWM files.
 * This is the first and only version of the BWM format used in KotOR games.
 */
type Bwm_DataTableOffsets struct {
	VertexCount uint32
	VertexOffset uint32
	FaceCount uint32
	FaceIndicesOffset uint32
	MaterialsOffset uint32
	NormalsOffset uint32
	DistancesOffset uint32
	AabbCount uint32
	AabbOffset uint32
	Unknown uint32
	AdjacencyCount uint32
	AdjacencyOffset uint32
	EdgeCount uint32
	EdgeOffset uint32
	PerimeterCount uint32
	PerimeterOffset uint32
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
}
func NewBwm_DataTableOffsets() *Bwm_DataTableOffsets {
	return &Bwm_DataTableOffsets{
	}
}

func (this Bwm_DataTableOffsets) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_DataTableOffsets) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp36, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.VertexCount = uint32(tmp36)
	tmp37, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.VertexOffset = uint32(tmp37)
	tmp38, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FaceCount = uint32(tmp38)
	tmp39, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FaceIndicesOffset = uint32(tmp39)
	tmp40, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MaterialsOffset = uint32(tmp40)
	tmp41, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NormalsOffset = uint32(tmp41)
	tmp42, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.DistancesOffset = uint32(tmp42)
	tmp43, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.AabbCount = uint32(tmp43)
	tmp44, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.AabbOffset = uint32(tmp44)
	tmp45, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Unknown = uint32(tmp45)
	tmp46, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.AdjacencyCount = uint32(tmp46)
	tmp47, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.AdjacencyOffset = uint32(tmp47)
	tmp48, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.EdgeCount = uint32(tmp48)
	tmp49, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.EdgeOffset = uint32(tmp49)
	tmp50, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.PerimeterCount = uint32(tmp50)
	tmp51, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.PerimeterOffset = uint32(tmp51)
	return err
}

/**
 * Number of vertices in the walkmesh
 */

/**
 * Byte offset to vertex array from the beginning of the file
 */

/**
 * Number of faces (triangles) in the walkmesh
 */

/**
 * Byte offset to face indices array from the beginning of the file
 */

/**
 * Byte offset to materials array from the beginning of the file
 */

/**
 * Byte offset to face normals array from the beginning of the file.
 * Only used for WOK files (area walkmeshes).
 */

/**
 * Byte offset to planar distances array from the beginning of the file.
 * Only used for WOK files (area walkmeshes).
 */

/**
 * Number of AABB tree nodes (WOK only, 0 for PWK/DWK).
 * AABB trees provide spatial acceleration for raycasting and point queries.
 */

/**
 * Byte offset to AABB tree nodes array from the beginning of the file (WOK only).
 * Only present if aabb_count > 0.
 */

/**
 * Unknown field (typically 0 or 4).
 * Purpose is undocumented but appears in all BWM files.
 */

/**
 * Number of walkable faces for adjacency data (WOK only).
 * This equals the number of walkable faces, not the total face count.
 * Adjacencies are stored only for walkable faces.
 */

/**
 * Byte offset to adjacency array from the beginning of the file (WOK only).
 * Only present if adjacency_count > 0.
 */

/**
 * Number of perimeter edges (WOK only).
 * Perimeter edges are boundary edges with no walkable neighbor.
 */

/**
 * Byte offset to edges array from the beginning of the file (WOK only).
 * Only present if edge_count > 0.
 */

/**
 * Number of perimeter markers (WOK only).
 * Perimeter markers indicate the end of closed loops of perimeter edges.
 */

/**
 * Byte offset to perimeters array from the beginning of the file (WOK only).
 * Only present if perimeter_count > 0.
 */
type Bwm_EdgeEntry struct {
	EdgeIndex uint32
	Transition int32
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm_EdgesArray
	_f_faceIndex bool
	faceIndex int
	_f_hasTransition bool
	hasTransition bool
	_f_localEdgeIndex bool
	localEdgeIndex int
}
func NewBwm_EdgeEntry() *Bwm_EdgeEntry {
	return &Bwm_EdgeEntry{
	}
}

func (this Bwm_EdgeEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_EdgeEntry) Read(io *kaitai.Stream, parent *Bwm_EdgesArray, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp52, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.EdgeIndex = uint32(tmp52)
	tmp53, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.Transition = int32(tmp53)
	return err
}

/**
 * Face index that this edge belongs to (decoded from edge_index)
 */
func (this *Bwm_EdgeEntry) FaceIndex() (v int, err error) {
	if (this._f_faceIndex) {
		return this.faceIndex, nil
	}
	this._f_faceIndex = true
	this.faceIndex = int(this.EdgeIndex / 3)
	return this.faceIndex, nil
}

/**
 * True if this edge has a transition ID (links to door/area connection)
 */
func (this *Bwm_EdgeEntry) HasTransition() (v bool, err error) {
	if (this._f_hasTransition) {
		return this.hasTransition, nil
	}
	this._f_hasTransition = true
	this.hasTransition = bool(this.Transition != -1)
	return this.hasTransition, nil
}

/**
 * Local edge index (0, 1, or 2) within the face (decoded from edge_index)
 */
func (this *Bwm_EdgeEntry) LocalEdgeIndex() (v int, err error) {
	if (this._f_localEdgeIndex) {
		return this.localEdgeIndex, nil
	}
	this._f_localEdgeIndex = true
	tmp54 := this.EdgeIndex % 3
	if tmp54 < 0 {
		tmp54 += 3
	}
	this.localEdgeIndex = int(tmp54)
	return this.localEdgeIndex, nil
}

/**
 * Encoded edge index: face_index * 3 + local_edge_index
 * Identifies which face and which edge (0, 1, or 2) of that face.
 * Edge 0: between v1 and v2
 * Edge 1: between v2 and v3
 * Edge 2: between v3 and v1
 */

/**
 * Transition ID for room/area connections, -1 if no transition.
 * Non-negative values reference door connections or area boundaries.
 * -1 indicates this is just a boundary edge with no transition.
 */
type Bwm_EdgesArray struct {
	Edges []*Bwm_EdgeEntry
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
}
func NewBwm_EdgesArray() *Bwm_EdgesArray {
	return &Bwm_EdgesArray{
	}
}

func (this Bwm_EdgesArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_EdgesArray) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.DataTableOffsets.EdgeCount); i++ {
		_ = i
		tmp55 := NewBwm_EdgeEntry()
		err = tmp55.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Edges = append(this.Edges, tmp55)
	}
	return err
}

/**
 * Array of perimeter edges (WOK only).
 * Perimeter edges are boundary edges with no walkable neighbor.
 * Each edge entry contains an edge index and optional transition ID.
 */
type Bwm_FaceIndices struct {
	V1Index uint32
	V2Index uint32
	V3Index uint32
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm_FaceIndicesArray
}
func NewBwm_FaceIndices() *Bwm_FaceIndices {
	return &Bwm_FaceIndices{
	}
}

func (this Bwm_FaceIndices) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_FaceIndices) Read(io *kaitai.Stream, parent *Bwm_FaceIndicesArray, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp56, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.V1Index = uint32(tmp56)
	tmp57, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.V2Index = uint32(tmp57)
	tmp58, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.V3Index = uint32(tmp58)
	return err
}

/**
 * Vertex index for first vertex of triangle (0-based index into vertices array).
 * Vertex indices define the triangle's vertices in counter-clockwise order
 * when viewed from the front (the side the normal points toward).
 */

/**
 * Vertex index for second vertex of triangle (0-based index into vertices array).
 */

/**
 * Vertex index for third vertex of triangle (0-based index into vertices array).
 */
type Bwm_FaceIndicesArray struct {
	Faces []*Bwm_FaceIndices
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
}
func NewBwm_FaceIndicesArray() *Bwm_FaceIndicesArray {
	return &Bwm_FaceIndicesArray{
	}
}

func (this Bwm_FaceIndicesArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_FaceIndicesArray) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.DataTableOffsets.FaceCount); i++ {
		_ = i
		tmp59 := NewBwm_FaceIndices()
		err = tmp59.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Faces = append(this.Faces, tmp59)
	}
	return err
}

/**
 * Array of face vertex index triplets
 */
type Bwm_MaterialsArray struct {
	Materials []uint32
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
}
func NewBwm_MaterialsArray() *Bwm_MaterialsArray {
	return &Bwm_MaterialsArray{
	}
}

func (this Bwm_MaterialsArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_MaterialsArray) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.DataTableOffsets.FaceCount); i++ {
		_ = i
		tmp60, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.Materials = append(this.Materials, tmp60)
	}
	return err
}

/**
 * Array of surface material IDs, one per face.
 * Material IDs determine walkability and physical properties:
 * - 0 = NotDefined/UNDEFINED (non-walkable)
 * - 1 = Dirt (walkable)
 * - 2 = Obscuring (non-walkable, blocks line of sight)
 * - 3 = Grass (walkable)
 * - 4 = Stone (walkable)
 * - 5 = Wood (walkable)
 * - 6 = Water (walkable)
 * - 7 = Nonwalk/NON_WALK (non-walkable)
 * - 8 = Transparent (non-walkable)
 * - 9 = Carpet (walkable)
 * - 10 = Metal (walkable)
 * - 11 = Puddles (walkable)
 * - 12 = Swamp (walkable)
 * - 13 = Mud (walkable)
 * - 14 = Leaves (walkable)
 * - 15 = Lava (non-walkable, damage-dealing)
 * - 16 = BottomlessPit (walkable but dangerous)
 * - 17 = DeepWater (non-walkable)
 * - 18 = Door (walkable, special handling)
 * - 19 = Snow/NON_WALK_GRASS (non-walkable)
 * - 20+ = Additional materials (Sand, BareBones, StoneBridge, etc.)
 */
type Bwm_NormalsArray struct {
	Normals []*Bwm_Vec3f
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
}
func NewBwm_NormalsArray() *Bwm_NormalsArray {
	return &Bwm_NormalsArray{
	}
}

func (this Bwm_NormalsArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_NormalsArray) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.DataTableOffsets.FaceCount); i++ {
		_ = i
		tmp61 := NewBwm_Vec3f()
		err = tmp61.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Normals = append(this.Normals, tmp61)
	}
	return err
}

/**
 * Array of face normal vectors, one per face (WOK only).
 * Normals are precomputed unit vectors perpendicular to each face.
 * Calculated using cross product: normal = normalize((v2 - v1) × (v3 - v1)).
 * Normal direction follows right-hand rule based on vertex winding order.
 */
type Bwm_PerimetersArray struct {
	Perimeters []uint32
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
}
func NewBwm_PerimetersArray() *Bwm_PerimetersArray {
	return &Bwm_PerimetersArray{
	}
}

func (this Bwm_PerimetersArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_PerimetersArray) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.DataTableOffsets.PerimeterCount); i++ {
		_ = i
		tmp62, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.Perimeters = append(this.Perimeters, tmp62)
	}
	return err
}

/**
 * Array of perimeter markers (WOK only).
 * Each value is an index into the edges array, marking the end of a perimeter loop.
 * Perimeter loops are closed chains of perimeter edges forming walkable boundaries.
 * Values are typically 1-based (marking end of loop), but may be 0-based depending on implementation.
 */
type Bwm_PlanarDistancesArray struct {
	Distances []float32
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
}
func NewBwm_PlanarDistancesArray() *Bwm_PlanarDistancesArray {
	return &Bwm_PlanarDistancesArray{
	}
}

func (this Bwm_PlanarDistancesArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_PlanarDistancesArray) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.DataTableOffsets.FaceCount); i++ {
		_ = i
		tmp63, err := this._io.ReadF4le()
		if err != nil {
			return err
		}
		this.Distances = append(this.Distances, tmp63)
	}
	return err
}

/**
 * Array of planar distances, one per face (WOK only).
 * The D component of the plane equation ax + by + cz + d = 0.
 * Calculated as d = -normal · vertex1 for each face.
 * Precomputed to allow quick point-plane relationship tests.
 */
type Bwm_Vec3f struct {
	X float32
	Y float32
	Z float32
	_io *kaitai.Stream
	_root *Bwm
	_parent kaitai.Struct
}
func NewBwm_Vec3f() *Bwm_Vec3f {
	return &Bwm_Vec3f{
	}
}

func (this Bwm_Vec3f) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_Vec3f) Read(io *kaitai.Stream, parent kaitai.Struct, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp64, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.X = float32(tmp64)
	tmp65, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Y = float32(tmp65)
	tmp66, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.Z = float32(tmp66)
	return err
}

/**
 * X coordinate (float32)
 */

/**
 * Y coordinate (float32)
 */

/**
 * Z coordinate (float32)
 */
type Bwm_VerticesArray struct {
	Vertices []*Bwm_Vec3f
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
}
func NewBwm_VerticesArray() *Bwm_VerticesArray {
	return &Bwm_VerticesArray{
	}
}

func (this Bwm_VerticesArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_VerticesArray) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.DataTableOffsets.VertexCount); i++ {
		_ = i
		tmp67 := NewBwm_Vec3f()
		err = tmp67.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Vertices = append(this.Vertices, tmp67)
	}
	return err
}

/**
 * Array of vertex positions, each vertex is a float3 (x, y, z)
 */
type Bwm_WalkmeshProperties struct {
	WalkmeshType uint32
	RelativeUsePosition1 *Bwm_Vec3f
	RelativeUsePosition2 *Bwm_Vec3f
	AbsoluteUsePosition1 *Bwm_Vec3f
	AbsoluteUsePosition2 *Bwm_Vec3f
	Position *Bwm_Vec3f
	_io *kaitai.Stream
	_root *Bwm
	_parent *Bwm
	_f_isAreaWalkmesh bool
	isAreaWalkmesh bool
	_f_isPlaceableOrDoor bool
	isPlaceableOrDoor bool
}
func NewBwm_WalkmeshProperties() *Bwm_WalkmeshProperties {
	return &Bwm_WalkmeshProperties{
	}
}

func (this Bwm_WalkmeshProperties) IO_() *kaitai.Stream {
	return this._io
}

func (this *Bwm_WalkmeshProperties) Read(io *kaitai.Stream, parent *Bwm, root *Bwm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp68, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.WalkmeshType = uint32(tmp68)
	tmp69 := NewBwm_Vec3f()
	err = tmp69.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.RelativeUsePosition1 = tmp69
	tmp70 := NewBwm_Vec3f()
	err = tmp70.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.RelativeUsePosition2 = tmp70
	tmp71 := NewBwm_Vec3f()
	err = tmp71.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.AbsoluteUsePosition1 = tmp71
	tmp72 := NewBwm_Vec3f()
	err = tmp72.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.AbsoluteUsePosition2 = tmp72
	tmp73 := NewBwm_Vec3f()
	err = tmp73.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Position = tmp73
	return err
}

/**
 * True if this is an area walkmesh (WOK), false if placeable/door (PWK/DWK)
 */
func (this *Bwm_WalkmeshProperties) IsAreaWalkmesh() (v bool, err error) {
	if (this._f_isAreaWalkmesh) {
		return this.isAreaWalkmesh, nil
	}
	this._f_isAreaWalkmesh = true
	this.isAreaWalkmesh = bool(this.WalkmeshType == 1)
	return this.isAreaWalkmesh, nil
}

/**
 * True if this is a placeable or door walkmesh (PWK/DWK)
 */
func (this *Bwm_WalkmeshProperties) IsPlaceableOrDoor() (v bool, err error) {
	if (this._f_isPlaceableOrDoor) {
		return this.isPlaceableOrDoor, nil
	}
	this._f_isPlaceableOrDoor = true
	this.isPlaceableOrDoor = bool(this.WalkmeshType == 0)
	return this.isPlaceableOrDoor, nil
}

/**
 * Walkmesh type identifier:
 * - 0 = PWK/DWK (Placeable/Door walkmesh)
 * - 1 = WOK (Area walkmesh)
 */

/**
 * Relative use hook position 1 (x, y, z).
 * Position relative to the walkmesh origin, used when the walkmesh may be transformed.
 * For doors: Defines where the player must stand to interact (relative to door model).
 * For placeables: Defines interaction points relative to the object's local coordinate system.
 */

/**
 * Relative use hook position 2 (x, y, z).
 * Second interaction point relative to the walkmesh origin.
 */

/**
 * Absolute use hook position 1 (x, y, z).
 * Position in world space, used when the walkmesh position is known.
 * For doors: Precomputed world-space interaction points (position + relative hook).
 * For placeables: World-space interaction points accounting for object placement.
 */

/**
 * Absolute use hook position 2 (x, y, z).
 * Second absolute interaction point in world space.
 */

/**
 * Walkmesh position offset (x, y, z) in world space.
 * For area walkmeshes (WOK): Typically (0, 0, 0) as areas define their own coordinate system.
 * For placeable/door walkmeshes: The position where the object is placed in the area.
 * Used to transform vertices from local to world coordinates.
 */
