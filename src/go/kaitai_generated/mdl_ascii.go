// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"


/**
 * MDL ASCII format is a human-readable ASCII text representation of MDL (Model) binary files.
 * Used by modding tools for easier editing than binary MDL format.
 * 
 * The ASCII format represents the model structure using plain text with keyword-based syntax.
 * Lines are parsed sequentially, with keywords indicating sections, nodes, properties, and data arrays.
 * 
 * Reference: https://github.com/OldRepublicDevs/PyKotor/wiki/MDL-MDX-File-Format.md - ASCII MDL Format section
 * Reference: https://github.com/OldRepublicDevs/PyKotor/blob/master/vendor/MDLOps/MDLOpsM.pm:3916-4698 - readasciimdl function implementation
 * @see <a href="https://github.com/th3w1zard1/PyKotor/wiki/MDL-MDX-File-Format.md#ascii-mdl-format">Source</a>
 */

type MdlAscii_ControllerTypeCommon int
const (
	MdlAscii_ControllerTypeCommon__Position MdlAscii_ControllerTypeCommon = 8
	MdlAscii_ControllerTypeCommon__Orientation MdlAscii_ControllerTypeCommon = 20
	MdlAscii_ControllerTypeCommon__Scale MdlAscii_ControllerTypeCommon = 36
	MdlAscii_ControllerTypeCommon__Alpha MdlAscii_ControllerTypeCommon = 132
)
var values_MdlAscii_ControllerTypeCommon = map[MdlAscii_ControllerTypeCommon]struct{}{8: {}, 20: {}, 36: {}, 132: {}}
func (v MdlAscii_ControllerTypeCommon) isDefined() bool {
	_, ok := values_MdlAscii_ControllerTypeCommon[v]
	return ok
}

type MdlAscii_ControllerTypeEmitter int
const (
	MdlAscii_ControllerTypeEmitter__AlphaEnd MdlAscii_ControllerTypeEmitter = 80
	MdlAscii_ControllerTypeEmitter__AlphaStart MdlAscii_ControllerTypeEmitter = 84
	MdlAscii_ControllerTypeEmitter__Birthrate MdlAscii_ControllerTypeEmitter = 88
	MdlAscii_ControllerTypeEmitter__BounceCo MdlAscii_ControllerTypeEmitter = 92
	MdlAscii_ControllerTypeEmitter__Combinetime MdlAscii_ControllerTypeEmitter = 96
	MdlAscii_ControllerTypeEmitter__Drag MdlAscii_ControllerTypeEmitter = 100
	MdlAscii_ControllerTypeEmitter__Fps MdlAscii_ControllerTypeEmitter = 104
	MdlAscii_ControllerTypeEmitter__FrameEnd MdlAscii_ControllerTypeEmitter = 108
	MdlAscii_ControllerTypeEmitter__FrameStart MdlAscii_ControllerTypeEmitter = 112
	MdlAscii_ControllerTypeEmitter__Grav MdlAscii_ControllerTypeEmitter = 116
	MdlAscii_ControllerTypeEmitter__LifeExp MdlAscii_ControllerTypeEmitter = 120
	MdlAscii_ControllerTypeEmitter__Mass MdlAscii_ControllerTypeEmitter = 124
	MdlAscii_ControllerTypeEmitter__P2pBezier2 MdlAscii_ControllerTypeEmitter = 128
	MdlAscii_ControllerTypeEmitter__P2pBezier3 MdlAscii_ControllerTypeEmitter = 132
	MdlAscii_ControllerTypeEmitter__ParticleRot MdlAscii_ControllerTypeEmitter = 136
	MdlAscii_ControllerTypeEmitter__Randvel MdlAscii_ControllerTypeEmitter = 140
	MdlAscii_ControllerTypeEmitter__SizeStart MdlAscii_ControllerTypeEmitter = 144
	MdlAscii_ControllerTypeEmitter__SizeEnd MdlAscii_ControllerTypeEmitter = 148
	MdlAscii_ControllerTypeEmitter__SizeStartY MdlAscii_ControllerTypeEmitter = 152
	MdlAscii_ControllerTypeEmitter__SizeEndY MdlAscii_ControllerTypeEmitter = 156
	MdlAscii_ControllerTypeEmitter__Spread MdlAscii_ControllerTypeEmitter = 160
	MdlAscii_ControllerTypeEmitter__Threshold MdlAscii_ControllerTypeEmitter = 164
	MdlAscii_ControllerTypeEmitter__Velocity MdlAscii_ControllerTypeEmitter = 168
	MdlAscii_ControllerTypeEmitter__Xsize MdlAscii_ControllerTypeEmitter = 172
	MdlAscii_ControllerTypeEmitter__Ysize MdlAscii_ControllerTypeEmitter = 176
	MdlAscii_ControllerTypeEmitter__Blurlength MdlAscii_ControllerTypeEmitter = 180
	MdlAscii_ControllerTypeEmitter__LightningDelay MdlAscii_ControllerTypeEmitter = 184
	MdlAscii_ControllerTypeEmitter__LightningRadius MdlAscii_ControllerTypeEmitter = 188
	MdlAscii_ControllerTypeEmitter__LightningScale MdlAscii_ControllerTypeEmitter = 192
	MdlAscii_ControllerTypeEmitter__LightningSubDiv MdlAscii_ControllerTypeEmitter = 196
	MdlAscii_ControllerTypeEmitter__Lightningzigzag MdlAscii_ControllerTypeEmitter = 200
	MdlAscii_ControllerTypeEmitter__AlphaMid MdlAscii_ControllerTypeEmitter = 216
	MdlAscii_ControllerTypeEmitter__PercentStart MdlAscii_ControllerTypeEmitter = 220
	MdlAscii_ControllerTypeEmitter__PercentMid MdlAscii_ControllerTypeEmitter = 224
	MdlAscii_ControllerTypeEmitter__PercentEnd MdlAscii_ControllerTypeEmitter = 228
	MdlAscii_ControllerTypeEmitter__SizeMid MdlAscii_ControllerTypeEmitter = 232
	MdlAscii_ControllerTypeEmitter__SizeMidY MdlAscii_ControllerTypeEmitter = 236
	MdlAscii_ControllerTypeEmitter__MFRandomBirthRate MdlAscii_ControllerTypeEmitter = 240
	MdlAscii_ControllerTypeEmitter__Targetsize MdlAscii_ControllerTypeEmitter = 252
	MdlAscii_ControllerTypeEmitter__Numcontrolpts MdlAscii_ControllerTypeEmitter = 256
	MdlAscii_ControllerTypeEmitter__Controlptradius MdlAscii_ControllerTypeEmitter = 260
	MdlAscii_ControllerTypeEmitter__Controlptdelay MdlAscii_ControllerTypeEmitter = 264
	MdlAscii_ControllerTypeEmitter__Tangentspread MdlAscii_ControllerTypeEmitter = 268
	MdlAscii_ControllerTypeEmitter__Tangentlength MdlAscii_ControllerTypeEmitter = 272
	MdlAscii_ControllerTypeEmitter__ColorMid MdlAscii_ControllerTypeEmitter = 284
	MdlAscii_ControllerTypeEmitter__ColorEnd MdlAscii_ControllerTypeEmitter = 380
	MdlAscii_ControllerTypeEmitter__ColorStart MdlAscii_ControllerTypeEmitter = 392
	MdlAscii_ControllerTypeEmitter__Detonate MdlAscii_ControllerTypeEmitter = 502
)
var values_MdlAscii_ControllerTypeEmitter = map[MdlAscii_ControllerTypeEmitter]struct{}{80: {}, 84: {}, 88: {}, 92: {}, 96: {}, 100: {}, 104: {}, 108: {}, 112: {}, 116: {}, 120: {}, 124: {}, 128: {}, 132: {}, 136: {}, 140: {}, 144: {}, 148: {}, 152: {}, 156: {}, 160: {}, 164: {}, 168: {}, 172: {}, 176: {}, 180: {}, 184: {}, 188: {}, 192: {}, 196: {}, 200: {}, 216: {}, 220: {}, 224: {}, 228: {}, 232: {}, 236: {}, 240: {}, 252: {}, 256: {}, 260: {}, 264: {}, 268: {}, 272: {}, 284: {}, 380: {}, 392: {}, 502: {}}
func (v MdlAscii_ControllerTypeEmitter) isDefined() bool {
	_, ok := values_MdlAscii_ControllerTypeEmitter[v]
	return ok
}

type MdlAscii_ControllerTypeLight int
const (
	MdlAscii_ControllerTypeLight__Color MdlAscii_ControllerTypeLight = 76
	MdlAscii_ControllerTypeLight__Radius MdlAscii_ControllerTypeLight = 88
	MdlAscii_ControllerTypeLight__Shadowradius MdlAscii_ControllerTypeLight = 96
	MdlAscii_ControllerTypeLight__Verticaldisplacement MdlAscii_ControllerTypeLight = 100
	MdlAscii_ControllerTypeLight__Multiplier MdlAscii_ControllerTypeLight = 140
)
var values_MdlAscii_ControllerTypeLight = map[MdlAscii_ControllerTypeLight]struct{}{76: {}, 88: {}, 96: {}, 100: {}, 140: {}}
func (v MdlAscii_ControllerTypeLight) isDefined() bool {
	_, ok := values_MdlAscii_ControllerTypeLight[v]
	return ok
}

type MdlAscii_ControllerTypeMesh int
const (
	MdlAscii_ControllerTypeMesh__Selfillumcolor MdlAscii_ControllerTypeMesh = 100
)
var values_MdlAscii_ControllerTypeMesh = map[MdlAscii_ControllerTypeMesh]struct{}{100: {}}
func (v MdlAscii_ControllerTypeMesh) isDefined() bool {
	_, ok := values_MdlAscii_ControllerTypeMesh[v]
	return ok
}

type MdlAscii_ModelClassification int
const (
	MdlAscii_ModelClassification__Other MdlAscii_ModelClassification = 0
	MdlAscii_ModelClassification__Effect MdlAscii_ModelClassification = 1
	MdlAscii_ModelClassification__Tile MdlAscii_ModelClassification = 2
	MdlAscii_ModelClassification__Character MdlAscii_ModelClassification = 4
	MdlAscii_ModelClassification__Door MdlAscii_ModelClassification = 8
	MdlAscii_ModelClassification__Lightsaber MdlAscii_ModelClassification = 16
	MdlAscii_ModelClassification__Placeable MdlAscii_ModelClassification = 32
	MdlAscii_ModelClassification__Flyer MdlAscii_ModelClassification = 64
)
var values_MdlAscii_ModelClassification = map[MdlAscii_ModelClassification]struct{}{0: {}, 1: {}, 2: {}, 4: {}, 8: {}, 16: {}, 32: {}, 64: {}}
func (v MdlAscii_ModelClassification) isDefined() bool {
	_, ok := values_MdlAscii_ModelClassification[v]
	return ok
}

type MdlAscii_NodeType int
const (
	MdlAscii_NodeType__Dummy MdlAscii_NodeType = 1
	MdlAscii_NodeType__Light MdlAscii_NodeType = 3
	MdlAscii_NodeType__Emitter MdlAscii_NodeType = 5
	MdlAscii_NodeType__Reference MdlAscii_NodeType = 17
	MdlAscii_NodeType__Trimesh MdlAscii_NodeType = 33
	MdlAscii_NodeType__Skinmesh MdlAscii_NodeType = 97
	MdlAscii_NodeType__Animmesh MdlAscii_NodeType = 161
	MdlAscii_NodeType__Danglymesh MdlAscii_NodeType = 289
	MdlAscii_NodeType__Aabb MdlAscii_NodeType = 545
	MdlAscii_NodeType__Lightsaber MdlAscii_NodeType = 2081
)
var values_MdlAscii_NodeType = map[MdlAscii_NodeType]struct{}{1: {}, 3: {}, 5: {}, 17: {}, 33: {}, 97: {}, 161: {}, 289: {}, 545: {}, 2081: {}}
func (v MdlAscii_NodeType) isDefined() bool {
	_, ok := values_MdlAscii_NodeType[v]
	return ok
}
type MdlAscii struct {
	Lines []*MdlAscii_AsciiLine
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii() *MdlAscii {
	return &MdlAscii{
	}
}

func (this MdlAscii) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0;; i++ {
		tmp1, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp1 {
			break
		}
		tmp2 := NewMdlAscii_AsciiLine()
		err = tmp2.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Lines = append(this.Lines, tmp2)
	}
	return err
}

/**
 * Animation section keywords
 */
type MdlAscii_AnimationSection struct {
	Newanim *MdlAscii_LineText
	Doneanim *MdlAscii_LineText
	Length *MdlAscii_LineText
	Transtime *MdlAscii_LineText
	Animroot *MdlAscii_LineText
	Event *MdlAscii_LineText
	Eventlist *MdlAscii_LineText
	Endlist *MdlAscii_LineText
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii_AnimationSection() *MdlAscii_AnimationSection {
	return &MdlAscii_AnimationSection{
	}
}

func (this MdlAscii_AnimationSection) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_AnimationSection) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp3 := NewMdlAscii_LineText()
	err = tmp3.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Newanim = tmp3
	tmp4 := NewMdlAscii_LineText()
	err = tmp4.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Doneanim = tmp4
	tmp5 := NewMdlAscii_LineText()
	err = tmp5.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Length = tmp5
	tmp6 := NewMdlAscii_LineText()
	err = tmp6.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Transtime = tmp6
	tmp7 := NewMdlAscii_LineText()
	err = tmp7.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Animroot = tmp7
	tmp8 := NewMdlAscii_LineText()
	err = tmp8.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Event = tmp8
	tmp9 := NewMdlAscii_LineText()
	err = tmp9.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Eventlist = tmp9
	tmp10 := NewMdlAscii_LineText()
	err = tmp10.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Endlist = tmp10
	return err
}

/**
 * newanim <animation_name> <model_name> - Start of animation definition
 */

/**
 * doneanim <animation_name> <model_name> - End of animation definition
 */

/**
 * length <duration> - Animation duration in seconds
 */

/**
 * transtime <transition_time> - Transition/blend time to this animation in seconds
 */

/**
 * animroot <root_node_name> - Root node name for animation
 */

/**
 * event <time> <event_name> - Animation event (triggers at specified time)
 */

/**
 * eventlist - Start of animation events list
 */

/**
 * endlist - End of list (controllers, events, etc.)
 */

/**
 * Single line in ASCII MDL file
 */
type MdlAscii_AsciiLine struct {
	Content string
	_io *kaitai.Stream
	_root *MdlAscii
	_parent *MdlAscii
}
func NewMdlAscii_AsciiLine() *MdlAscii_AsciiLine {
	return &MdlAscii_AsciiLine{
	}
}

func (this MdlAscii_AsciiLine) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_AsciiLine) Read(io *kaitai.Stream, parent *MdlAscii, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp11, err := this._io.ReadBytesTerm(10, false, true, false)
	if err != nil {
		return err
	}
	this.Content = string(tmp11)
	return err
}

/**
 * Bezier (smooth animated) controller format
 */
type MdlAscii_ControllerBezier struct {
	ControllerName *MdlAscii_LineText
	Keyframes []*MdlAscii_ControllerBezierKeyframe
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii_ControllerBezier() *MdlAscii_ControllerBezier {
	return &MdlAscii_ControllerBezier{
	}
}

func (this MdlAscii_ControllerBezier) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_ControllerBezier) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp12 := NewMdlAscii_LineText()
	err = tmp12.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.ControllerName = tmp12
	for i := 0;; i++ {
		tmp13, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp13 {
			break
		}
		tmp14 := NewMdlAscii_ControllerBezierKeyframe()
		err = tmp14.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Keyframes = append(this.Keyframes, tmp14)
	}
	return err
}

/**
 * Controller name followed by 'bezierkey' (e.g., positionbezierkey, orientationbezierkey)
 */

/**
 * Keyframe entries until endlist keyword
 */

/**
 * Single keyframe in Bezier controller (stores value + in_tangent + out_tangent per column)
 */
type MdlAscii_ControllerBezierKeyframe struct {
	Time string
	ValueData string
	_io *kaitai.Stream
	_root *MdlAscii
	_parent *MdlAscii_ControllerBezier
}
func NewMdlAscii_ControllerBezierKeyframe() *MdlAscii_ControllerBezierKeyframe {
	return &MdlAscii_ControllerBezierKeyframe{
	}
}

func (this MdlAscii_ControllerBezierKeyframe) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_ControllerBezierKeyframe) Read(io *kaitai.Stream, parent *MdlAscii_ControllerBezier, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp15, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp15 = tmp15
	this.Time = string(tmp15)
	tmp16, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp16 = tmp16
	this.ValueData = string(tmp16)
	return err
}

/**
 * Time value (float)
 */

/**
 * Space-separated values (3 times column_count floats: value, in_tangent, out_tangent for each column)
 */

/**
 * Keyed (animated) controller format
 */
type MdlAscii_ControllerKeyed struct {
	ControllerName *MdlAscii_LineText
	Keyframes []*MdlAscii_ControllerKeyframe
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii_ControllerKeyed() *MdlAscii_ControllerKeyed {
	return &MdlAscii_ControllerKeyed{
	}
}

func (this MdlAscii_ControllerKeyed) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_ControllerKeyed) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp17 := NewMdlAscii_LineText()
	err = tmp17.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.ControllerName = tmp17
	for i := 0;; i++ {
		tmp18, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp18 {
			break
		}
		tmp19 := NewMdlAscii_ControllerKeyframe()
		err = tmp19.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Keyframes = append(this.Keyframes, tmp19)
	}
	return err
}

/**
 * Controller name followed by 'key' (e.g., positionkey, orientationkey)
 */

/**
 * Keyframe entries until endlist keyword
 */

/**
 * Single keyframe in keyed controller
 */
type MdlAscii_ControllerKeyframe struct {
	Time string
	Values string
	_io *kaitai.Stream
	_root *MdlAscii
	_parent *MdlAscii_ControllerKeyed
}
func NewMdlAscii_ControllerKeyframe() *MdlAscii_ControllerKeyframe {
	return &MdlAscii_ControllerKeyframe{
	}
}

func (this MdlAscii_ControllerKeyframe) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_ControllerKeyframe) Read(io *kaitai.Stream, parent *MdlAscii_ControllerKeyed, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp20, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp20 = tmp20
	this.Time = string(tmp20)
	tmp21, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp21 = tmp21
	this.Values = string(tmp21)
	return err
}

/**
 * Time value (float)
 */

/**
 * Space-separated property values (number depends on controller type and column count)
 */

/**
 * Single (constant) controller format
 */
type MdlAscii_ControllerSingle struct {
	ControllerName *MdlAscii_LineText
	Values *MdlAscii_LineText
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii_ControllerSingle() *MdlAscii_ControllerSingle {
	return &MdlAscii_ControllerSingle{
	}
}

func (this MdlAscii_ControllerSingle) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_ControllerSingle) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp22 := NewMdlAscii_LineText()
	err = tmp22.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.ControllerName = tmp22
	tmp23 := NewMdlAscii_LineText()
	err = tmp23.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Values = tmp23
	return err
}

/**
 * Controller name (position, orientation, scale, color, radius, etc.)
 */

/**
 * Space-separated controller values (number depends on controller type)
 */

/**
 * Danglymesh node properties
 */
type MdlAscii_DanglymeshProperties struct {
	Displacement *MdlAscii_LineText
	Tightness *MdlAscii_LineText
	Period *MdlAscii_LineText
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii_DanglymeshProperties() *MdlAscii_DanglymeshProperties {
	return &MdlAscii_DanglymeshProperties{
	}
}

func (this MdlAscii_DanglymeshProperties) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_DanglymeshProperties) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp24 := NewMdlAscii_LineText()
	err = tmp24.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Displacement = tmp24
	tmp25 := NewMdlAscii_LineText()
	err = tmp25.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Tightness = tmp25
	tmp26 := NewMdlAscii_LineText()
	err = tmp26.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Period = tmp26
	return err
}

/**
 * displacement <value> - Maximum displacement distance for physics simulation
 */

/**
 * tightness <value> - Tightness/stiffness of spring simulation (0.0-1.0)
 */

/**
 * period <value> - Oscillation period in seconds
 */

/**
 * Data array keywords
 */
type MdlAscii_DataArrays struct {
	Verts *MdlAscii_LineText
	Faces *MdlAscii_LineText
	Tverts *MdlAscii_LineText
	Tverts1 *MdlAscii_LineText
	Lightmaptverts *MdlAscii_LineText
	Tverts2 *MdlAscii_LineText
	Tverts3 *MdlAscii_LineText
	Texindices1 *MdlAscii_LineText
	Texindices2 *MdlAscii_LineText
	Texindices3 *MdlAscii_LineText
	Colors *MdlAscii_LineText
	Colorindices *MdlAscii_LineText
	Weights *MdlAscii_LineText
	Constraints *MdlAscii_LineText
	Aabb *MdlAscii_LineText
	SaberVerts *MdlAscii_LineText
	SaberNorms *MdlAscii_LineText
	Name *MdlAscii_LineText
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii_DataArrays() *MdlAscii_DataArrays {
	return &MdlAscii_DataArrays{
	}
}

func (this MdlAscii_DataArrays) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_DataArrays) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp27 := NewMdlAscii_LineText()
	err = tmp27.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Verts = tmp27
	tmp28 := NewMdlAscii_LineText()
	err = tmp28.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Faces = tmp28
	tmp29 := NewMdlAscii_LineText()
	err = tmp29.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Tverts = tmp29
	tmp30 := NewMdlAscii_LineText()
	err = tmp30.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Tverts1 = tmp30
	tmp31 := NewMdlAscii_LineText()
	err = tmp31.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Lightmaptverts = tmp31
	tmp32 := NewMdlAscii_LineText()
	err = tmp32.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Tverts2 = tmp32
	tmp33 := NewMdlAscii_LineText()
	err = tmp33.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Tverts3 = tmp33
	tmp34 := NewMdlAscii_LineText()
	err = tmp34.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Texindices1 = tmp34
	tmp35 := NewMdlAscii_LineText()
	err = tmp35.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Texindices2 = tmp35
	tmp36 := NewMdlAscii_LineText()
	err = tmp36.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Texindices3 = tmp36
	tmp37 := NewMdlAscii_LineText()
	err = tmp37.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Colors = tmp37
	tmp38 := NewMdlAscii_LineText()
	err = tmp38.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Colorindices = tmp38
	tmp39 := NewMdlAscii_LineText()
	err = tmp39.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Weights = tmp39
	tmp40 := NewMdlAscii_LineText()
	err = tmp40.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Constraints = tmp40
	tmp41 := NewMdlAscii_LineText()
	err = tmp41.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Aabb = tmp41
	tmp42 := NewMdlAscii_LineText()
	err = tmp42.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.SaberVerts = tmp42
	tmp43 := NewMdlAscii_LineText()
	err = tmp43.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.SaberNorms = tmp43
	tmp44 := NewMdlAscii_LineText()
	err = tmp44.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp44
	return err
}

/**
 * verts <count> - Start vertex positions array (count vertices, 3 floats each: X, Y, Z)
 */

/**
 * faces <count> - Start faces array (count faces, format: normal_x normal_y normal_z plane_coeff mat_id adj1 adj2 adj3 v1 v2 v3 [t1 t2 t3])
 */

/**
 * tverts <count> - Start primary texture coordinates array (count UVs, 2 floats each: U, V)
 */

/**
 * tverts1 <count> - Start secondary texture coordinates array (count UVs, 2 floats each: U, V)
 */

/**
 * lightmaptverts <count> - Start lightmap texture coordinates (magnusll export compatibility, same as tverts1)
 */

/**
 * tverts2 <count> - Start tertiary texture coordinates array (count UVs, 2 floats each: U, V)
 */

/**
 * tverts3 <count> - Start quaternary texture coordinates array (count UVs, 2 floats each: U, V)
 */

/**
 * texindices1 <count> - Start texture indices array for 2nd texture (count face indices, 3 indices per face)
 */

/**
 * texindices2 <count> - Start texture indices array for 3rd texture (count face indices, 3 indices per face)
 */

/**
 * texindices3 <count> - Start texture indices array for 4th texture (count face indices, 3 indices per face)
 */

/**
 * colors <count> - Start vertex colors array (count colors, 3 floats each: R, G, B)
 */

/**
 * colorindices <count> - Start vertex color indices array (count face indices, 3 indices per face)
 */

/**
 * weights <count> - Start bone weights array (count weights, format: bone1 weight1 [bone2 weight2 [bone3 weight3 [bone4 weight4]]])
 */

/**
 * constraints <count> - Start vertex constraints array for danglymesh (count floats, one per vertex)
 */

/**
 * aabb [min_x min_y min_z max_x max_y max_z leaf_part] - AABB tree node (can be inline or multi-line)
 */

/**
 * saber_verts <count> - Start lightsaber vertex positions array (count vertices, 3 floats each: X, Y, Z)
 */

/**
 * saber_norms <count> - Start lightsaber vertex normals array (count normals, 3 floats each: X, Y, Z)
 */

/**
 * name <node_name> - MDLedit-style name entry for walkmesh nodes (fakenodes)
 */

/**
 * Emitter behavior flags
 */
type MdlAscii_EmitterFlags struct {
	P2p *MdlAscii_LineText
	P2pSel *MdlAscii_LineText
	AffectedByWind *MdlAscii_LineText
	MIsTinted *MdlAscii_LineText
	Bounce *MdlAscii_LineText
	Random *MdlAscii_LineText
	Inherit *MdlAscii_LineText
	Inheritvel *MdlAscii_LineText
	InheritLocal *MdlAscii_LineText
	Splat *MdlAscii_LineText
	InheritPart *MdlAscii_LineText
	DepthTexture *MdlAscii_LineText
	Emitterflag13 *MdlAscii_LineText
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii_EmitterFlags() *MdlAscii_EmitterFlags {
	return &MdlAscii_EmitterFlags{
	}
}

func (this MdlAscii_EmitterFlags) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_EmitterFlags) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp45 := NewMdlAscii_LineText()
	err = tmp45.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.P2p = tmp45
	tmp46 := NewMdlAscii_LineText()
	err = tmp46.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.P2pSel = tmp46
	tmp47 := NewMdlAscii_LineText()
	err = tmp47.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.AffectedByWind = tmp47
	tmp48 := NewMdlAscii_LineText()
	err = tmp48.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.MIsTinted = tmp48
	tmp49 := NewMdlAscii_LineText()
	err = tmp49.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Bounce = tmp49
	tmp50 := NewMdlAscii_LineText()
	err = tmp50.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Random = tmp50
	tmp51 := NewMdlAscii_LineText()
	err = tmp51.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Inherit = tmp51
	tmp52 := NewMdlAscii_LineText()
	err = tmp52.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Inheritvel = tmp52
	tmp53 := NewMdlAscii_LineText()
	err = tmp53.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.InheritLocal = tmp53
	tmp54 := NewMdlAscii_LineText()
	err = tmp54.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Splat = tmp54
	tmp55 := NewMdlAscii_LineText()
	err = tmp55.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.InheritPart = tmp55
	tmp56 := NewMdlAscii_LineText()
	err = tmp56.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.DepthTexture = tmp56
	tmp57 := NewMdlAscii_LineText()
	err = tmp57.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Emitterflag13 = tmp57
	return err
}

/**
 * p2p <0_or_1> - Point-to-point flag (bit 0x0001)
 */

/**
 * p2p_sel <0_or_1> - Point-to-point selection flag (bit 0x0002)
 */

/**
 * affectedByWind <0_or_1> - Affected by wind flag (bit 0x0004)
 */

/**
 * m_isTinted <0_or_1> - Is tinted flag (bit 0x0008)
 */

/**
 * bounce <0_or_1> - Bounce flag (bit 0x0010)
 */

/**
 * random <0_or_1> - Random flag (bit 0x0020)
 */

/**
 * inherit <0_or_1> - Inherit flag (bit 0x0040)
 */

/**
 * inheritvel <0_or_1> - Inherit velocity flag (bit 0x0080)
 */

/**
 * inherit_local <0_or_1> - Inherit local flag (bit 0x0100)
 */

/**
 * splat <0_or_1> - Splat flag (bit 0x0200)
 */

/**
 * inherit_part <0_or_1> - Inherit part flag (bit 0x0400)
 */

/**
 * depth_texture <0_or_1> - Depth texture flag (bit 0x0800)
 */

/**
 * emitterflag13 <0_or_1> - Emitter flag 13 (bit 0x1000)
 */

/**
 * Emitter node properties
 */
type MdlAscii_EmitterProperties struct {
	Deadspace *MdlAscii_LineText
	BlastRadius *MdlAscii_LineText
	BlastLength *MdlAscii_LineText
	NumBranches *MdlAscii_LineText
	Controlptsmoothing *MdlAscii_LineText
	Xgrid *MdlAscii_LineText
	Ygrid *MdlAscii_LineText
	Spawntype *MdlAscii_LineText
	Update *MdlAscii_LineText
	Render *MdlAscii_LineText
	Blend *MdlAscii_LineText
	Texture *MdlAscii_LineText
	Chunkname *MdlAscii_LineText
	Twosidedtex *MdlAscii_LineText
	Loop *MdlAscii_LineText
	Renderorder *MdlAscii_LineText
	MBFrameBlending *MdlAscii_LineText
	MSDepthTextureName *MdlAscii_LineText
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii_EmitterProperties() *MdlAscii_EmitterProperties {
	return &MdlAscii_EmitterProperties{
	}
}

func (this MdlAscii_EmitterProperties) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_EmitterProperties) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp58 := NewMdlAscii_LineText()
	err = tmp58.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Deadspace = tmp58
	tmp59 := NewMdlAscii_LineText()
	err = tmp59.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.BlastRadius = tmp59
	tmp60 := NewMdlAscii_LineText()
	err = tmp60.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.BlastLength = tmp60
	tmp61 := NewMdlAscii_LineText()
	err = tmp61.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.NumBranches = tmp61
	tmp62 := NewMdlAscii_LineText()
	err = tmp62.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Controlptsmoothing = tmp62
	tmp63 := NewMdlAscii_LineText()
	err = tmp63.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Xgrid = tmp63
	tmp64 := NewMdlAscii_LineText()
	err = tmp64.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Ygrid = tmp64
	tmp65 := NewMdlAscii_LineText()
	err = tmp65.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Spawntype = tmp65
	tmp66 := NewMdlAscii_LineText()
	err = tmp66.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Update = tmp66
	tmp67 := NewMdlAscii_LineText()
	err = tmp67.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Render = tmp67
	tmp68 := NewMdlAscii_LineText()
	err = tmp68.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Blend = tmp68
	tmp69 := NewMdlAscii_LineText()
	err = tmp69.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Texture = tmp69
	tmp70 := NewMdlAscii_LineText()
	err = tmp70.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Chunkname = tmp70
	tmp71 := NewMdlAscii_LineText()
	err = tmp71.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Twosidedtex = tmp71
	tmp72 := NewMdlAscii_LineText()
	err = tmp72.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Loop = tmp72
	tmp73 := NewMdlAscii_LineText()
	err = tmp73.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Renderorder = tmp73
	tmp74 := NewMdlAscii_LineText()
	err = tmp74.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.MBFrameBlending = tmp74
	tmp75 := NewMdlAscii_LineText()
	err = tmp75.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.MSDepthTextureName = tmp75
	return err
}

/**
 * deadspace <value> - Minimum distance from emitter before particles become visible
 */

/**
 * blastRadius <value> - Radius of explosive/blast particle effects
 */

/**
 * blastLength <value> - Length/duration of blast effects
 */

/**
 * numBranches <value> - Number of branching paths for particle trails
 */

/**
 * controlptsmoothing <value> - Smoothing factor for particle path control points
 */

/**
 * xgrid <value> - Grid subdivisions along X axis for particle spawning
 */

/**
 * ygrid <value> - Grid subdivisions along Y axis for particle spawning
 */

/**
 * spawntype <value> - Particle spawn type
 */

/**
 * update <script_name> - Update behavior script name (e.g., single, fountain)
 */

/**
 * render <script_name> - Render mode script name (e.g., normal, billboard_to_local_z)
 */

/**
 * blend <script_name> - Blend mode script name (e.g., normal, lighten)
 */

/**
 * texture <texture_name> - Particle texture name
 */

/**
 * chunkname <chunk_name> - Associated model chunk name
 */

/**
 * twosidedtex <0_or_1> - Whether texture should render two-sided (1=two-sided, 0=single-sided)
 */

/**
 * loop <0_or_1> - Whether particle system loops (1=loops, 0=single playback)
 */

/**
 * renderorder <value> - Rendering priority/order for particle sorting
 */

/**
 * m_bFrameBlending <0_or_1> - Whether frame blending is enabled (1=enabled, 0=disabled)
 */

/**
 * m_sDepthTextureName <texture_name> - Depth/softparticle texture name
 */

/**
 * Light node properties
 */
type MdlAscii_LightProperties struct {
	Flareradius *MdlAscii_LineText
	Flarepositions *MdlAscii_LineText
	Flaresizes *MdlAscii_LineText
	Flarecolorshifts *MdlAscii_LineText
	Texturenames *MdlAscii_LineText
	Ambientonly *MdlAscii_LineText
	Ndynamictype *MdlAscii_LineText
	Affectdynamic *MdlAscii_LineText
	Flare *MdlAscii_LineText
	Lightpriority *MdlAscii_LineText
	Fadinglight *MdlAscii_LineText
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii_LightProperties() *MdlAscii_LightProperties {
	return &MdlAscii_LightProperties{
	}
}

func (this MdlAscii_LightProperties) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_LightProperties) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp76 := NewMdlAscii_LineText()
	err = tmp76.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Flareradius = tmp76
	tmp77 := NewMdlAscii_LineText()
	err = tmp77.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Flarepositions = tmp77
	tmp78 := NewMdlAscii_LineText()
	err = tmp78.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Flaresizes = tmp78
	tmp79 := NewMdlAscii_LineText()
	err = tmp79.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Flarecolorshifts = tmp79
	tmp80 := NewMdlAscii_LineText()
	err = tmp80.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Texturenames = tmp80
	tmp81 := NewMdlAscii_LineText()
	err = tmp81.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Ambientonly = tmp81
	tmp82 := NewMdlAscii_LineText()
	err = tmp82.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Ndynamictype = tmp82
	tmp83 := NewMdlAscii_LineText()
	err = tmp83.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Affectdynamic = tmp83
	tmp84 := NewMdlAscii_LineText()
	err = tmp84.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Flare = tmp84
	tmp85 := NewMdlAscii_LineText()
	err = tmp85.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Lightpriority = tmp85
	tmp86 := NewMdlAscii_LineText()
	err = tmp86.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Fadinglight = tmp86
	return err
}

/**
 * flareradius <value> - Radius of lens flare effect
 */

/**
 * flarepositions <count> - Start flare positions array (count floats, 0.0-1.0 along light ray)
 */

/**
 * flaresizes <count> - Start flare sizes array (count floats)
 */

/**
 * flarecolorshifts <count> - Start flare color shifts array (count RGB floats)
 */

/**
 * texturenames <count> - Start flare texture names array (count strings)
 */

/**
 * ambientonly <0_or_1> - Whether light only affects ambient (1=ambient only, 0=full lighting)
 */

/**
 * ndynamictype <value> - Type of dynamic lighting behavior
 */

/**
 * affectdynamic <0_or_1> - Whether light affects dynamic objects (1=affects, 0=static only)
 */

/**
 * flare <0_or_1> - Whether lens flare effect is enabled (1=enabled, 0=disabled)
 */

/**
 * lightpriority <value> - Rendering priority for light culling/sorting
 */

/**
 * fadinglight <0_or_1> - Whether light intensity fades with distance (1=fades, 0=constant)
 */

/**
 * A single UTF-8 text line (without the trailing newline).
 * Used to make doc-oriented keyword/type listings schema-valid for Kaitai.
 */
type MdlAscii_LineText struct {
	Value string
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii_LineText() *MdlAscii_LineText {
	return &MdlAscii_LineText{
	}
}

func (this MdlAscii_LineText) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_LineText) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp87, err := this._io.ReadBytesTerm(10, false, true, false)
	if err != nil {
		return err
	}
	this.Value = string(tmp87)
	return err
}

/**
 * Reference node properties
 */
type MdlAscii_ReferenceProperties struct {
	Refmodel *MdlAscii_LineText
	Reattachable *MdlAscii_LineText
	_io *kaitai.Stream
	_root *MdlAscii
	_parent kaitai.Struct
}
func NewMdlAscii_ReferenceProperties() *MdlAscii_ReferenceProperties {
	return &MdlAscii_ReferenceProperties{
	}
}

func (this MdlAscii_ReferenceProperties) IO_() *kaitai.Stream {
	return this._io
}

func (this *MdlAscii_ReferenceProperties) Read(io *kaitai.Stream, parent kaitai.Struct, root *MdlAscii) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp88 := NewMdlAscii_LineText()
	err = tmp88.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Refmodel = tmp88
	tmp89 := NewMdlAscii_LineText()
	err = tmp89.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Reattachable = tmp89
	return err
}

/**
 * refmodel <model_resref> - Referenced model resource name without extension
 */

/**
 * reattachable <0_or_1> - Whether model can be detached and reattached dynamically (1=reattachable, 0=permanent)
 */
