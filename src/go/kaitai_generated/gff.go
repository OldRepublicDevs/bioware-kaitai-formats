// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"io"
)


/**
 * GFF (Generic File Format) is BioWare's universal container format for structured game data.
 * It is used by many KotOR file types including UTC (creature), UTI (item), DLG (dialogue),
 * ARE (area), GIT (game instance template), IFO (module info), and many others.
 * 
 * GFF uses a hierarchical structure with structs containing fields, which can be simple values,
 * nested structs, or lists of structs. The format supports version V3.2 (KotOR) and later
 * versions (V3.3, V4.0, V4.1) used in other BioWare games.
 * 
 * Binary Format Structure:
 * - File Header (56 bytes): File type signature (FourCC), version, counts, and offsets to all
 *   data tables (structs, fields, labels, field_data, field_indices, list_indices)
 * - Label Array: Array of 16-byte null-padded field name labels
 * - Struct Array: Array of struct entries (12 bytes each) - struct_id, data_or_offset, field_count
 * - Field Array: Array of field entries (12 bytes each) - field_type, label_index, data_or_offset
 * - Field Data: Storage area for complex field types (strings, binary, vectors, etc.)
 * - Field Indices Array: Array of field index arrays (used when structs have multiple fields)
 * - List Indices Array: Array of list entry structures (count + struct indices)
 * 
 * Field Types:
 * - Simple types (0-5, 8): Stored inline in data_or_offset (uint8, int8, uint16, int16, uint32,
 *   int32, float)
 * - Complex types (6-7, 9-13, 16-17): Offset to field_data section (uint64, int64, double, string,
 *   resref, localized_string, binary, vector4, vector3)
 * - Struct (14): Struct index stored inline (nested struct)
 * - List (15): Offset to list_indices_array (list of structs)
 * 
 * Struct Access Pattern:
 * 1. Root struct is always at struct_array index 0
 * 2. If struct.field_count == 1: data_or_offset contains direct field index
 * 3. If struct.field_count > 1: data_or_offset contains offset into field_indices_array
 * 4. Use field_index to access field_array entry
 * 5. Use field.label_index to get field name from label_array
 * 6. Use field.data_or_offset based on field_type (inline, offset, struct index, list offset)
 * 
 * References:
 * - https://github.com/OldRepublicDevs/PyKotor/wiki/GFF-File-Format.md - Complete GFF format documentation
 * - https://github.com/OldRepublicDevs/PyKotor/wiki/Bioware-Aurora-GFF.md - Official BioWare Aurora GFF specification
 * - https://github.com/xoreos/xoreos-docs/blob/master/specs/torlack/itp.html - Tim Smith/Torlack's GFF/ITP documentation
 * - https://github.com/seedhartha/reone/blob/master/src/libs/resource/format/gffreader.cpp - Complete C++ GFF reader implementation
 * - https://github.com/xoreos/xoreos/blob/master/src/aurora/gff3file.cpp - Generic Aurora GFF implementation (shared format)
 * - https://github.com/KotOR-Community-Patches/KotOR.js/blob/master/src/resource/GFFObject.ts - TypeScript GFF parser
 * - https://github.com/KotOR-Community-Patches/KotOR-Unity/blob/master/Assets/Scripts/FileObjects/GFFObject.cs - C# Unity GFF loader
 * - https://github.com/KotOR-Community-Patches/Kotor.NET/tree/master/Kotor.NET/Formats/KotorGFF/ - .NET GFF reader/writer
 * - https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/gff/io_gff.py - PyKotor binary reader/writer
 * - https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/gff/gff_data.py - GFF data model
 */

type Gff_GffFieldType int
const (
	Gff_GffFieldType__Uint8 Gff_GffFieldType = 0
	Gff_GffFieldType__Int8 Gff_GffFieldType = 1
	Gff_GffFieldType__Uint16 Gff_GffFieldType = 2
	Gff_GffFieldType__Int16 Gff_GffFieldType = 3
	Gff_GffFieldType__Uint32 Gff_GffFieldType = 4
	Gff_GffFieldType__Int32 Gff_GffFieldType = 5
	Gff_GffFieldType__Uint64 Gff_GffFieldType = 6
	Gff_GffFieldType__Int64 Gff_GffFieldType = 7
	Gff_GffFieldType__Single Gff_GffFieldType = 8
	Gff_GffFieldType__Double Gff_GffFieldType = 9
	Gff_GffFieldType__String Gff_GffFieldType = 10
	Gff_GffFieldType__Resref Gff_GffFieldType = 11
	Gff_GffFieldType__LocalizedString Gff_GffFieldType = 12
	Gff_GffFieldType__Binary Gff_GffFieldType = 13
	Gff_GffFieldType__Struct Gff_GffFieldType = 14
	Gff_GffFieldType__List Gff_GffFieldType = 15
	Gff_GffFieldType__Vector4 Gff_GffFieldType = 16
	Gff_GffFieldType__Vector3 Gff_GffFieldType = 17
)
var values_Gff_GffFieldType = map[Gff_GffFieldType]struct{}{0: {}, 1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {}, 7: {}, 8: {}, 9: {}, 10: {}, 11: {}, 12: {}, 13: {}, 14: {}, 15: {}, 16: {}, 17: {}}
func (v Gff_GffFieldType) isDefined() bool {
	_, ok := values_Gff_GffFieldType[v]
	return ok
}
type Gff struct {
	Header *Gff_GffHeader
	_io *kaitai.Stream
	_root *Gff
	_parent kaitai.Struct
	_f_fieldArray bool
	fieldArray *Gff_FieldArray
	_f_fieldData bool
	fieldData *Gff_FieldData
	_f_fieldIndicesArray bool
	fieldIndicesArray *Gff_FieldIndicesArray
	_f_labelArray bool
	labelArray *Gff_LabelArray
	_f_listIndicesArray bool
	listIndicesArray *Gff_ListIndicesArray
	_f_structArray bool
	structArray *Gff_StructArray
}
func NewGff() *Gff {
	return &Gff{
	}
}

func (this Gff) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff) Read(io *kaitai.Stream, parent kaitai.Struct, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1 := NewGff_GffHeader()
	err = tmp1.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Header = tmp1
	return err
}

/**
 * Array of field entries (12 bytes each)
 */
func (this *Gff) FieldArray() (v *Gff_FieldArray, err error) {
	if (this._f_fieldArray) {
		return this.fieldArray, nil
	}
	this._f_fieldArray = true
	if (this.Header.FieldCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this.Header.FieldOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp2 := NewGff_FieldArray()
		err = tmp2.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.fieldArray = tmp2
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.fieldArray, nil
}

/**
 * Storage area for complex field types (strings, binary, vectors, etc.)
 */
func (this *Gff) FieldData() (v *Gff_FieldData, err error) {
	if (this._f_fieldData) {
		return this.fieldData, nil
	}
	this._f_fieldData = true
	if (this.Header.FieldDataCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this.Header.FieldDataOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp3 := NewGff_FieldData()
		err = tmp3.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.fieldData = tmp3
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.fieldData, nil
}

/**
 * Array of field index arrays (used when structs have multiple fields)
 */
func (this *Gff) FieldIndicesArray() (v *Gff_FieldIndicesArray, err error) {
	if (this._f_fieldIndicesArray) {
		return this.fieldIndicesArray, nil
	}
	this._f_fieldIndicesArray = true
	if (this.Header.FieldIndicesCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this.Header.FieldIndicesOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp4 := NewGff_FieldIndicesArray()
		err = tmp4.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.fieldIndicesArray = tmp4
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.fieldIndicesArray, nil
}

/**
 * Array of 16-byte null-padded field name labels
 */
func (this *Gff) LabelArray() (v *Gff_LabelArray, err error) {
	if (this._f_labelArray) {
		return this.labelArray, nil
	}
	this._f_labelArray = true
	if (this.Header.LabelCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this.Header.LabelOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp5 := NewGff_LabelArray()
		err = tmp5.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.labelArray = tmp5
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.labelArray, nil
}

/**
 * Array of list entry structures (count + struct indices)
 */
func (this *Gff) ListIndicesArray() (v *Gff_ListIndicesArray, err error) {
	if (this._f_listIndicesArray) {
		return this.listIndicesArray, nil
	}
	this._f_listIndicesArray = true
	if (this.Header.ListIndicesCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this.Header.ListIndicesOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp6 := NewGff_ListIndicesArray()
		err = tmp6.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.listIndicesArray = tmp6
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.listIndicesArray, nil
}

/**
 * Array of struct entries (12 bytes each)
 */
func (this *Gff) StructArray() (v *Gff_StructArray, err error) {
	if (this._f_structArray) {
		return this.structArray, nil
	}
	this._f_structArray = true
	if (this.Header.StructCount > 0) {
		_pos, err := this._io.Pos()
		if err != nil {
			return nil, err
		}
		_, err = this._io.Seek(int64(this.Header.StructOffset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp7 := NewGff_StructArray()
		err = tmp7.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.structArray = tmp7
		_, err = this._io.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
	}
	return this.structArray, nil
}

/**
 * GFF file header (56 bytes total)
 */
type Gff_FieldArray struct {
	Entries []*Gff_FieldEntry
	_io *kaitai.Stream
	_root *Gff
	_parent *Gff
}
func NewGff_FieldArray() *Gff_FieldArray {
	return &Gff_FieldArray{
	}
}

func (this Gff_FieldArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff_FieldArray) Read(io *kaitai.Stream, parent *Gff, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.Header.FieldCount); i++ {
		_ = i
		tmp8 := NewGff_FieldEntry()
		err = tmp8.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Entries = append(this.Entries, tmp8)
	}
	return err
}

/**
 * Array of field entries (12 bytes each)
 */
type Gff_FieldData struct {
	RawData []byte
	_io *kaitai.Stream
	_root *Gff
	_parent *Gff
}
func NewGff_FieldData() *Gff_FieldData {
	return &Gff_FieldData{
	}
}

func (this Gff_FieldData) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff_FieldData) Read(io *kaitai.Stream, parent *Gff, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp9, err := this._io.ReadBytes(int(this._root.Header.FieldDataCount))
	if err != nil {
		return err
	}
	tmp9 = tmp9
	this.RawData = tmp9
	return err
}

/**
 * Raw field data storage. Individual field data entries are accessed via
 * field_entry.field_data_offset_value offsets. The structure of each entry
 * depends on the field_type:
 * - UInt64/Int64/Double: 8 bytes
 * - String: 4-byte length + string bytes
 * - ResRef: 1-byte length + string bytes (max 16)
 * - LocalizedString: variable (see bioware_common::bioware_locstring type)
 * - Binary: 4-byte length + binary bytes
 * - Vector3: 12 bytes (3×float)
 * - Vector4: 16 bytes (4×float)
 */
type Gff_FieldEntry struct {
	FieldType Gff_GffFieldType
	LabelIndex uint32
	DataOrOffset uint32
	_io *kaitai.Stream
	_root *Gff
	_parent *Gff_FieldArray
	_f_fieldDataOffsetValue bool
	fieldDataOffsetValue int
	_f_isComplexType bool
	isComplexType bool
	_f_isListType bool
	isListType bool
	_f_isSimpleType bool
	isSimpleType bool
	_f_isStructType bool
	isStructType bool
	_f_listIndicesOffsetValue bool
	listIndicesOffsetValue int
	_f_structIndexValue bool
	structIndexValue uint32
}
func NewGff_FieldEntry() *Gff_FieldEntry {
	return &Gff_FieldEntry{
	}
}

func (this Gff_FieldEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff_FieldEntry) Read(io *kaitai.Stream, parent *Gff_FieldArray, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp10, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FieldType = Gff_GffFieldType(tmp10)
	tmp11, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LabelIndex = uint32(tmp11)
	tmp12, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.DataOrOffset = uint32(tmp12)
	return err
}

/**
 * Absolute file offset to field data for complex types
 */
func (this *Gff_FieldEntry) FieldDataOffsetValue() (v int, err error) {
	if (this._f_fieldDataOffsetValue) {
		return this.fieldDataOffsetValue, nil
	}
	this._f_fieldDataOffsetValue = true
	tmp13, err := this.IsComplexType()
	if err != nil {
		return 0, err
	}
	if (tmp13) {
		this.fieldDataOffsetValue = int(this._root.Header.FieldDataOffset + this.DataOrOffset)
	}
	return this.fieldDataOffsetValue, nil
}

/**
 * True if field stores data in field_data section
 */
func (this *Gff_FieldEntry) IsComplexType() (v bool, err error) {
	if (this._f_isComplexType) {
		return this.isComplexType, nil
	}
	this._f_isComplexType = true
	this.isComplexType = bool( ((this.FieldType == Gff_GffFieldType__Uint64) || (this.FieldType == Gff_GffFieldType__Int64) || (this.FieldType == Gff_GffFieldType__Double) || (this.FieldType == Gff_GffFieldType__String) || (this.FieldType == Gff_GffFieldType__Resref) || (this.FieldType == Gff_GffFieldType__LocalizedString) || (this.FieldType == Gff_GffFieldType__Binary) || (this.FieldType == Gff_GffFieldType__Vector4) || (this.FieldType == Gff_GffFieldType__Vector3)) )
	return this.isComplexType, nil
}

/**
 * True if field is a list of structs
 */
func (this *Gff_FieldEntry) IsListType() (v bool, err error) {
	if (this._f_isListType) {
		return this.isListType, nil
	}
	this._f_isListType = true
	this.isListType = bool(this.FieldType == Gff_GffFieldType__List)
	return this.isListType, nil
}

/**
 * True if field stores data inline (simple types)
 */
func (this *Gff_FieldEntry) IsSimpleType() (v bool, err error) {
	if (this._f_isSimpleType) {
		return this.isSimpleType, nil
	}
	this._f_isSimpleType = true
	this.isSimpleType = bool( ((this.FieldType == Gff_GffFieldType__Uint8) || (this.FieldType == Gff_GffFieldType__Int8) || (this.FieldType == Gff_GffFieldType__Uint16) || (this.FieldType == Gff_GffFieldType__Int16) || (this.FieldType == Gff_GffFieldType__Uint32) || (this.FieldType == Gff_GffFieldType__Int32) || (this.FieldType == Gff_GffFieldType__Single)) )
	return this.isSimpleType, nil
}

/**
 * True if field is a nested struct
 */
func (this *Gff_FieldEntry) IsStructType() (v bool, err error) {
	if (this._f_isStructType) {
		return this.isStructType, nil
	}
	this._f_isStructType = true
	this.isStructType = bool(this.FieldType == Gff_GffFieldType__Struct)
	return this.isStructType, nil
}

/**
 * Absolute file offset to list indices for list type fields
 */
func (this *Gff_FieldEntry) ListIndicesOffsetValue() (v int, err error) {
	if (this._f_listIndicesOffsetValue) {
		return this.listIndicesOffsetValue, nil
	}
	this._f_listIndicesOffsetValue = true
	tmp14, err := this.IsListType()
	if err != nil {
		return 0, err
	}
	if (tmp14) {
		this.listIndicesOffsetValue = int(this._root.Header.ListIndicesOffset + this.DataOrOffset)
	}
	return this.listIndicesOffsetValue, nil
}

/**
 * Struct index for struct type fields
 */
func (this *Gff_FieldEntry) StructIndexValue() (v uint32, err error) {
	if (this._f_structIndexValue) {
		return this.structIndexValue, nil
	}
	this._f_structIndexValue = true
	tmp15, err := this.IsStructType()
	if err != nil {
		return 0, err
	}
	if (tmp15) {
		this.structIndexValue = uint32(this.DataOrOffset)
	}
	return this.structIndexValue, nil
}

/**
 * Field data type (see gff_field_type enum):
 * - 0-5, 8: Simple types (stored inline in data_or_offset)
 * - 6-7, 9-13, 16-17: Complex types (offset to field_data in data_or_offset)
 * - 14: Struct (struct index in data_or_offset)
 * - 15: List (offset to list_indices_array in data_or_offset)
 */

/**
 * Index into label_array for field name
 */

/**
 * Inline data (simple types) or offset/index (complex types):
 * - Simple types (0-5, 8): Value stored directly (1-4 bytes, sign/zero extended to 4 bytes)
 * - Complex types (6-7, 9-13, 16-17): Byte offset into field_data section (relative to field_data_offset)
 * - Struct (14): Struct index (index into struct_array)
 * - List (15): Byte offset into list_indices_array (relative to list_indices_offset)
 */
type Gff_FieldIndicesArray struct {
	Indices []uint32
	_io *kaitai.Stream
	_root *Gff
	_parent *Gff
}
func NewGff_FieldIndicesArray() *Gff_FieldIndicesArray {
	return &Gff_FieldIndicesArray{
	}
}

func (this Gff_FieldIndicesArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff_FieldIndicesArray) Read(io *kaitai.Stream, parent *Gff, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.Header.FieldIndicesCount); i++ {
		_ = i
		tmp16, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.Indices = append(this.Indices, tmp16)
	}
	return err
}

/**
 * Array of field indices. When a struct has multiple fields, it stores an offset
 * into this array, and the next N consecutive u4 values (where N = struct.field_count)
 * are the field indices for that struct.
 */
type Gff_GffHeader struct {
	FileType string
	FileVersion string
	StructOffset uint32
	StructCount uint32
	FieldOffset uint32
	FieldCount uint32
	LabelOffset uint32
	LabelCount uint32
	FieldDataOffset uint32
	FieldDataCount uint32
	FieldIndicesOffset uint32
	FieldIndicesCount uint32
	ListIndicesOffset uint32
	ListIndicesCount uint32
	_io *kaitai.Stream
	_root *Gff
	_parent *Gff
}
func NewGff_GffHeader() *Gff_GffHeader {
	return &Gff_GffHeader{
	}
}

func (this Gff_GffHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff_GffHeader) Read(io *kaitai.Stream, parent *Gff, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp17, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp17 = tmp17
	this.FileType = string(tmp17)
	tmp18, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp18 = tmp18
	this.FileVersion = string(tmp18)
	tmp19, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.StructOffset = uint32(tmp19)
	tmp20, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.StructCount = uint32(tmp20)
	tmp21, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FieldOffset = uint32(tmp21)
	tmp22, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FieldCount = uint32(tmp22)
	tmp23, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LabelOffset = uint32(tmp23)
	tmp24, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LabelCount = uint32(tmp24)
	tmp25, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FieldDataOffset = uint32(tmp25)
	tmp26, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FieldDataCount = uint32(tmp26)
	tmp27, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FieldIndicesOffset = uint32(tmp27)
	tmp28, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FieldIndicesCount = uint32(tmp28)
	tmp29, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ListIndicesOffset = uint32(tmp29)
	tmp30, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ListIndicesCount = uint32(tmp30)
	return err
}

/**
 * File type signature (FourCC). Examples: "GFF ", "UTC ", "UTI ", "DLG ", "ARE ", etc.
 * Must match a valid GFFContent enum value.
 */

/**
 * File format version. Must be "V3.2" for KotOR games.
 * Later BioWare games use "V3.3", "V4.0", or "V4.1".
 * Valid values: "V3.2" (KotOR), "V3.3", "V4.0", "V4.1" (other BioWare games)
 */

/**
 * Byte offset to struct array from beginning of file
 */

/**
 * Number of struct entries in struct array
 */

/**
 * Byte offset to field array from beginning of file
 */

/**
 * Number of field entries in field array
 */

/**
 * Byte offset to label array from beginning of file
 */

/**
 * Number of labels in label array
 */

/**
 * Byte offset to field data section from beginning of file
 */

/**
 * Size of field data section in bytes
 */

/**
 * Byte offset to field indices array from beginning of file
 */

/**
 * Number of field indices (total count across all structs with multiple fields)
 */

/**
 * Byte offset to list indices array from beginning of file
 */

/**
 * Number of list indices entries
 */
type Gff_LabelArray struct {
	Labels []*Gff_LabelEntry
	_io *kaitai.Stream
	_root *Gff
	_parent *Gff
}
func NewGff_LabelArray() *Gff_LabelArray {
	return &Gff_LabelArray{
	}
}

func (this Gff_LabelArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff_LabelArray) Read(io *kaitai.Stream, parent *Gff, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.Header.LabelCount); i++ {
		_ = i
		tmp31 := NewGff_LabelEntry()
		err = tmp31.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Labels = append(this.Labels, tmp31)
	}
	return err
}

/**
 * Array of label entries (16 bytes each)
 */
type Gff_LabelEntry struct {
	Name string
	_io *kaitai.Stream
	_root *Gff
	_parent *Gff_LabelArray
}
func NewGff_LabelEntry() *Gff_LabelEntry {
	return &Gff_LabelEntry{
	}
}

func (this Gff_LabelEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff_LabelEntry) Read(io *kaitai.Stream, parent *Gff_LabelArray, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp32, err := this._io.ReadBytes(int(16))
	if err != nil {
		return err
	}
	tmp32 = tmp32
	this.Name = string(tmp32)
	return err
}

/**
 * Field name label (null-padded to 16 bytes, null-terminated).
 * The actual label length is determined by the first null byte.
 * Application code should trim trailing null bytes when using this field.
 */
type Gff_ListEntry struct {
	NumStructIndices uint32
	StructIndices []uint32
	_io *kaitai.Stream
	_root *Gff
	_parent kaitai.Struct
}
func NewGff_ListEntry() *Gff_ListEntry {
	return &Gff_ListEntry{
	}
}

func (this Gff_ListEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff_ListEntry) Read(io *kaitai.Stream, parent kaitai.Struct, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp33, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NumStructIndices = uint32(tmp33)
	for i := 0; i < int(this.NumStructIndices); i++ {
		_ = i
		tmp34, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.StructIndices = append(this.StructIndices, tmp34)
	}
	return err
}

/**
 * Number of struct indices in this list
 */

/**
 * Array of struct indices (indices into struct_array)
 */
type Gff_ListIndicesArray struct {
	RawData []byte
	_io *kaitai.Stream
	_root *Gff
	_parent *Gff
}
func NewGff_ListIndicesArray() *Gff_ListIndicesArray {
	return &Gff_ListIndicesArray{
	}
}

func (this Gff_ListIndicesArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff_ListIndicesArray) Read(io *kaitai.Stream, parent *Gff, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp35, err := this._io.ReadBytes(int(this._root.Header.ListIndicesCount))
	if err != nil {
		return err
	}
	tmp35 = tmp35
	this.RawData = tmp35
	return err
}

/**
 * Raw list indices data. List entries are accessed via offsets stored in
 * list-type field entries (field_entry.list_indices_offset_value).
 * Each entry starts with a count (u4), followed by that many struct indices (u4 each).
 * 
 * Note: This is a raw data block. In practice, list entries are accessed via
 * offsets stored in list-type field entries, not as a sequential array.
 * Use list_entry type to parse individual entries at specific offsets.
 */
type Gff_StructArray struct {
	Entries []*Gff_StructEntry
	_io *kaitai.Stream
	_root *Gff
	_parent *Gff
}
func NewGff_StructArray() *Gff_StructArray {
	return &Gff_StructArray{
	}
}

func (this Gff_StructArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff_StructArray) Read(io *kaitai.Stream, parent *Gff, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(this._root.Header.StructCount); i++ {
		_ = i
		tmp36 := NewGff_StructEntry()
		err = tmp36.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Entries = append(this.Entries, tmp36)
	}
	return err
}

/**
 * Array of struct entries (12 bytes each)
 */
type Gff_StructEntry struct {
	StructId int32
	DataOrOffset uint32
	FieldCount uint32
	_io *kaitai.Stream
	_root *Gff
	_parent *Gff_StructArray
	_f_fieldIndicesOffset bool
	fieldIndicesOffset uint32
	_f_hasMultipleFields bool
	hasMultipleFields bool
	_f_hasSingleField bool
	hasSingleField bool
	_f_singleFieldIndex bool
	singleFieldIndex uint32
}
func NewGff_StructEntry() *Gff_StructEntry {
	return &Gff_StructEntry{
	}
}

func (this Gff_StructEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Gff_StructEntry) Read(io *kaitai.Stream, parent *Gff_StructArray, root *Gff) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp37, err := this._io.ReadS4le()
	if err != nil {
		return err
	}
	this.StructId = int32(tmp37)
	tmp38, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.DataOrOffset = uint32(tmp38)
	tmp39, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FieldCount = uint32(tmp39)
	return err
}

/**
 * Byte offset into field_indices_array when struct has multiple fields
 */
func (this *Gff_StructEntry) FieldIndicesOffset() (v uint32, err error) {
	if (this._f_fieldIndicesOffset) {
		return this.fieldIndicesOffset, nil
	}
	this._f_fieldIndicesOffset = true
	tmp40, err := this.HasMultipleFields()
	if err != nil {
		return 0, err
	}
	if (tmp40) {
		this.fieldIndicesOffset = uint32(this.DataOrOffset)
	}
	return this.fieldIndicesOffset, nil
}

/**
 * True if struct has multiple fields (offset to field indices in data_or_offset)
 */
func (this *Gff_StructEntry) HasMultipleFields() (v bool, err error) {
	if (this._f_hasMultipleFields) {
		return this.hasMultipleFields, nil
	}
	this._f_hasMultipleFields = true
	this.hasMultipleFields = bool(this.FieldCount > 1)
	return this.hasMultipleFields, nil
}

/**
 * True if struct has exactly one field (direct field index in data_or_offset)
 */
func (this *Gff_StructEntry) HasSingleField() (v bool, err error) {
	if (this._f_hasSingleField) {
		return this.hasSingleField, nil
	}
	this._f_hasSingleField = true
	this.hasSingleField = bool(this.FieldCount == 1)
	return this.hasSingleField, nil
}

/**
 * Direct field index when struct has exactly one field
 */
func (this *Gff_StructEntry) SingleFieldIndex() (v uint32, err error) {
	if (this._f_singleFieldIndex) {
		return this.singleFieldIndex, nil
	}
	this._f_singleFieldIndex = true
	tmp41, err := this.HasSingleField()
	if err != nil {
		return 0, err
	}
	if (tmp41) {
		this.singleFieldIndex = uint32(this.DataOrOffset)
	}
	return this.singleFieldIndex, nil
}

/**
 * Structure type identifier. Often 0xFFFFFFFF (-1) for generic structs.
 * Used to identify struct types in schema-aware parsers.
 */

/**
 * Field index (if field_count == 1) or byte offset to field indices array (if field_count > 1).
 * If field_count == 0, this value is unused.
 */

/**
 * Number of fields in this struct:
 * - 0: No fields
 * - 1: Single field, data_or_offset contains the field index directly
 * - >1: Multiple fields, data_or_offset contains byte offset into field_indices_array
 */
