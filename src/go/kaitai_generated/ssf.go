// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"io"
)


/**
 * SSF (Sound Set File) files store sound string references (StrRefs) for character voice sets.
 * Each SSF file contains exactly 28 sound slots, mapping to different game events and actions.
 * 
 * Binary Format:
 * - Header (12 bytes): File type signature, version, and offset to sounds array
 * - Sounds Array (112 bytes): 28 uint32 values representing StrRefs (0xFFFFFFFF = -1 = no sound)
 * - Padding (12 bytes): 3 uint32 values of 0xFFFFFFFF (reserved/unused)
 * 
 * Total file size: 136 bytes (12 + 112 + 12)
 * 
 * Sound Slots (in order):
 * 0-5: Battle Cry 1-6
 * 6-8: Select 1-3
 * 9-11: Attack Grunt 1-3
 * 12-13: Pain Grunt 1-2
 * 14: Low Health
 * 15: Dead
 * 16: Critical Hit
 * 17: Target Immune
 * 18: Lay Mine
 * 19: Disarm Mine
 * 20: Begin Stealth
 * 21: Begin Search
 * 22: Begin Unlock
 * 23: Unlock Failed
 * 24: Unlock Success
 * 25: Separated From Party
 * 26: Rejoined Party
 * 27: Poisoned
 * 
 * References:
 * - https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/ssf/ssf_binary_reader.py
 * - https://github.com/OldRepublicDevs/PyKotor/blob/master/Libraries/PyKotor/src/pykotor/resource/formats/ssf/ssf_binary_writer.py
 */
type Ssf struct {
	FileType string
	FileVersion string
	SoundsOffset uint32
	Padding *Ssf_Padding
	_io *kaitai.Stream
	_root *Ssf
	_parent kaitai.Struct
	_f_sounds bool
	sounds *Ssf_SoundArray
}
func NewSsf() *Ssf {
	return &Ssf{
	}
}

func (this Ssf) IO_() *kaitai.Stream {
	return this._io
}

func (this *Ssf) Read(io *kaitai.Stream, parent kaitai.Struct, root *Ssf) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp1 = tmp1
	this.FileType = string(tmp1)
	if !(this.FileType == "SSF ") {
		return kaitai.NewValidationNotEqualError("SSF ", this.FileType, this._io, "/seq/0")
	}
	tmp2, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp2 = tmp2
	this.FileVersion = string(tmp2)
	if !(this.FileVersion == "V1.1") {
		return kaitai.NewValidationNotEqualError("V1.1", this.FileVersion, this._io, "/seq/1")
	}
	tmp3, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.SoundsOffset = uint32(tmp3)
	if !(this.SoundsOffset == 12) {
		return kaitai.NewValidationNotEqualError(12, this.SoundsOffset, this._io, "/seq/2")
	}
	tmp4 := NewSsf_Padding()
	err = tmp4.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Padding = tmp4
	return err
}

/**
 * Array of 28 sound string references (StrRefs)
 */
func (this *Ssf) Sounds() (v *Ssf_SoundArray, err error) {
	if (this._f_sounds) {
		return this.sounds, nil
	}
	this._f_sounds = true
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64(this.SoundsOffset), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp5 := NewSsf_SoundArray()
	err = tmp5.Read(this._io, this, this._root)
	if err != nil {
		return nil, err
	}
	this.sounds = tmp5
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.sounds, nil
}

/**
 * File type signature. Must be "SSF " (space-padded).
 * Bytes: 0x53 0x53 0x46 0x20
 */

/**
 * File format version. Always "V1.1" for KotOR SSF files.
 * Bytes: 0x56 0x31 0x2E 0x31
 */

/**
 * Byte offset to the sounds array from the beginning of the file.
 * Always 12 (0x0C) in valid SSF files, as the sounds array immediately follows the header.
 * This field exists for format consistency, though it's always the same value.
 */

/**
 * Reserved padding bytes (12 bytes of 0xFFFFFFFF)
 */
type Ssf_Padding struct {
	PaddingBytes []uint32
	_io *kaitai.Stream
	_root *Ssf
	_parent *Ssf
}
func NewSsf_Padding() *Ssf_Padding {
	return &Ssf_Padding{
	}
}

func (this Ssf_Padding) IO_() *kaitai.Stream {
	return this._io
}

func (this *Ssf_Padding) Read(io *kaitai.Stream, parent *Ssf, root *Ssf) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(3); i++ {
		_ = i
		tmp6, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.PaddingBytes = append(this.PaddingBytes, tmp6)
	}
	return err
}

/**
 * Reserved padding bytes. Always 3 uint32 values of 0xFFFFFFFF.
 * Total size: 12 bytes (3 * 4 bytes).
 * These bytes are unused but must be present for format compatibility.
 * Each padding byte should be 0xFFFFFFFF (4294967295).
 */
type Ssf_SoundArray struct {
	Entries []*Ssf_SoundEntry
	_io *kaitai.Stream
	_root *Ssf
	_parent *Ssf
}
func NewSsf_SoundArray() *Ssf_SoundArray {
	return &Ssf_SoundArray{
	}
}

func (this Ssf_SoundArray) IO_() *kaitai.Stream {
	return this._io
}

func (this *Ssf_SoundArray) Read(io *kaitai.Stream, parent *Ssf, root *Ssf) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(28); i++ {
		_ = i
		tmp7 := NewSsf_SoundEntry()
		err = tmp7.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Entries = append(this.Entries, tmp7)
	}
	return err
}

/**
 * Array of exactly 28 sound entries, one for each SSFSound enum value.
 * Each entry is a uint32 representing a StrRef (string reference).
 * Value 0xFFFFFFFF (4294967295) represents -1 (no sound assigned).
 * 
 * Entry indices map to SSFSound enum:
 * - 0-5: Battle Cry 1-6
 * - 6-8: Select 1-3
 * - 9-11: Attack Grunt 1-3
 * - 12-13: Pain Grunt 1-2
 * - 14: Low Health
 * - 15: Dead
 * - 16: Critical Hit
 * - 17: Target Immune
 * - 18: Lay Mine
 * - 19: Disarm Mine
 * - 20: Begin Stealth
 * - 21: Begin Search
 * - 22: Begin Unlock
 * - 23: Unlock Failed
 * - 24: Unlock Success
 * - 25: Separated From Party
 * - 26: Rejoined Party
 * - 27: Poisoned
 */
type Ssf_SoundEntry struct {
	StrrefRaw uint32
	_io *kaitai.Stream
	_root *Ssf
	_parent *Ssf_SoundArray
	_f_isNoSound bool
	isNoSound bool
}
func NewSsf_SoundEntry() *Ssf_SoundEntry {
	return &Ssf_SoundEntry{
	}
}

func (this Ssf_SoundEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Ssf_SoundEntry) Read(io *kaitai.Stream, parent *Ssf_SoundArray, root *Ssf) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp8, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.StrrefRaw = uint32(tmp8)
	return err
}

/**
 * True if this entry represents "no sound" (0xFFFFFFFF).
 * False if this entry contains a valid StrRef value.
 */
func (this *Ssf_SoundEntry) IsNoSound() (v bool, err error) {
	if (this._f_isNoSound) {
		return this.isNoSound, nil
	}
	this._f_isNoSound = true
	this.isNoSound = bool(this.StrrefRaw == uint32(4294967295))
	return this.isNoSound, nil
}

/**
 * Raw uint32 value representing the StrRef.
 * Value 0xFFFFFFFF (4294967295) represents -1 (no sound assigned).
 * All other values are valid StrRefs (typically 0-999999).
 * The conversion from 0xFFFFFFFF to -1 is handled by SSFBinaryReader.ReadInt32MaxNeg1().
 */
