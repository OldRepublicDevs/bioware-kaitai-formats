// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"


/**
 * DDS (DirectDraw Surface) files appear in two variants in KotOR:
 * 
 * 1. Standard DirectX DDS: Header magic "DDS " (0x44445320), 124-byte header
 * 2. BioWare DDS variant: No magic; width/height/bpp/dataSize leading integers
 * 
 * DDS files support DXT1/DXT3/DXT5 block compression, uncompressed RGB/RGBA,
 * and various other pixel formats. They can include mipmaps and cube maps.
 * 
 * References:
 * - https://github.com/OldRepublicDevs/PyKotor/wiki/DDS-File-Format.md - Complete DDS format documentation
 * - Standard DirectX DDS format specification
 */
type Dds struct {
	Magic string
	Header *Dds_DdsHeader
	BiowareHeader *Dds_BiowareDdsHeader
	PixelData []uint8
	_io *kaitai.Stream
	_root *Dds
	_parent kaitai.Struct
}
func NewDds() *Dds {
	return &Dds{
	}
}

func (this Dds) IO_() *kaitai.Stream {
	return this._io
}

func (this *Dds) Read(io *kaitai.Stream, parent kaitai.Struct, root *Dds) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp1 = tmp1
	this.Magic = string(tmp1)
	if !( ((this.Magic == "DDS ") || (this.Magic == "    ")) ) {
		return kaitai.NewValidationNotAnyOfError(this.Magic, this._io, "/seq/0")
	}
	if (this.Magic == "DDS ") {
		tmp2 := NewDds_DdsHeader()
		err = tmp2.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Header = tmp2
	}
	if (this.Magic != "DDS ") {
		tmp3 := NewDds_BiowareDdsHeader()
		err = tmp3.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.BiowareHeader = tmp3
	}
	for i := 0;; i++ {
		tmp4, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp4 {
			break
		}
		tmp5, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.PixelData = append(this.PixelData, tmp5)
	}
	return err
}

/**
 * File magic. Either "DDS " (0x44445320) for standard DDS,
 * or check for BioWare variant (no magic, starts with width/height).
 */

/**
 * Standard DDS header (124 bytes) - only present if magic is "DDS "
 */

/**
 * BioWare DDS variant header - only present if magic is not "DDS "
 */

/**
 * Pixel data (compressed or uncompressed).
 * For standard DDS: Format determined by DDPIXELFORMAT
 * For BioWare DDS: DXT1 or DXT5 compressed data
 */
type Dds_BiowareDdsHeader struct {
	Width uint32
	Height uint32
	BytesPerPixel uint32
	DataSize uint32
	UnusedFloat float32
	_io *kaitai.Stream
	_root *Dds
	_parent *Dds
}
func NewDds_BiowareDdsHeader() *Dds_BiowareDdsHeader {
	return &Dds_BiowareDdsHeader{
	}
}

func (this Dds_BiowareDdsHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Dds_BiowareDdsHeader) Read(io *kaitai.Stream, parent *Dds, root *Dds) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp6, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Width = uint32(tmp6)
	tmp7, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Height = uint32(tmp7)
	tmp8, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.BytesPerPixel = uint32(tmp8)
	tmp9, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.DataSize = uint32(tmp9)
	tmp10, err := this._io.ReadF4le()
	if err != nil {
		return err
	}
	this.UnusedFloat = float32(tmp10)
	return err
}

/**
 * Image width in pixels (must be power of two, < 0x8000)
 */

/**
 * Image height in pixels (must be power of two, < 0x8000)
 */

/**
 * Bytes per pixel:
 * - 3 = DXT1 compression
 * - 4 = DXT5 compression
 */

/**
 * Total compressed data size.
 * Must match (width*height)/2 for DXT1 or width*height for DXT5
 */

/**
 * Unused float field (typically 0.0)
 */
type Dds_Ddpixelformat struct {
	Size uint32
	Flags uint32
	Fourcc string
	RgbBitCount uint32
	RBitMask uint32
	GBitMask uint32
	BBitMask uint32
	ABitMask uint32
	_io *kaitai.Stream
	_root *Dds
	_parent *Dds_DdsHeader
}
func NewDds_Ddpixelformat() *Dds_Ddpixelformat {
	return &Dds_Ddpixelformat{
	}
}

func (this Dds_Ddpixelformat) IO_() *kaitai.Stream {
	return this._io
}

func (this *Dds_Ddpixelformat) Read(io *kaitai.Stream, parent *Dds_DdsHeader, root *Dds) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp11, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Size = uint32(tmp11)
	if !(this.Size == 32) {
		return kaitai.NewValidationNotEqualError(32, this.Size, this._io, "/types/ddpixelformat/seq/0")
	}
	tmp12, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Flags = uint32(tmp12)
	tmp13, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp13 = tmp13
	this.Fourcc = string(tmp13)
	tmp14, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.RgbBitCount = uint32(tmp14)
	tmp15, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.RBitMask = uint32(tmp15)
	tmp16, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.GBitMask = uint32(tmp16)
	tmp17, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.BBitMask = uint32(tmp17)
	tmp18, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.ABitMask = uint32(tmp18)
	return err
}

/**
 * Structure size (must be 32)
 */

/**
 * Pixel format flags:
 * - 0x00000001 = DDPF_ALPHAPIXELS
 * - 0x00000002 = DDPF_ALPHA
 * - 0x00000004 = DDPF_FOURCC
 * - 0x00000040 = DDPF_RGB
 * - 0x00000200 = DDPF_YUV
 * - 0x00080000 = DDPF_LUMINANCE
 */

/**
 * Four-character code for compressed formats:
 * - "DXT1" = DXT1 compression
 * - "DXT3" = DXT3 compression
 * - "DXT5" = DXT5 compression
 * - "    " = Uncompressed format
 */

/**
 * Bits per pixel for uncompressed formats (16, 24, or 32)
 */

/**
 * Red channel bit mask (for uncompressed formats)
 */

/**
 * Green channel bit mask (for uncompressed formats)
 */

/**
 * Blue channel bit mask (for uncompressed formats)
 */

/**
 * Alpha channel bit mask (for uncompressed formats)
 */
type Dds_DdsHeader struct {
	Size uint32
	Flags uint32
	Height uint32
	Width uint32
	PitchOrLinearSize uint32
	Depth uint32
	MipmapCount uint32
	Reserved1 []uint32
	PixelFormat *Dds_Ddpixelformat
	Caps uint32
	Caps2 uint32
	Caps3 uint32
	Caps4 uint32
	Reserved2 uint32
	_io *kaitai.Stream
	_root *Dds
	_parent *Dds
}
func NewDds_DdsHeader() *Dds_DdsHeader {
	return &Dds_DdsHeader{
	}
}

func (this Dds_DdsHeader) IO_() *kaitai.Stream {
	return this._io
}

func (this *Dds_DdsHeader) Read(io *kaitai.Stream, parent *Dds, root *Dds) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp19, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Size = uint32(tmp19)
	if !(this.Size == 124) {
		return kaitai.NewValidationNotEqualError(124, this.Size, this._io, "/types/dds_header/seq/0")
	}
	tmp20, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Flags = uint32(tmp20)
	tmp21, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Height = uint32(tmp21)
	tmp22, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Width = uint32(tmp22)
	tmp23, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.PitchOrLinearSize = uint32(tmp23)
	tmp24, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Depth = uint32(tmp24)
	tmp25, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MipmapCount = uint32(tmp25)
	for i := 0; i < int(11); i++ {
		_ = i
		tmp26, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.Reserved1 = append(this.Reserved1, tmp26)
	}
	tmp27 := NewDds_Ddpixelformat()
	err = tmp27.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.PixelFormat = tmp27
	tmp28, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Caps = uint32(tmp28)
	tmp29, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Caps2 = uint32(tmp29)
	tmp30, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Caps3 = uint32(tmp30)
	tmp31, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Caps4 = uint32(tmp31)
	tmp32, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Reserved2 = uint32(tmp32)
	return err
}

/**
 * Header size (must be 124)
 */

/**
 * DDS flags bitfield:
 * - 0x00001007 = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT
 * - 0x00020000 = DDSD_MIPMAPCOUNT (if mipmaps present)
 */

/**
 * Image height in pixels
 */

/**
 * Image width in pixels
 */

/**
 * Pitch (uncompressed) or linear size (compressed).
 * For compressed formats: total size of all mip levels
 */

/**
 * Depth for volume textures (usually 0 for 2D textures)
 */

/**
 * Number of mipmap levels (0 or 1 = no mipmaps)
 */

/**
 * Reserved fields (unused)
 */

/**
 * Pixel format structure
 */

/**
 * Capability flags:
 * - 0x00001000 = DDSCAPS_TEXTURE
 * - 0x00000008 = DDSCAPS_MIPMAP
 * - 0x00000200 = DDSCAPS2_CUBEMAP
 */

/**
 * Additional capability flags:
 * - 0x00000200 = DDSCAPS2_CUBEMAP
 * - 0x00000FC00 = Cube map face flags
 */

/**
 * Reserved capability flags
 */

/**
 * Reserved capability flags
 */

/**
 * Reserved field
 */
